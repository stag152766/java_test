
Занятие 1. 
Урок 1. Основы {

Написать программу 
Загрузить в память 
Хранить пока не запустится
ЦП начинает ее исполнять
Результат

Программа - набор инструкций и данных для обработки. На выходе получаем результат.

Уровни языков 
высокий (исходный код)
низкий (машинный код) 

Трансляция - перевод языка с высого на низкий уровень
Машинный код - код, исполняемый непосредственно процессором


Языки условно разделяются на: 
Компилируемый 
Интерпритируемый 

Способ 1
Исходный код программы пишется на каком-то языке программирования, инструмент который транслирует исходный код в машинный, называется компилятор. На выход он принимает программу на высокоуровневом языке, на выходе получается файл, сожержащий исполняемый код, который может исполняться ЦП. Компилятор порождает файл, который может самостоятельно исполняться. После создания файла компилятор не нужен. Компилятор нужен только разработчику. Пользователю нужен только скомпилированный исполняемый файл. Программа распостраняется в виде исполняемого файла. 

Способ 2
Интерпретатор читает исходный код, написанный на языке высокого уровня. Интерпретатор выполняет команды этого языка. На процессоре исполняется интерпретатор, а не какая-то программа, которая им порождается. Интерпретатор ничего не порождает, он сам работает и сам во время работ интерпретирует исходный код программы. Пользователю нужно установить интерпретатор. Программа распостряняется в виде исходных кодов. 

Способ 3
Одновременное наличие компилятора и интерпретатора. 
Исходный код программы с помощью компилятора преобразуется в байт-код. Байт код - промежуточное представление. Это низкоуровневый код, но еще не машинный код. Для исполнения байт кода нужен интерпретатор, который читает программу в байт коде и исполняет ее. В отличии от классического интерпритатора, низкоуровневый байт код легче и быстрее интерпретировать. 

Преимущества способа 3   
1. Простой и быстрый интерпретатор
2. Переносимость (кроссплатформенность). Исполняемый код для разных процессоров и ОС нужен разный. Если разработчики не ходят открыть свой код, и при этом они не сделали исполняемый код для вашей платформы, то сами сделать вы не сможете. 
А байт код, в отличии от обычного машинного кода, является универсальным. Компилятор универсальный, а интерпретатор под каждую платформу отдельный. В результате, программа распостраняется в одном единственном формате, возможность запуска определяется исключительно наличием интерпретатора для этой платформы.    
	
Java распостраняется в виде двух дистрибутивов. 
Java SDK (compiler + JRE ) для разработчиков.
Java Runtime Environment (JRE) для пользователей.


}
Урок 2. Установка Java SDK. Настройка окружения. {

Путь инсталяции
C:\Program Files\Java\jdk-11.0.1\

Настройка окружение

Путь к исполняемому файл 
C:\ProgramData\Oracle\Java\javapath\

Путь к JRE 
‪C:\Program Files\Java\jre1.8.0_181\bin\java.exe

Инсталятор настраивает окружение на JRE, так как это удобно пользователям для запуска java программ. Нам нужно перенастроить окружение так, чтобы вместо этого использовались исполняемые файлы JSK.

Для этого модифицируем переменную окружения path 
Control Panel\All Control Panel Items\System > Advanced system settings > System Properties > Environment Variables > Path

c:\Program Files\Java\jdk-11.0.1\

	

Создали путь для JSK

Путь к исполняемому файлу where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe

Путь к компилятору where javac
c:\Program Files\Java\jdk-11.0.1\bin\javac.exe


Поднимаем переменную JAVA_HOME вверх, чтобы в командной строке получилось
C:\Users\kobzev\Documents\temp>where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe
C:\ProgramData\Oracle\Java\javapath\java.exe






C:\Program Files\Java\jdk-11.0.1\}
Урок 3. {

Расширение .java указывает на то, что внутри хранится исходный код.


Пишем программу myFirstProject.java
public class myFirstProject {

	public static void main(String[] args) {
		System.out.println("Hello, world!");
	}
}


C:\Users\kobzev\Documents\temp>javac myFirstProject.java //компилируем

C:\Users\kobzev\Documents\temp>java myFirstProject //запускаем байт код
Hello, world!

}
Урок 4. Система хранение кода {

Зачем?
Резервная копия исходного кода
Ослеживание изменений (история)
Синхронизация, совместный доступ

Хранилище Git

Сервис GitHub

Add .gitignore - параметр определяет чего не нужно сохранять в репозитории (файлы компиляций/отчеты о выполнении тестов)


Поэтому создаем файл .gitignore описывающий что сохранять не нужно

Выбираем Gradle / Apache License 2.0

Клонирование - программа для локальной копии
}
Урок 5. Сборщики {

В больших проектах много файлов, дополнительных библиотек. При компиляции нужно указывать пути к файлам с исходным кодом, библиотекам, опции. 
Решение
Написать один конфигурационный файл, Gradle, который берет конфигурационный файл и компилирует с описанием.

Конфигурационный файл может описывать настройки запуска, тестов. 

Популярные сборщики для Java
Аpache Аnt
Apache Maven
Gradle

Подготовка проекта
sandBox

Создание конфигурационного файла sandBox.gradle

Сборщики являются универсальными инструментами, умеют работать с разными языками программирования.
Необходимо подлючить плагин 
apply plugin: 'java'
Этот плагин требует создание определенной структуры директорий. Он будет искать файлы с исходным кодом на языке java в определенном месте (будем использовать настройки по умолчанию).

Создаем структуру директорий
src > main | test

main > java //сюда кладем файлы с исходными кодами, кроме тестов
test > java //сюда кладем тесты

Перемещаем myFirstProject.java в директорию main
Переходим в корневую папку sandBox
Запускаем консоль и компилируем файл с помощью gradle
c:\Tools\gradle-4.10.3\bin\gradle build

В проекте sandBox появляется два подкаталога
первый содержит вспомогательные файлы, которые нужны gradle для работы
c:\Users\Admin\Documents\temp\sandBox\.gradle\

второй сожержит результат компиляции
c:\Users\Admin\Documents\temp\sandBox\build\classes\java\main\

Для того, чтобы запустить скомпилированный файл class используется плагин
apply plugin: 'application'

Для того, чтобы данный плагин знал, что запускать указываем настройку
mainClassMain = "myFirstProject"


c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle run
 
запускается перекомпиляция и на консоль выводится наш текст "Hello, world!"

Уложить все в репозиторий


gradle можно интегрировать в проект, так чтобы все необходимое для его запуска хранилось в самом проекте. Для создания такого запускателя, gradle все таки понадобится. После того как запускатель создан, отдельно стоящий gradle уже использоваться не будет. 

В консоли выполняем команду запускателя
c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle wrapper  

Внутри проекта sandBox появляются новые файлы, которые представляют собой запускатель.
Укладываем их в репозиторий.



c:\Users\Admin\Documents\GitHub\java_test\sandBox\gradlew build

Скачивается и устанавливается внутрь проекта отдельный сборщик gradle. В результате отдельный gradle уже не будет использоваться.

После того, как дистрибутив загружен он распаковывается внутрь проекта и используется для сборки и запуска.
c:\Users\Admin\Documents\GitHub\java_test\sandBox>gradlew run


---
Как прописать путь в переменную PATH

Открыть System Properties (WIN > PATH)
Открыть Environment Variables
System Variables NEW  (GRADLE_HOME / c:\Tools\gradle-5.2.1-bin\gradle-5.2.1\bin\)
Открываем для редактирования PATH > EDIT > NEW > %GRADLE_HOME%\bin
Переоткываем консоль WIN+R

--

Задачи 
gradle build // компилирует, тестирует и упаковывает код в JAR-файл
gradle wrapper //  загрузка и инициализация wrapper-скриптов

BUILD SUCCESSFUL // означает, что сборка прошла успешно


Чтобы увидеть результаты сборки, посмотрите на содержимое каталога build. Здесь вы найдете несколько директорий, среди которых три наиболее значимые:

classes. Скомпилированные .class файлы
reports. Отчеты в течении сборки(такие как отчеты о тестировании)
libs. Библиотеки для сборки проекта(обычно в виде JAR и/или WAR файлов)

dependency_cache - зависимости от бибилиотек

}
Урок 6. Среда разработки {

Основные
NetBeans
Eclipse
IJ


IJ позволяет оперировать двумя разными сущностями
проект - это группа модулей
модуль 

Выбираем New Project > Empty Project
Project Location: java_test //корневую директорию

Изменяем
Project Structure > SDKs + // указать где находится java
C:\Program Files\Java\jdk-11.0.1

Gradle Project 
Use auto-import enabled
Позволяет автоматически сихронизировать модуль, который мы создаем в среде разработки, с конфигурационным файлом build.gradle (когда изменения вносятся в конфигурационный файл, автоматически обновляется модуль).

Create durectories for empty content roots automatically
Используется когда есть пустой модуль с конфигурационным файлом

Create separate module содержит три типа модулей
для подкатолога src main
для подкатолога src test
общий

Открваем myFirstProject.class 
Запускаем в среде разработки IJ
Комитим в гитхаб

В GitHub видим последнии изменения, сохранять их нужно не все потому что они быстро меняются
workspace.xml // содержит информацию о том, какие файлы открыты в среде IJ
misc.xml 

помещение (push) 
получение (pull)

Скачать все ветки с origin, но не мержить их в локальный репозиторий:
fetch orgin 

}
Урок 7. Рассматриваем высокуровневую структуру {

В Java есть соответствие между файлами и классами. 
Если есть файл myFirstProject.java, то он должен содержать класс с таким же именем myFirstProject без расширения (не допускается несоответствие имен)

В одном файле может несколько классов, но только один public класс.

IJ автоматически сохраняет исходный код, компилирует его, и выводит сообщение об ошибке (при наличии)


Пакеты - с физической точки зрения соответствуют наборам директорий. Предназначены для того, чтобы избегать конфликты имен файлов и разрешить создавать файлы с одинаковыми именами. Рекомендуется классы помещать в индивидуальные пакеты.

Refactor > Move > Create New Package // ru.testjava.sandBox

Помещаем в папку src main, в которой создается иерархическая структура директорий. Таким образом, исключаются все конфликты между именами файлов. 


---
Урок 8. Рассматриваем содержимое файла исходного кода

Класс - основная структурная единица кода. Любой исполняемый код должен находится внутри какого-то класса. 

public class myFirstProject {}- открывая файл исходного кода обнаруживаете декларация одноименного класса. Внутри фигурный скобок находится описание класса (ограничитель для блока кода). 

Все конструкции заканчиваются ;

Метод = функция = блок кода (параметры) {конструкции, выражения}

метод main принимает на себя массив строке


Форматирование 
Code > Reformat Code  

Правила именования
классы всегда с большой буквы
все остальное с маленькой буквы

СamelCase

}
Урок 9. {

В java есть определенные правила вычислений. Если в выражении есть целые числа, то результат должен является тоже целым числом.
В ПК целые и дробные числа хранятся по разному. Для хранения дробных чисел используется представление чисел с плавающей точкой (2*10^3)

System.out.println("2" + 2) > 22 //число преобразуется в строку, и две строки склеиваются

}
Урок 10. Переменные и значения {

Значения - это выражение которое нельзя упростить. Часть даных, которая хранится в памяти компьютера. 

System.out.println("2" + 2)

("2" + 2) - выражение, получаемое путем склеивания двух значений
Когда выражение выполняется, то результатом склейки является новое значение.

Литеральные значения - явно описанные в коде программы.
Вычисляемые значения - получаемые в результате вычисления каких-то значений.

Переменная - именнованная ячейка памяти, в которой можно хранить присваемое значение. 
Переменная - ссылка / адрес где хранится объект(ссылка на объект).
Переменная - идентификатор / имя ссылающееся на какое-то значение.

В java все значения участвующие в вычислении должны быть известны.

}
Урок 11. Типы переменных и значений {

Java язык со строгим контролем типов / со строгой типизацией

int В = 8

int указание на тип переменной, в нее можно поместить только тип целых числел

Типы значений
целые числа 
числа с плавающей точкой
строки, заключенные в кавычки


Для них опеределены разные операции , и даже одинаковые операции выполняются по разному


Java для каждого значения значет значение, оно по разному представляется внутри компьютера.

Тип значения не совместим с типом переменной
int B = 8.0 или
int B = "Hello"


Переменная типа int может ссылаться только на значение с целым числом.


double - число двойной точности (с плавающей точкой)

Языки со строгой типизацией - это языки, которые отслеживают несоответствие типов на этапе компиляции, а не на этапе выполнения когда выражение будет реально вычисляться.
}
Урок 12. Среда разработки {

Отладчик (Debug) - позволяет выполнять программу последовательно, строчку за строчкой. И во время отладки смотреть какие значения преобретают переменные. Пользуются чтобы понять что происходит во время выполнения программы.

Точка останова

Нажать Step Over чтобы выполнить одну строку. 
Выполнилась та строка, в которой определяется переменная somebody. И эта переменная теперь видна в отладчике. Мы можем посмотреть ее значение. 


}
Урок 13. Функции именованные куски кода {

Создадим функцию, которая выполняет строку System.out.println("Hello, world!");  

Чтобы создать функцию, выводящую на экран приветствие по имени, нужно
Объявим переменную 
String somebody = "world";

Переменная somebody определена внутри функции, и значение ей присвается внутри функции.

public static void hello() {
		String somebody = "world";
		System.out.println("Hello, " + somebody + "!");
	}

Для того, чтобы значение можно было менять из вне, нужно ее объявить по другому:
 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world"); 					//место где функкия вызывается, передаем конкретное значение этого параметра 
	}

	public static void hello(String somebody) { //где somebody - параметр, аргумент функции
		System.out.println("Hello, " + somebody + "!");
	}

}

Теперь функция main обращается к функции hello, и передает туда строчку world. Эта строчка присвается, в качестве значения, параметру somebody. Далее это значение используется в коде функции. 

Void - нично, пустота. Функция не возвращает никакого значения. 

public static double area(double b){
		return b * b;
	}

Тип возвращаемого результата, указывается перед именем функции area.



package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world");
		hello("user");
		hello("Max");

		double l = 5; // переменная#1 - l (за пределами функ main она не существует)
		System.out.println("Площадь квадрата со стороной " + l + " = " + area(l));
	}

	public static void hello(String somebody) {
		System.out.println("Hello, " + somebody + "!");
	}

	public static double area(double l){ //переменная#2 - l (за пределами функ area она не существует) 
		return l * l; 
	}
}

Область видимости для переменной ограничевается телом функции (фигурными скобками, внутри которых она определена).
Переменная#1 и переменная#2 между собой никак не связаны.
Те переменные, которые указаны как параметры функции, тоже считаются относящиеся к ней.

Следующий шаг.

Создаем функцию, которая вычисляет площадь прямоугольника.

public static double area(double len){
		return len * len;
	}

	public static double area(double a, double b) {
		return a * b;
	}
	
Имеется две функции с одниковыми именами. Java их отличает, потому что у них разные параметры. 

Обратимся ко второй area

double a = 	b


}
Урок 14. Классы, объекты, конструкторы {

Объект - сложная структура хранения информации (дата), состоит из значений - полей / атрибутов (дд / мм / гггг). Объекты принадлежат  определенному типу.

Объекты могут хранить разные типы данных, поэтому у них может быть разная структура.

Для описания структуры однотипных объектов используется конструкция - класс.

Класс - это описание структуры однотипных объектов. Объекты - экземпляры, представители класса.

Создадим классы, описывающие объекты, площадь для которых мы вычисляем.

Создадим класс типа Квадрат

public class Square { //класс, который описывает структуру объектов, хранящих информацию о квадратах
    public double l; //внутри класса описываем атрибуты, которыми обладает объект этого типа. Квадрат описывается длиной его стороны.
}

Создадим класс типа Прямоугольник

public class Rectangle {
    public double a; //прямоугольник описывается двумя сторонами
    public double b; 
}

После описания классов, можно создавать объекты, которые являются представителями или экземплярами этих классов.

Square s = new Square(); // создаем объект типа Square
s.l = 5; // обращаемся к первой area, устанавливает значение атрибута l равное 5  
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

public static double area(Square s){ //функция area принимает не сторону, а объект типа Квадрат
		return s.l * s.l; //для того чтобы обеспечить доступ к атрибуту этого объекта указываем объект.атрибут 
}

	
	
Когда идет речь об объектах сложной структуры, то передавать в качестве параметра в вызываемую функцию один объект, лучше чем 10-20 параметров, которые описывают атрибуты этого объекта.   

В дальнейщем будем работать с объектами, которые имеют много атрибутов.


Rectangle r = new Rectangle(); // сначала создается объект класса 
	r.a = 4; // потом указываются (заполняются) значения атрибутов**
	r.b = 6;

	
Следующим шагом оптимизируем те части когда, где создаются объекты.
Square s = new Square(); 
	s.l = 5;

Rectangle r = new Rectangle();
	r.a = 4;
	r.b = 6;

	
**Можно сделать другим способом
Внутри класса объявим псевдофункцию - конструктор. 
Конструктор предназначен для того, чтобы заполнить атрибуты нового создаваемого объекта некоторыми значениями, которые передаются в качестве параметра в этот контсруктор. 

Было

public class Square(){
	public double l;
}

Стало

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


Конструктор - это специальная функция, которая имеет имя класса и не имеет возвращаемого значения. Тип возвращаемого значения не указывается. Конструктор может принимать параметры. 
Внутри фигурных скобок необходимо написать код, который инициализирует новый объект. То есть заполняет его атрибуты какими-то значеняими.

Теперь нельзя создать Square s = new Square(); потому что конструктор объектов этого типа требует, чтобы ему были переданы значения параметров.

Было
Square s = new Square(); 
	s.l = 5;
	
 
Стало
Square s = new Square(5); //атрибуты заполняются в конструкторе

 
Ключевое слово this 
это тот объект, который инициализируется в конструкторе
это ссылка на переменную, объявленную для всего класса

было

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


стало

public class Square(){
	public double l;
	
	public Square(double len){
	this.l = len;	
	}
}
 
Когда у нас есть какая то переменная s, которая ссылается на объект, то обращаться к атрибуту мы можем через эту переменную s.l
Square s = new Square(5);
s.l

Но в конструкторе в качестве специальной переменной, которая ссылается на конструируемый объект, выступает ключевое слово this.   

было
public class Square(){
	public double l;
	
	public Square(double len){ //len параметр контсруктора
	this.l = len;	
	}
}



стало 
 public class Square(){
	public double l;
	
	public Square(double l){
	this.l = l;	//так выглядит присваемое значение в атрибут. название аргумента конструктора совпадает с названием атрибута   
	}
}

В первом случае l атрибут, во втором l - переменная, которая объявлена как аргумент функции (переменная, являющаяся аргументом функции). 
Написать l=l нельзя тогда в обоих случах будет использоваться переменная  (double l)
Для того, чтобы присвоить переданное значение именно в атрибут объекта, нужно сослаться на этот объект this.l 
Значение атрибута создаваемого объекта, равно значению параметра переданного в конструктор.


В итоге, получаем
	
package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
	Square s = new Square(5);
	System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

	Rectangle r = new Rectangle(4,6); //длины сторон прямоугольника передаются в качестве параметра в конструктор 
	System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + area(r));
	}


	public static double area(Square s){ // функция принимает не сторону квадрата, а объект типа Квадрат
	return s.l * s.l; // для того чтобы получить доступ к атрибуту объекта, необходимо написать объект.атрибут
	}

	public static double area(Rectangle r) {
	return r.a * r.b;
	}
}


public Square(double l) { 
    this.l = l;
}
	
public Rectangle(double a, double b) {
	this.a = a;
	this.b = b;
	
}


}	
Урок 15. Методы. Функции объектов. {
 	
Функция - именнованный фрагмент кода.
Метод - это функция, связанная (ассоциированная) с каким-то объектом.

Для того, чтобы превратить обычные функции в методы необходимо
1) перенести функцию во внутрь класса, которая описывает соответствующие объекты
2) модификацировать функцию


Переносим функцию в конец класса
Переделка: убираем слово static и параметр функции, добавляем ссылку (this)


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/
 
    }
}


После переделки нужно научится использовать этот метод, вместо той функции из которой он был сделан 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		
		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); /* s.area())(параметр объекта.название метода) - место где вызывается функция (код вызова).  Обращаемся к методу , который ассоциирован с объектом.
		
		*/
		
		
	}

}

Вместо того, чтобы передавать s в качестве параметра area(s), мы его указываем перед названием s.area(). Вместо обращениния к атрибуту объекта, мы обращаемся к методу, который ассоциирован с этим объектом. 

Когда Java видит конструкцию s.area() она находит функцию area(), которая находится в классе Square, соответствущему этому объекту, и вызывает эту функцию public double area(){return this.l * this.l;}
А тот объект, в котором эта функция (метод) вызывалась, становится доступен через специальный идентификатор this.

Ключевое слово static исчезло, потому что оно используется чтобы помечать фукнции, которые не ассоциированы не с каким объектом. К которым можно обращаться напрямую.  

К методам можно обращаться только указав перед ними объект, в котором этот метод вызывается s.area(). 


package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {

		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); // обращаемся к методу, который ассоциирован с объектом

		Rectangle r = new Rectangle(4, 6); // чать когда, где функция вызывается
		System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + r.area());
	}
}


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/

    }
}


package ru.testjava.sandBox;

public class Rectangle {

    public double a;
    public double b;

    public Rectangle(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double area() {
        return this.a * this.b; //ссылка на объект доступно через ключевое слово this. ссылка на тот объект, в котором этот метод вызван
    }
}

В двух классах Square и Rectangle находятся функции с одинаковыми именами и без параметров area(). Эти функции между собой не конфликтуют, потому что они находятся в разных классах и Java легко определяет какую из этих функций следует вызывать. 

Если вызывается метод в объекте s.area(), который является экземляром класса Square, значит будет выполняться функция с именем area(), которая находится в классе Square.
Если обращаемся к методу объекта, который имеет тип (является представилем класса) Rectangle, значит будет выполняться функция находящаяся в классе Rectangle.

}


Занятие 2.
Урок 16. Что такое автотесты? {

Стек автотестирования - общий набор инструментов, которые задействованы при создании автотестов.
//стек - структура данных, организаванных по принципу "последний поступил -  первым обслужен"

Стек автотестирования состоит:

6. Сервер непрерывной интеграции - для автозапуска тестов из хранилища

	6.1 Хранилище - для хранения и распостранения 
	6.2 Среда разработки - для написания, отлаживания, запуска тестов по отдельности 


5. Сборщик - может использоваться для компиляции и запуска тестов. Удобно когда нужно запустить все тесты сразу.

4. Фреймворк - для запуска тестов. Его задача найти, запустить тесты и сгенерировать отчет. 

3. Тесты - написаны на языке програмирования, должны взаимодействовать с ТС. 

2. Драйверы тестируемой системы - инструменты, которые помогают взаимодействовать с ТС по сети или через пользовательский интерфейс (написанной на другом языке?)

1. Тестируемая система (ТС)


Взаимодействие на прямую означает через программый интерфейс.

Программа, в рамках которой запускаются и работают тесты состоит из фреймворка, тестов, драйвера.
При выполнении тестов, основной запускаемой программой является фреймворк.


}
Урок 17. Gradle подключаем зависимости {

Доработаем проект для использования автотестов функций area()
Подлючаем доп зависимость от тестового фреймворка TestNG


Готовый к употреблению, скомпилированный код для языка Java распостраняется в виде библиотек.
Физически они представляют собой архивы, в формате .jar
Технически это обычный zip архив который имеет специфическую структуру, использует расширение .jar

Сайт для поиска библиотек в репозитории сборщика
https://search.maven.org

Находим TestNG
Копируем текст в конфигурационный файл сборщика
Указываем зависимость в специальном блоке "декларация зависимости"


dependencies {
    implementation 'org.testng:testng:7.0.0-beta1'

}

Перед декларацией указываем какой репозиторий следует использовать
repositories {
    mavenCentral()
}

Через некоторое время библиотеки подключатся.

После установки библеотек, рекомендуется их проиндексировать
File > Settings > Build, Executiosn > Build tools > Maven > Repositories

Указывается репозитории, которые используются сборком
локальный 
удаленный

При отсутствии библиотеки в локальном репозитории, среда разработки обращается к удаленному репозиторию. Чтобы было быстрее искать, IJ загружает список всех имеющихся библиотек и индексируюет его.

Загрузка библиотек из удаленого репозитория в локальный.
Эта автоматическая сихронизация модуля в среде разработки с конфигурационным файлом build.gradle происходит благодаря тому, что во время импорта модуля была поставлена галочка Auto Import. 
Но автосинхронизация работает не всегда. Список зависимостей обновляется не всегда , несмотря на внесение изменений в конфигурационный файл. 

Выполнение синхронизации в ручную 
View > Tool Windows > Gradle > Refresh  

Документация сборщика для того, чтобы копировать фрагменты конфигурационного файла  
https://docs.gradle.org/current/userguide/building_java_projects.html


}
Урок 18. Фреймворк для запуска тестов TestNG {


Поместить первый тест в поддиректорию test > java 
Создать пакет ru.testjava.sandBox
В нем создать класс SquareTests. В Java любой код оформляется в виде классов.

Метод main делать не нужно, потому что запускается тестовый фрейворк. Он находит все тесты, выполняет и генерирует отчет.
В тестовом классе нужно написать методы, которые буду являться тестами.
Каждый метод в отчете будет представлен как отдельный тест.

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class SquareTests {

  @Test
  public void testArea(){
    Square s = new Square(5);
  }
}

В тестовом методе нет параметров и возвращаемого результата. О результатах своей работы, он сообщает тестовому фреймворку особым образом.

Создаем новый квадрат
Square s = new Square(5);
Проверяем площадь
assert s.area() == 25; // ключевое слово assert - логическое выражение "утверждение". Знак == для сравнения величин, а = для присваивания

Нужно пометить метод, чтобы фреймворк понял что это тест.
Перед методом нужно написать аннотацию  
Аннотация - это особый класс, которые используются как псевдо комментарии 
Не создаем объекты этого типа, просто указываем название этого класса перед чем нибудь  
Фреймворк по аннатациям находит нужный метод, это для него сигнал что это тест и его нужно запустить


Можно писать короткие имена классов
@Test //Enter - автопродолжения

Появляется конструкция, чтобы их импортировать 
import org.testng.annotations.Test; //полное название класса

или писать название классов полностью
@org.testng.annotations.Test //тогда конструкция import не нужная

После запуска теста появляется отчет 
Default Suite
Total tests run: 1, Failures: 0, Skips: 0

Но в случае упавшего теста AssertionError, не видно результата выполнения метода area().


Для отображения подробного сообщение об ошибке (expected, actual result) используется вспомогательный класс Assert

import org.testng.Assert;

Assert.assertEquals(s.area(),25.0); //начинаем писать Asserе. и включается механизм автопродолжения + Enter

Сравниваем значение площади, которое вычислено и ожидаемое значение


К функции assertEquals() можно обращаться на прямую, так как в ее описании есть ключевое слово static (подсказка ЛКП + Ctrl)
То есть чтобы воспользоваться этой функцией, не нужно создавать какой-то объект. 

Так как функция находится в классе Assert, а не в текущем классе SquareTests, значит перед ней нужно указать в качестве префикса имя класса Assert.assertEquals() Имякласса.функция




package ru.testjava.sandBox;

import org.testng.Assert; //класс Assert импорт добавляется автоматически 
import org.testng.annotations.Test; //класс Test

public class SquareTests { 

  @Test
  public void testArea(){
    Square s = new Square(5);
    Assert.assertEquals(s.area(),25) ;


  }
}


Результат упавшего теста
java.lang.AssertionError: expected [25] but found [25.0]
Expected :25
Actual   :25.0


Тестовый фремворк контролирует совпадение типов данных
Если Expected 25, а Actual 25.0, то тест считается упавшим.


}
Урок 19. Среда разработки {

Показать варианты исправления ошибки Alt + Enter

Список продолжения Ctrl + Space


}
Урок 20. Selenium драйвер для браузеров {

Скачать пакет
https://www.apachefriends.org/ru/download_success.html

Инструкция по установки
https://selenium2.ru/articles/136-installing-xampp.html


Установка приложения addressbook на сервер XAMPP

Распаковать addressbook в папку
c:\xampp\htdocs\  

Подготовка базы данных
MySQL > Admin (http://localhost/phpmyadmin/)

Create New database > addressbook

Создать структуру базы данных (импортировать)
Import > addressbook.sql

http://localhost/addressbook/
admin / secret

Если вход выполнился успешно, значит логин / пароль прочитались из базы данных. Приложение базу данных видит.


Начнем с подготовки нового модуля
Создаем подкаталог (модуль) java_test > addressbook-web-tests
Помещаем туда самое главное -  конфигурационный файл сборщика, потом сможем импортировать его в среду разработки



Перекладываем конфиг файл
build.gradle
и запускатель 
подкаталог gradle 
и запускаемые файлы для платформ win и linux
gradlew
gradlew.bat


Удаляем 
apply plugin: 'application'
mainClassName = "ru.testjava.sandBox.MyFirstProject"
	
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.testng:testng:6.14.3'
}

Скачиваем chromedriver.exe 
https://sites.google.com/a/chromium.org/chromedriver/downloads

Сохраняем в папку
c:\Tools\chromedriver_win32\



Устанавливаем Katalon Recorder
Записываем процесс создания группы http://localhost/addressbook/group.php
Сохраняем запись в формате java-testng.class и помещаем ее в каталог с нашим тестом

Открываем сгенерированный код в среде разработки
Добавляем строку, указываем путь с ChromeDriver и 
    System.setProperty("webdriver.chrome.driver", "c:\Tools\chromedriver_win32\chromedriver.exe");
    driver = new ChromeDriver();

Добавляем в конфиг файл две зависимости
    implementation 'com.katalon:com.katalon.platform.parent:1.0.1'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'

}
Урок 21. Фикстуры инициализация и зачистка {

Исправим ошибку в сгенерированном коде тестового метода @Test (аннотация Тест)

имя должно быть отличное от имени класса, и начинаться с маленькой буквы

Кроме тестового метода @Test сгенерировались два вспомогательных (пометки/подсказки для тестового фрейворка)
BeforeClass //метод инициализации фикстура, единственное место для указания используемого драйвера - браузера
AfterClass //метод завершения фикстура


Зачистка
Если код дублируется, то его нужно постараться выделить в отдельную функцию. Его можно использовать повторно, обращаясь к этому методу. В случае с тестовым фрейворком, он автоматически вызывает методы BeforClass / AfterClass перед каждым запуском тестового метода.

Фикструр - тестовая ситуация, тест зажимается между двумя методами Before - After. 


Модифицируем код 
Действия для авторизации не являются частью теста создания группы, поэтому вырезаем и переносим кусок кода в метод инициализации фикстура @Before.


}
Урок 22. Рефакторинг {

Правила безопасного преобразования кода. Структура кода меняется, но функциональность остается неизменной.

С помощью механизма рефакторинга научимся выделять вспомогательные методы.

Рекодер записывает сценарий, который трудно читается.
Для удобства пользования мы дадим имя фрагменту кода, сделаем именнованный фрагмент кода. Для этого нужно превратить его в функцию и в нужное время к этой функции обращаться.

Выделяем фрагмент кода для превращения в именнованную функцию
Refactor > Extract > Method (Ctrl + Alt + M)

Фрагмент кода получил собственное имя - там выволняется логин

@BeforeClass
...
login(); // вызов созданного метода (место, в котором к этому фрагменту нужно обратиться)

Почему метода, а не обычной функции?
Внутри метода используется переменная driver, которая является атрибутом объекта типа GroupCreationTests.  

private void login() {
    driver.findElement(By.name(user)).click();
    driver.findElement(By.name(user)).clear();
	
	...
}

Тестовый фрейворк сначала создает объект класса 
Потом выполняет метод 
setUp(){
	инициалируется атрибут объекта driver = new ChromeDriver();
}
Когда вызывается другой метод login() в том же самом объекте, он может этим атрибутом пользоваться.
Также нужно поступить с тестовым методом, выделить из него вспомогательные фукнции.

Первый механизм рефакторинга - это выделение вспомогательных методов.

Следующий шаг

Делаем метод login() параметрализованным, чтобы имя пользователя и пароль передовались внутрь метода в качестве параметров. 

Выделяем значение, которое необходимо превратить в передаваемый параметр
Refactor > Extract > Parameter (Ctrl + Alt + P)
Даем имя username
   

login("admin"); //В точке вызова передается конкретное значение, которое подставляется в эту переменную параметр и используется в методе login
private void login(String username){
	driver.findElement(By.name(user)).sendKeys(username);
}


Тестовый метод создает группу с какими-то свойствами name, header, footer
Значение этих свойств явно прописаны в коде метода
private void fillGroupForm() {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys("test1");
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys("test2");
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys("test3");
}

Было бы более логично передавать их в качестве параметров, чтобы функция fillGroupForm стала универсальной. Ее можно было бы использовать для создания групп с разными параметрами, то есть заполнять форму разными данными. Конкретные значения передавались бы из @Test.

private void fillGroupForm(String name, String header, String footer) {
    driver.findElement(By.name("group_name")).sendKeys(name);
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys(header);
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys(footer);
  }


Создаем новый контакт
У формы контакта много параметров
Как превратить много параметров в мало?

Вместо того, чтобы передавать много отдельных значений, их можно объединить в один объект, который будет иметь много атрибутов. То есть создать вспомогательный класс, который описывает объект типа Group. Объекты этого типа имеют набор атрибутов.

!В метод будет передаваться один объект
ПКМ на fillGroupForm
Refactor > Extract > Parameter Object 

Указываем имя классу, который будет описывать совокупность значений GroupData
Отмечаем те значения, которые должны быть объеденены
Default valuse for parameter -  Leave blank
Рефакторинг закончен

Теперь метод принимает один объект типа GroupData
public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

Это объект 

public class GroupData {
  private final String name; //имеет три атрибута
  private final String header;
  private final String footer;

  //конструктор, который позволяет проинициализировать объект какими то значениями
  public GroupData(String name, String header, String footer) { 
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  //методы, которые возвращают эти атрибуты
  public String getName() { //геттер не имеет параметров и возвращает значение одной переменной (одного поля)
    return name;
  }

  public String getHeader() {
    return header;
  }

  public String getFooter() {
    return footer;
  }
}  
 


А в @Test при вызове fillGroupForm создается новый объект, атрибуты которого заполняются конкретными значениями


@Test
public void testGroupCreation() throws Exception {
returnToGroupPage("groups");
initGroupCreation("new");
fillGroupForm(new GroupData("test1", "test2", "test3")); //данные для передачи во вспомогательные методы
...
}


Эти значения потом используются в методе fillGroupForm()



private void fillGroupForm(GroupData groupData) {
driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
driver.findElement(By.name("group_header")).sendKeys(groupData.getHeader());
driver.findElement(By.name("group_footer")).sendKeys(groupData.getFooter());
...	
}



}
Урок 23. Наследование общий базовый класс {

Поместим тесты в разные классы
- создание группы
- удаление группы
Куда поместить вспомогательные функции, чтобы они были доступны в нескольких классах?

Начнем с создания теста для удаления групп. Запишем его рекодером.
Запись теста экспортируем в язык программирования java+testng
Помещаем сгенерированный код в наш пакет
Исправляем имя пакету

Когда создается объект типа GroupDeletionTests, то в этом объекте нельзя вызывать функции, находящиеся в другом классе. Они с этим объектом никак не ассоциированы. 

Наследование - механизм, позволяющий сделать общее пространство для нескольких классов. Туда можно поместить методы и атрибуты. Класс наследник - это тот класс, который расширяет базовый.

Наследование - это процесс, в ходе которого один объект преобретает свойства другого объекта. 

Чтобы воспользоваться механизмом наследования, нужно создать дополнительный класс в который будут помещены общие методы. Класс GroupCreationTests будет расширять этот новый класс. 

public class GroupDeletionTests extends TestBase {}
 
Создадим общий (базовый) класс TestBase 
Поместим туда методы, которые хотим сделать общими
GroupDeletionTests > Refactor > Pull Members Up 
Отмечаем все, кроме test

public class GroupCreationTests extends TestBase { //тестовый класс расширяет (является наследником) базовый класс TestBase 
}
С технической точки зрения это означает, что все методы, которые описаны в базовом классе, становятся членами класса наследника. 
Когда создается объект GroupCreationTests, то с ним ассоциируются все атрибуты и методы, которые находятся и в базовом классе. 

Переходим ко второму тесту GroupDeletionTests.
Для того, чтобы воспользоваться теми методами, которые помещены в класс TestBase нужно написать, что класс GroupDeletionTests расширяет базовый класс TestBase.
Удаляем лишнее, то что уже есть в базовом классе.

Чистим тестовый метод testGroupDeletion()
-удаляем строки, где выполняется вход в систему. Потому что эти действия в методе, с аннотацией @BeforeMethod
К моменту начала выполнения тестового метода все будет уже готово.
-заменяем строки на уже существующие методы
-новые методы преобразуем во вспомогательные функции Ctrl+Alt+M // покабез параметров?


Созданные вспомогательные функции можно перенести в базовый класс. Меняем модификатор прав доступа.
GroupDeletionTests > Refactor > Pull Members Up 


Модификаторы видимости 
public - класс/атрибут/метод доступны откуда угодно
private - доступно из методов, которые находятся в том же самом классе
protected - доступно из методов того же самого класса и из классов наследников

protected void deleteSelectedGroups(String delete) {}

К ним можно обращаться не только из методов, находящихся в том же самом классе, но и из тех методов, которые находятся в классе наследников. 


Code > Reformat Code 
Code > Optimize Inports


Класс наследник содержит то, что описано в нем, а также то что содержится в базовом классе.
Если создается объет, то с ним ассоциированы не только не методы/атрибуты, которые описаны в нем самом, но и те методы/атрибуты, которые описаны в базовом классе.


}
Урок 24. Делегирование вместо наследования {

В разных классах могут возникать одинаковые вспомогательные фукнции. Для того, чтобы избежать дублирования кода мы используем
общий базовый класс, в который помещены вспомогательные функции. Они могут использоваться в разных тестовых классах. Но это ведет к новой проблеме. По мере того, как количество тестов увеличивается - количество вспомогательных методов тоже растет. Общий базовый класс становится слишком громоздким.       

1. Большой класс трудно читать и понимать 
2. Потенциальные конфликты при использовании вспомогательных методов несколькими пользователями

Предлагается решение, раскидать вспомогательные функции по дополнительным узкоспециализированным классам. 

1 этап
Из класса TestBase перенесем все вспомогательные фукнции в новый вспомогательный класс ApplicationManager
Вместо наследования будет работать механизм делегирования

2 этап
Новый класс ApplicationManager раздробим на более мелкие узко специализированные классы.


1 этап 
1 шаг
Временно сделаем еще один базовый класс и перенесем функции вверх. А потом передвинем сверху в бок.
После всех преобразований в классе TestBase должно остаться две функции setUp() и tearDown(). 
В этих функциях выполняется много действий, сначала надо вынести эти действия во вспомогательные фукции, которые потом вместе с остальными переедут в новый вспомогательный класс. Тем самым TestBase разгрузится практически полностью.
 

Выделяем содержимое метода setUp() {то что в скобках} Ctrl+Alt+M делаем вспомогательный метод init()
Тоже с tearDown(), новый вспомогательный метод называем stop()

Временно создаем базовый класс ApplicationManager
TestBase expects ApplicationManager

Перемещаем в новый класс все кроме setUp() и tearDown()

И применяем еще один рефактор 
Refactor > Replace Inheritance with Delegations

Заменяем наследование на делегирование. При этом будет создано новое поле (атрибут) назовем его app. Никакие галочки ставить не нужно.

Делегирование - механизм, при котором объекту вспомогательного класса делегируются определенные действия, которые он должен выполнить.


package ru.testjava.addressbook;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
public class TestBase { //исчезла ссылка на расширение класса ApplicationManager, вместо этого
  protected final ApplicationManager app = new ApplicationManager(); // создается ссылка на новый объект типа ApplicationManager
  @BeforeClass(alwaysRun = true)
  public void setUp()  {
    app.init(); /* те вызовы , которые выполнялись в текущем классе (как бы this.init())
    теперь вместо этого вызываются методы, находящиеся в объекте типа ApplicationManager */
  }
  @AfterClass(alwaysRun = true)
  public void tearDown() {
    app.stop();
  }
}

Также произошли изменения в тестах 

package ru.testjava.addressbook;
import org.testng.annotations.Test;
public class GroupCreationTests extends TestBase {
  @Test
  public void testGroupCreation() {
    app.gotoGroupPage("groups"); //просим объект типа ApplicationManager, чтобы он выполнил какое-то действие (обращаемся к нему)
    app.initGroupCreation("new");
    app.fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.submitGroupCreation("submit");
    app.returnToGroupPage("group page");
  }
}

Все вспомогательные фукнции теперь находятся в классе ApplicationManager

Фактически мы разделили код на два слоя
Первый слой - логика тестов. Включает в себя тесты (тестовые классы), которые содержат тестовые методы, сценарии короткие и понятные. Класс Test Base перед каждым тестовым методом инициализирует объект типа ApplicationManager, а после того как метод отработал останавливает его, разрушает.
Второй слой - логика (код) взаимодействия с тестируемой системой.  

Разделим свои физически, разнесем из по разным пакетам

protected - пометка, которая разрешает использовать этот метод не только в классах наслениках, но и в классах находящихся в том же самом пакете.   

Если мы собираемся перенести метод в другой пакет, нужно сделать методы public

ApplicationManager > appmanager
..Tests > tests
GroupData > model

Класс GroupData используется везде. Для того, чтобы обозначить его предназначение поместим его в model.  
Он представляет собой модель какого-то объекта предметной области. 


}
Урок 25. Расщепление и специализация {

Раздробим класс ApplicationManager (АМ) на несколько более простых классов и раскидаем по ним вспомогательные функции. 

Для этого используем механизм делегирования. Класс ApplicationManager будет делегировать какие-то действия своим помощникам. 
Создавать помощников мы будем как в предыдущем уроке. Создается временный базовый класс, в который переносятся какие то методы. Потом наследование заменяется на делегирование.

Самое сложное это определить какие вспомогательные классы нам нужны, и какие методы куда переносить. 
Проще всего перенести те методы, которые используются при работе с группами initGroupCreation, initGroupForm, returnToGroupPage 

public class ApplicationManager extends GroupHelper //создаем новый базовый класс
 
Переносим в новый класс методы, связанные с группами 
Заменяем наследование делегированием 
ПКМ ApplicationManager
Refactor > Replace Inheritance With Delegations

Среда сообщает, что после этого действия в тестах возникнут проблемы. Они не смогут получить доступ к перенесенным методам. 
Нужно поставить галочку Generate getter for delegated component**

**для него генерируется вспомогательный метод, дающий доступ к этому полю

Тестовые класса изменились, например GroupCreationTests


  @Test
  public void testGroupCreation() {
	app.gotoGroupPage(); // если АМ может выполнять действие сам
    app.getGroupHelper().gotoGroupPage("groups"); /* для других действий происходит делегирование в два этапа 
	Сначала происходит обращение к АМ, чтобы он дал доступ к помошнику по работе с группами GroupHelper, и уже этому помощнику делегируется выполнение настоящего действия , где происходит взаимодействие с тестируемой системой gotoGroupPage("groups") 
	*/
	}


Есть одно нежелательное изменение в АМ

Ссылка на драйвер переехала в groupHelper 
groupHelper.driver = new WebDriver();

Это неправильно, нужно вернуть ее обратно в ApplicationManager. Потому что она должна быть общей, ей хочет пользоваться  ApplicationManager и другие помощники тоже хотят работать с этой ссылкой.
Вернуть ее обратно средствами рефакторинга не получится. Нужно перенести в ручную.

Отправляемся в GroupHelper 
Копируем от туда ссылку 
WebDriver driver;
Вставляем в АМ, в начало выражения
Метод инициализации init() будет инициализировать именно эту ссылку. Атрибут который находится в классе AM
удаляем префикс groupHelper.
Но тогда возникает вопрос. Как GroupHepler получит эту ссылку на драйвер?
Нужно ее передать в конструктор, но не в private final GroupHelper = new GroupHelper(); а после того как выполнена инициализация (после  строк с атрибутом driver.)
То естьGroupHeldep должен конструироваться внутри метода init()
Ссылка на драйвер должна передаваться в качества параметра в контструктор
groupHelper = new GroupHelper(driver);
И этот конструктор необходимо создать Alt+Enter

  public GroupHelper(WebDriver driver) { //то значение, которое передано в качестве параметра конструктора
    this.driver = driver; //необходимо присвоить в атрибут (поле) класса GroupHelper
  }
Тем самым класс GroupHelper получит доступ к драйверу, который инициализирован в AM и передан помощнику. 
  
Но остались проблемы в АМ


private final GroupHelper groupHelper = new GroupHelder(); //не нужна инициализация = new GroupHelder()
private final GroupHelper groupHelper; //его нужно только декларировать

final - пометка означает, что в это можно присвоить значение только один раз. Нас это не устраивает потому что метод init() может вызываться многократно. Убираем пометку. 

private GroupHelper groupHelper;

Остались проблемы в других вспомогательных методах. Там тоже используется ссылка, которая находится внутри groupHelper. Нужно от этого избавиться. Чтобы определить где именно есть эта нежелательная ссылка, нужно в GroupHelper объявить атрибут, в котором он хранит свою личную ссылку на драйвер, private

> GroupHelper.java

private WebDriver driver;

В АМ будут выделены те кто хочет получить доступ к атрибуту, находящимуся внутри GroupHelper. Удаляем ссылки.
Пусть они пользуются ссылкой, которая находится внтури AM.


Для закрепления проделаем тоже самое с методом gotoGroupPage

Вынесем его во вспомогательный класс - NavigationHelper

public class ApplicationManager extends NavigationHelper; // создаем базовый класс  Alt+Enter

переносим в него нужную функцию gotoGroupPage + driver

Заменяем наследование на делегирование


Обратно переносим ссылку на драйвер

чтобы NavigationHelper получил доступ к этой ссылке передаем ее в качестве параметра в конструктор

navigationHelper = new navigationHelper(driver);

просим среду разработки чтобы она создала этот конструктор 

присваемваем переданное значение 

public class NavigationHelper {
  private WebDriver driver; //для того чтобы к нему никто не мог получить доступ  

public NavigationHelper(WebDriver driver) {
    this.driver = driver; //присваеваем переданное значение в поле 
  }
}
возвращаемся в сломавшийся и подкрашенный АМ

удаляем все неправильные использования драйвера

удаляем модификатор final и инициализацию = new navigationHelper(); //потому что эта инициализация выполняется в методе init() после создания драйвера 

navigationHelper = new NavigationHelper(driver); 



Переносим метод login() во вспомогательный класс другим способом, без рефакторирга


appmanager > Create New Class > SessionHelper


сделаем в АМ ссылку на SessionHelper


private sessionHelper sessionHelper;


инициализируем его в методе init()

sessionHelper = new SessionHelper(driver); //поскольку такого конструктора нет, сделаем его

public class SessionHelper {
  private WebDriver driver;
}

public SessionHelper(WebDriver driver) { //driver Alt+Enter > присвоить значение параметра конструктора в какое-то поле 
  this.driver = driver; //поле создается автоматически 
}

Вырезаем метод login() и вставляем в класс SessionHelper

Добавить все необходимые импорты, поменять методы на public 

Внутри AM обращаться к нему через помощникам

sessionHelper.login("admin", "secret") //вызывается метод в помощнике, ему делиируются какие-то действия


}
Урок 26 Наследование общий базовый класс {

Для того чтобы новые тесты было проще добавлять, и без использования рекодера, нужно доработать код классов помощников

Код заполнения поля ввода 

driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());

Alt+Ctrl+M

public void fillGroupForm(GroupData groupData) {
    type(groupData); 
}
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

В результате рефакторинга параметр у этого метода получился не очень удачный. Логичнее в этот метод передавать 2 других параметра: локатор элемента, текст который нужноввести в поля ввода. 

было
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

стало
 private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }
  
  
При этом среда разработки сама догадалась, что параметр GroupData больше не используется и автоматически его удалила. Кроме того, она заметила такие места, где повторяется фрагмент кода и предложила там тоже сделать замену на вызов нового созданного метода. 



  public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

  private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }

В результате всех преобразований дублирование кода сократилось.

Тоже с методом клик

 public void submitGroupCreation() {
    driver.findElement(By.name("submit")).click();
  }
  
Выделяем кусок кода, который хотим выделить во вспомогательный метод
Alt+Ctrl+M

  public void submitGroupCreation() {
    click();
  }
 

  
Делаем его параметрализованным 

public void submitGroupCreation() {
	click(By.name("submit"));
}
private void click(By locator) {
	driver.findElement(locator).click();
}

Среда замечает, что есть 5 похожим фрагментов и их тоже стоит заменить

Тоже самое нужно проделать в другом классе помощнике - SessionHelper
Но мы уже сделали подходящие методы, необходимо только предоставить возможность использовать их.

Здесь нам поможет механизм наследования, который даст возможность предоставить общее пространство обобществить какие то методы между двумя классами. Возвращаемся в GroupHelper, делаем базовый класс и помещаем в него методы click и type + ссылка на драйвер

GroupHelper extends HelperBase; //базовый класс для всех помощников 

Раньше в контсрукторе просто присваивалось значение в поле класса, а сейчас появился вызов странного метода 
  public GroupHelper(WebDriver driver) {
    super(driver); //это обращение к конструктору базового класса
  }
В базовом классе создан конструктор, который принимает параметр в качестве ссылке на драйвер
  public HelperBase(WebDriver driver) {
    this.driver = driver;
  }



public void login(String username, String password) {
    driver.findElement(By.name("user")).click();
    driver.findElement(By.name("user")).clear();
    driver.findElement(By.name("user")).sendKeys(username);
    driver.findElement(By.name("pass")).clear();
    driver.findElement(By.name("pass")).sendKeys(password);
    driver.findElement(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]")).click();
  }


  public void login(String username, String password) {
    type(By.name("user"), username);
    type(By.name("pass"), password);
    click(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]"));
  }


Метод может пользоваться теми данными, которые храняться в объекте этого класса.


}
Урок 27. Новый тест без использования рекодера {

Добавим тест в котором проверяется возможность модификации какой то существующей группы


package ru.testjava.addressbook.tests;

import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupModificationTests extends TestBase{

  GroupModificationTests() {

  }

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    app.getGroupHelper().selectGroup();
    app.getGroupHelper().initGroupModification(); //новый
    app.getGroupHelper().fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.getGroupHelper().submitGroupModification();//новый
    app.getGroupHelper().returnToGroupPage();
  }
}

Новые методы создаем в классе GroupHelper

}


Занятие 3 Управление потоком выполнения кода, ветвление
Урок 28. Блок if / else {

Решение квадратного уравнения
D = b^2 - 4ac

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения


double d = b*b - 4*a*c; 
	
Используя условный оператор if, можно выборочно выполнять отдельные части программы.
Ниже представлена простейшая форма оператора if:
if (условие) оператор;
Условие обозначает логическое выражение.

Будем анализировать дескреминант, чтобы присвоить значение в атрибут n


if (d > 0) { //если условие в скобках справедливо, то выполняется блок в фигурных скобках
  n = 2;
} else { //если условие в скобках не справедливо
  if (d == 0) { //вложенная конструкция if
	n = 1;
  } else {
	n = 0;
  }
}


---
Урок 29. Проверки различные формы
Конструкция if, служащая для проверки условий может принимать три формы

Полная форма с блоком else
Сокращеная форма без блока else
Свернутая форма - альтернативное представление для нескольких вложенных конструкций if

Если в конструкции if внутри фигурных скобок находится одно действие, то фигурные скобки можно не ставить.

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения

Тройных развилок нет, поэтому это реализуется через вложенные конструкции 


Визульно равноправные, а не вложенные. Это свернутая форма которая по сути эквивалентна вложенной форме.
if (d > 0) { 
  n = 2;
} else if (d == 0) { 
n = 1;
} else {
n = 0;
}

Если условия взаимоисключающие, то можно записать по другому. Но тогда будут выполняться все проверки, то есть будут лишнии проверки. При наличии блока else лишних проверок нет.

if (d > 0) { 
  n = 2;
} 
  
if (d == 0) { 
n = 1;
} 

if {d < 0) {
n = 0;
}
}

Внутри блока else находится одна единственная конструкция if
else { 
  if (b == 0) {
	if (c == 0) {
	  n = -1;
	} else {
	  n = 0;
	}
  } else {
	n = 1;
  }

}

стало
 if (a != 0) { //алгоритм решения квадратного уравнения
      if (d > 0) { //используется конструкция типа свертка* 
        n = 2;
      } else if (d == 0) {
        n = 1;
      } else {
        n = 0;
      }

    } else if (b != 0) { //алгоритм решения линейного, вырожденного уравнения //используется конструкция типа свертка
      n = 1;

    } else if (c != 0) {
      n = 0;

    } else {
      n = -1;
    }

С логической точки зрения это разные свертки 
в первой конструкции равноправные, взаимоисключающие варианты развития событий D < 0 или D = 0 или D > 0. Это три разные ветки.
во второй конструкции остается каскад проверок - они по смыслу вложенные, но написаны в свернутой форме.

При написании кода пробуйте эксперементируйте, меняйте проверяемые условия, переставляйте блоки местами, стараясь добиться максимальной понятности того, что проверяется и когда что должно выполняться.


}
Урок 30. Браузер на выбор {

public class ApplicationManager {
  private WebDriver driver; //тип переменной интерфейс WebDriver - это проявление механизма наследования
 
public void init() {
    System.setProperty("webdriver.chrome.driver", "c:\\Tools\\chromedriver.exe");
    driver = new ChromeDriver(); //создается экземпляр класса ChromeDriver

	}	
	
В интерфейсе методы только декларируются, объявляются имена и типы параметров возвращаемого значения. А конкретная реализация этих методов должна быть написана в классе наследнике.	
Разные классы могут реализовывать один и тот же интерфейс, но по разному 	
	
Выбор типа браузера нужно указать при инициализации в TestBase. Поэтому тип браузера нужно следать параметром.

Способ 1
Можно сделать параметром метода init()	
	
Тогда в TestBase при вызове этого метода нужно указать тип браузера
@BeforeMethod
public void setUp()
app.init(CHROME)

Способ 2
Можно сделать тип бразузера параметром конструктора AM

public class TestBase {
protected final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);
...
}

Создаем конструктор
public ApplicationManager(String browser) {

    this.browser = browser; //значение параметра сохраняем в поле
  }
	
Убираем локальную переменную String browser = BrowserType.CHROME; вместо нее будет использоваться атрибут объекта АМ, тот который был установлен при конструировании этого объекта.
public void init() {
    String browser = BrowserType.CHROME;
    if (browser == BrowserType.CHROME) {	
	}	

public void init() {
    if (browser == BrowserType.CHROME) {
      driver = new ChromeDriver(); 
    } else if (browser == BrowserType.FIREFOX) {
      driver = new FirefoxDriver();
    } else if (browser == BrowserType.IE) {
      driver = new InternetExplorerDriver();
    }
}

Драйверы помещены в папку c:\Tools\
В переменную окружения PATH добавлен путь c:\Tools\ 
	
http://software-testing.ru/forum/index.php?/topic/33657-udaetsia-podkliuchit-chromedriver-tolko-cherez-systemsetproperty/?p=154278

1) Можно положить исполняемый файл chromedriver в одну из директорий, которые упоминаются в переменной окружения PATH. Если Вы попытались это сделать, но не работает -- вероятно, неправильно настроили переменную, либо не перезапустили приложение, которое должно увидеть изменённое значение переменной. В операционной системе Windows можно просто положить исполняемый файл в c:\windows\system32, эта директория по умолчанию включена в PATH (если только вы её оттуда сами не удалили)

 

2) Можно положить исполняемый файл chromedriver в текущую директорию. То есть в ту директорию, которая будет текущей, когда вы будете запускать тесты. Скорее всего это корневая директория проекта.



---
Урок 31. Сравнение Equals	
	
Знак сравнения == нужно использовать только для чисел (двойной знак равенства)
Во всех остальных случаях, для объектов нужно использовать метод Equals	
	
Переменная - ссылка на объект
Когда вы объявляете переменную ссылочного типа, на самом деле вы создаете ссылку на объект данного типа. Рассмотрим следующий код для объявления переменной типа int:
int x;
x = 10;
В этом примере переменная x имеет тип int и Java инициализирует её как 0. Когда вы присвоите переменной значение 10 (вторая строка), это значение сохранится в ячейке памяти, на которую ссылается x.


Когда мы присваивали во вторую переменную значение, которое хранится в первой переменной, новый объект не создавался. 
Скопировалась ссылка на уже существующий объект
String s1 = "firefox";
String s2 = s1; //есть 2 переменных ссылающееся на один и тот же объект


public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = s1; 

System.out.println(s1 == s2); //true сравнение ссылок, проверяется идентичность объектов 
System.out.println(s1.equals(s2)); //true сравнение содержимого объектов
}
}
	
	
public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = new String(s1);  // в памяти возник другой объект

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}	
	
В памяти возник другой объект, который логически содержит такой же текст, но физически это другой объект. Он хранится в другом месте в памяти, имеет другой адрес.

Когда сравниваются две ссылки s1 == s2 результат отрицательный.
Метод equals() сравнивает не ссылки, а содержимое объектов. Это логические сравнение, а не физическое. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = "firefox"; // не происходит копирование ссылки. В переменную s2 присвается значение, совершенно не зависимо от того что было раньше присвоено в переменную s1  

System.out.println(s1 == s2); //true java считает что переменные ссылаются на один и тот же объект 
System.out.println(s1.equals(s2)); //true
}}

Компилятор оптимизирует код. Все переменные, которые ссылаются на одну и туже литеральную строку, будут ссылаться на один и тотже физический объект. 
String s2 = "fire"+"fox";
System.out.println(s1 == s2); //true

Компилятор догадывается, что это один и тотже объект. На этапе компиляции склеет эти части, увидит что получился тотже самый объект, который ранее использовался.

Но на этапе компиляции вычисляются не любые выражения. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox" + "2.0";
String s2 = "firefox" + Math.sqrt(4.0); //на этапе выполнения будут созданы два независимых объекта

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}


---
Урок 32. Дефолтные значения в полях

Рассмотрим пример использования конструкции if для оптимизации ввода данных в текстовые поля.

Задание
Создать группу, с именем test1, а остальные поля пусть будут заполнены значениями по умолчанию. Не указывать в тесте явно. 

Можно использовать значение null. Когда в переменную присвается значение null , это означает, что она ни на какой объект не ссылается.


protected void type(By locator, String text) {
	click(locator);
	driver.findElement(locator).clear(); 
	driver.findElement(locator).sendKeys(text); //падает, предварительно очистив поле ввода 
}

Задание 
Если в качестве текста передано значение null, то это поле ввода вообще не нужно трогать.

было  	
  protected void type(By locator, String text) {
    click(locator);
    if (text == null) { // нужно проверить храниться ли в переменной ссылка на какой то объект (физ сравнение)

    } else {
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }	
}	
	
стало
if (text != null) { 
  driver.findElement(locator).clear();
  driver.findElement(locator).sendKeys(text);
}	
}
}

}
Урок 33. Ленивое заполнение полей {

Для того чтобы оставить поле неизменным, можно передать в качестве значение null. Это будет означать, что мы хотим оставить в поле то значение, которое в поле уже введено.


Если то значение, которое мы передали совпадает с тем, которое уже введено в поле ввода. Есть смысл провести проверку. 

Задание
Если в поле уже введено значение, то с этим полем делать ничего не нужно



По правилам web приложений тот текст которым видим в поле ввода, является значением атрибута value

А обычный метод getText() для полей ввода всегда возвращает пустую строчку. Метод getText() используется для всех остальных элементов, кроме полей ввода. 


protected void type(By locator, String text) {
click(locator);
if (text != null) {
  String existingText = driver.findElement(locator).getAttribute("value"); //извлекаем из поля то значение, которое храниться
  if (! text.equals(existingText)) { //если неверно что текст совпадает с уже существующим текстом
	driver.findElement(locator).clear();
	driver.findElement(locator).sendKeys(text);}
  }
} 

Если нужно чтобы тесты работали быстро, есть большие поля ввода куда вводится длинный текст, тогда сделать такую доп проверку не помешает. 
Selenium вводит текст по символьно. 


}
Урок 34. Исключения. Перехват и обработка {

Исключение - это информация выводящаяся на консоль при падении программы. Информация о том, где произошел сбой, в каком файле, строчке.

Конструкция if часто используется чтобы предотвратить возникновение исключения.

В нормальном состоянии выполнение метода завершается либо от дошел до самого конца "}", которая ограничивает тело метода. Либо если в коде встретилось слово return.

Стек вызовов - цепочка методов, которые вызывают друг друга

Читать удобно снизу вверх. 

main главная функция, которая запускается когда мы стартуем какую нибудб программу.
В последнем методе, который упоминается в стеке вызовов произошла ошибка. 
Причем ошибка настолько серьезная, что дальнейшая работа программы стала невозможной. 
Несмотря на то, что в последнем методе нет слово return, java должная прекратить выполнение этого метода. 
Java прекращает выполнение этого метода аварийно. То есть вышестоящий метод получает сообщение о том, что вызванный метод завершился аварийно. 
И вместе с этим сообщением получает специальный объект, который содержит информацию о возникшей проблеме. Этот объект называется исключением.
А преждевременный возврат из функции называется выбросом исключением. 

Последняя функция выбросила исключение и при этом ее работа прервалась.
Предпоследняя функция, которая обращалась к проблемной , тоже не может продолжать, поэтому она пробрасывает исключение дальше. 
В свою очередь предшествующий метод тоже аварийно прерывается, и пробрасывает ислючение еще выше 
И так ислючение постепенно летит вверх пока не долетает до места где оно будет перехвачено.

В тестовом фрейфорке есть механизм, который позволяет эту цепочку аварийных прерываний остановить, исключение перехватить, проанализировать и обработать.
Тестовый фреймворк ловит исключение, записывает в отчет, выводит на консоль, и продолжает выполнять следующие тесты. 
 
Синие функции - те что в нашем проекте	
Серые - какие то библиотеки	(selenium)

Код серых библиотек нам не доступен, мы ее исправить не можем
Поэтому если внутри этой библиотеки возникает ислючение, мы можем:
- попытаться это предотвратить, написав какие то проверки и не допустить обращение к методу sendKeys() с плохими данными;
- обратиться к фукнкции sendKeys и попытаться перехватить те исключения, которые могут быть выброшены во время ее работы (устранить последствия).

Метод isAlertPresent() позволяет проверить наличие диалогового окна, которое иногда возникает на странице web приложений.
Библиотека selenium не предлагает способа проверить наличие / отсутствие этого диалогового окна
	
	
public boolean isAlertPresent() {
  try { //пытаемся выполнить блок кода
	driver.switchTo().alert(); //если окно есть, то успешно переключимся. все Ок
	return true; //а если не получилось и возникло исключение
  } catch (NoAlertPresentException e) { // если окна нет, то возникает исключения типа NoAlertPresentException. Перехватываем его и тоже все Ок. другого типа не перехватим.
	return false; 
  }
}	

Предотвратить появление ислючения нельзя. Вынуждены устранять последствия. 	
Это аварийное прерывание не будет распостраняться дальше. 
Те функции которые обращаются к isAlertPresent(), вместо прерывания и исключения получат нормальное возвращаемое значение true / false
	
Типы исключений бывают разные:	
- при выполнении недопустимых арифметических действий, поделить на 0
- преобразование строки в число, если при этом строка не может быть преобразована в число
- использование переменной, которая не проинициализирована NullPointerException
- при поиске несуществующего элемента 

}
Урок 35. Почти одикановые формы {

Имеется две почти одинаковые формы. В форме для редактирования контакта отсутствует поле выбора группы с выподающим списком.

В обоих тестах CreateContact и ContactModification используется метод fillContactForm()
Добавим в него функционал для работы с группами

Во первых нужно добавить поле String group в класс ContactData, который хранит информацию о контакте

Добавляем параметр в конструктор, сохраняем его значение в какое то поле 

Делаем для этого поля метод getter, которое позволяет получить значение поля. 

//“get” — “получать” (т.е. “метод для получения значения поля”) и set — “устанавливать” (т.е. “метод для установки значения поля”).
//метод getName() возвращает значение поля name у того объекта, для которого он был вызван

public class ContactData {
	...
    private String group;

  public ContactData(...String group) {
	...
    this.group = group;
  }

  ...
  public String getGroup() {
    return group;
  }
}

Указываем существущее значение параметра group в тестах 
На странице приложения Edit Group нет поля group, поэтому в тесте ContactModification указываем null

На этом доработка тестов завершена, теперь доработаем метод который заполняет форму.

Как выбрать элемент из выпадающего списка?

Используем вспомогательный класс 
new Select(driver.findElement(By.name("new_group"))) //в качестве параметра указан элемент, который найден на странице приложения - листбокс со списком групп

Теперь в этом объекте типа select надо вызвать один из методов
new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());

Но при попытке запустить тест ContactModification в этой строчке возникнет исключение, потому что драйвер не сможет найти элемент с таким локатором.

Для того, чтобы предотвратить это исключение, можно сделать проверку

if (isElementPresent(By.name("new_group"))) { //задаем локатор в качестве параметра
    new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup()); //выбор пункта из выпадающего списка
    } 
//в противном случае, если такого элемента нет, то делать ничего не нужно - блока else не будет

Создаем метод isElementPresent()

private boolean isElementPresent(By locator) { //параметру даем общее имя, для проверки произвольного локатора
	return  ; //тут нельзя предотвратить возникновение исключения 
}
  
Драйвер селениум не предоставляет возможности узнать заранее есть ли на странице элемент или нет.
Единственное что можно сделать это его поискать

private boolean isElementPresent(By locator) {
	driver.findElement(locator); //поиск элемента
}

Если элемент есть, то он успешно найдется. 
Если элемента нет, то будет выбрашено исключение.
Поэтому нужно обернуть попытку поиска элементра в блок try

 protected boolean isElementPresent(By locator) {
    try {
    driver.findElement(locator);
    return true;
    } catch (NoSuchElementException ex) {
    return false;
    }

 }

Рассмотрим ситуацию, когда на форме создания контакта разработчики потеряли это поле. 

if (isElementPresent(By.name("new_group"))) { //селениум должен заполнить это поле, если его нет то выпадет исключение
    new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());


Чтобы эту проблему устранить, для метода fillContactForm() сделаем доп параметр, в который будет передаваться информация о том, что мы сейчас делаем - создаем или модифицируем контакт.
Это "булевский" параметр , где true - означает форма создания, там должен быть элемент для выбора группы, false - означает что контакт модифицируется, элемента не должно быть.

public void fillContactForm(ContactData contactData, boolean creation) { 
	type(By.name("firstname"), contactData.getFirstname());
	...
	
}

Тесты тоже придется поменять 

public void testContactCreation() {
...
app.getContactHelper().fillContactForm(new ContactData(...), true);
}

public void testContactModification() {
...
app.getContactHelper().fillContactForm(new ContactData(...), false);
}

А теперь поменяем метод fillContactForm() в ContactHelper //самое важное **

Вместо того, чтобы анализировать есть элемент на странице или его нет и в зависимости от этого принимать какие то решения, используем следующую конструкцию  

if (creation) { //если это форма создания, значит элемент должен быть, поэтому нужно выбирать элемент из выпадающего списка
	new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());
} //если вдруг этого элемента нет, то тест упадет - и так должно быть
else { //а иначе , это форма модификации, в этом случае элемента быть не должно
  Assert.assertFalse(isElementPresent(By.name("new_group"))); //проверка того что элемента быть не должно 
}
} 

Если вдруг на форме модицикации контакта этот элемент появился то это баг, тест должен упасть

Запускаем оба теста
В одном случае выбирается группа из выпадающего списка
В другом - проверяется отсутствие этого выпадающего списка


В тесте модификации контакта происходит задержка
driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS); //после инициализации браузера устанавливается значение тайм аута 

Когда селениум пытается найти какой то элемент, он думает что из за медленной загрузки страницы элемент не успел появится. 
При проверки отсутствия элементов тайм аут мешает. Да, он помогает уменьшить нестабильность тестов. Драйвер автоматически ждем пока страница загрузится, элементы появятся. 
Когда нужно убедится, что опредленнные элементы отсутствуют, можно тай аут отключить =0. 

Теперь проверка отсутствия элементов выполняется мнгновенно. Если где то есть элементы, которые появятся не сразу, то могут возникнуть проблемы - нестабильность при выполнении тестов. Когда возникнут проблемы, тогда будем их решать. Перед поиском конкретного элемента можно увелить тайм аут, а после того как он найден сбросить обратно в 0.

** самое важное - мы сделали метод, который позволяет выполнять проверку наличия или отсутствия элементов. И пользуем этот методом для того чтобы заполнять форму, которая то содержит, то не содержит элемент.
При этом мы не просто ориентируемя на наличие отсутствие элемента. 
Тесты предсказывают должен быть этот элемент или нет.
При создании контакта список должен быть, поэтому мы пытаемся из него выбрать. 
А при модификации контакта такого списка не должно быть вообще, поэтому мы явно контролируем его отсутствие. А если он вдруг появится, то тесты упадут - будет обнаружен баг

}
Урок 36. Ленивые действия {

Оптимизированы переходы между страницами. Полезно когда веб приложение работает медленно, если проверка занимает меньше времени чем действие.  

Перед тем как перейти на страницу или кликнуть меню, имеет смысл сделать проверку. А может быть уже находимся на нужной странице и не надо никуда переходить. 

Эта оптимизация будет реализована в классе navigationHelper

Добавим проверки перед каждым кликом / переходом . Какой критерий выбрать? 

Можно проверять наличие каких то характерных элементов. Например, использовать комбинированный критерий - наличие заголовка с текстом Groups и кнопки для создания новой группы New groups. Такой критерий будет уникальным для конкретной страницы.

Cначала проверяем наличие заголовка
После того как убедились в наличии элемента, можно проверять текст
Для написания составного условия используем логические операции && (И / двойной амперсанд) || (или)


public void gotoGroupPage() {
if (isElementPresent(By.tagName("h1"))
		&& driver.findElement(By.tagName("h1")).getText().equals("Groups")
		&& isElementPresent(By.tagName("new"))) { 
		//ничего делать не надо, мы уже находимся на нужно странице

} else {
  click(By.linkText("groups"));
}
}

Но так писать не принято, чтобы основной блок if был пустым. Можно это условие развернуть, превратить в противоположное

public void gotoGroupPage() {
if (! isElementPresent(By.tagName("h1"))
		|| ! driver.findElement(By.tagName("h1")).getText().equals("Groups")
		|| ! isElementPresent(By.tagName("new"))) { 
		click(By.linkText("groups"));

}
} 


public void gotoGroupPage() {
if (isElementPresent(By.tagName("h1"))
		&& driver.findElement(By.tagName("h1")).getText().equals("Groups")
		&& isElementPresent(By.tagName("new"))) { 
		return; //сразу же выполнить выход из этого метода, не нужно дальше двигаться

} 
  click(By.linkText("groups")); //а иначе мы проскакиваем блок if и выполняем клик 
  
}


Таким образом выполняется нужная функциональность, и требования стиля тоже соблюдены.


}
Урок 37. Предусловия. Проверка и обеспечение. {

Использование контструкции if для проверки предусловий перед выполнением теста.

Вопрос функциональности: могут ли тесты вообще выполнить свою задачу?

Рассмотрим тест модификации группы. Если групп для модификации нет, то тест упадет

Чтобы исправить проблему, нужно добавить в тест проверку предусловия.
Перед модификацией группы, нужно убедится что она есть.
Кроме того, нужно отреагировать на ее отсутствие.

1 способ
Тест можно пропустить 

2 способ
Можно сделать попытку исправить ситуацию
Сначала создать группу, а потом продолжить выполнение теста, как будто она существовала с самого начала

Предусловие можно не только проверять, но и обеспечивать их выполнение.

Добавляем проверку предусловия  
@Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {     //помещаем новый метод в GroupHelper, чтобы сохранить имеющуюся архитектуру
    //копировать фрагмент кода не будем, создадим вспомогательный метод 
    }
    ...
  } 

Вставлять большой фрагмент кода из метода GroupCreationTests не будем, потому что возникает дублирование.
Как только копируем большой фрагмент кода из одного места в другое, значит должно возникнуть подозрение что то идет не так. Нужно создать вспомогательный метод, который поместим в GroupHelper

if (! app.getGroupHelper().isThereAGroup()) {     //помещаем новый метод в GroupHelper, чтобы сохранить имеющуюся архитектуру
      app.getGroupHelper().createGroup(new GroupData("test1", null, null)); //параметр - группа со всеми ее атрибутами
    }


public class GroupHelper extends HelperBase {
  public void createGroup(GroupData group) { //параметру дали любое имя, значение задается в тесте
    initGroupCreation(); //маленькие вспомогательные методы
    fillGroupForm(group);
    submitGroupCreation();
    returnToGroupPage();
  }
}

Возникает вопрос: а нужно ли оставлять маленькие вспомогательные методы?

Во первых наличие этих вспомогательных методов позволяет писать метод CreateGroup, так что он легко читается  - понятно из каких шагов состоит метод создания группы

Во вторых, может существовать такой тест, в котором этот сценарий до конца не доходит. Например, при проверки отмены создания группы. Тогда, сценарий можно легко изменить.

Реализуем метод isThereAGroup()

  public boolean isThereAGroup() { //будет проверяться наличие элемента, который пытаемся выбирать в методе SelectGroup (соответствует включенному чекбоксу)
    return isElementPresent(By.name("selected[]"));
  }


Теперь тест testGroupDeletion выполняется правильно, вне зависимости от того есть ли группа в начале выполнения теста или нет. 

}


Занятие 4. Коллекции и циклы  
Урок 38. Циклы. Многократные повторения похожих действий {

Циклы - конструкции, предназначенные для повторения похожих действий
Коллекции - наборы однотипных элементов

Циклы используются, чтобы сформировать или перебрать коллекцию. То есть выполнить однинаковые действия со всеми элементами некоторого набора. 

Конструкция, позволяющая описать два типа циклов 
выполнить действие определенное количество раз
выполнять действия пока не удовлетворится какое то условие окончания

Задача об определении простоты целого числа
Простое число делится только на себя и 1 
(2, 3, 5, 7, 11, ...)
Для проверки простоты числа нужно попытаться поделить его на все числа, которые меньше него. Если среди них найдется делитель, значит число не простое. Если делетелей нет, значит простое. 

Нужно число n делить последовательно на разные числа. Выполнять это действие многократно. Сколько раз? 
В данном случае нам известно сколько чисел нужно попробовать.
Нужно проверить все числа от 2 до n-1   

Для описания таких циклов используется конструкция for ()
Цикл for () обычно использует переменную счетчик, которая описывается внутри круглых скобок. Она не только декларируется, но и описывает все что с этим счетчиком происходит.
Ниже приведена простейшая форма цикла for:

for (инициализация; условие; итерация) оператор;

for (инициализация; место остановки; то что происходит с переменной счетчика на кажной итерации цикла) {действия которые должны происходить на каждой итерации; }



  
i = i + 1
i += 1 		сокращенная запись, увеличение переменной на заданное значение
i++ 		операция инкремент, увеличение переменной на 1 
% операция получения остатка от деления двух чисел  
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4*5 = 2)


	
public class Primes {

  public static boolean isPrime(int n) { 
    for (int i = 2; i < n ; i++) { // i = 2 потому что ищем делитель отличный от 1 и n
      if (n % i == 0) { //число делится без остатка
      return false; //не простое
      }
    }
    return true; //простое
  }
}

Напишим тест

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class PrimeTests {

  @Test
  public void testPrimes() {
    Assert.assertTrue(Primes.isPrime(Integer.MAX_VALUE)); //Integer.MAX_VALUE простое число
  }

  @Test
  public void testNonPrimes() {
    Assert.assertFalse(Primes.isPrime(Integer.MAX_VALUE-2)); //Integer.MAX_VALUE - 2 не простое число
  }
}




//цикл for может быть переписан в другой вид (эквивалентная форма)

public static boolean isPrimeWhile(int n) {
int i = 2;
while (i < n) { //while (до тех пор пока) условие окончания цикла 
  if (n % i == 0) { //можно избавится от констукции if, ту проверку которая выполняется включить в условие окончания цикла
	return false;
  }
  i++; //на каждой итерации цикла увеличиваем переменную на 1, выполнять эти действия будем пока i = n
}
return true; //если дошли до конца цикла i = n, значит делителя не найдено и возвращаем true
}

 
public static boolean isPrimeWhile(int n) {
int i = 2;
while (i < n && n % i != 0) { //тогда продолжаем искать делитель дальше
  i++; 
}
return i == n; //**

} 

**
Цикл завершится когда i = n, либо будет найдет какой то делитель. Значит после окончания цикла нужно проверить чему равно i
Если i == n, то ниодного делителя не найдено, n простое число. 
Если i != n, значит цикл закончился раньше, чем достигнуто максимальное значение и делитель найден. n не простое число. 	


Рассмотрим разные модификации фукнкции Prime()

int используется для представления 32бит чисел
long это 64бит числа

Две функции имеют одинаковые имена isPrime(), но разные типы переменных int и long. Конфликта не возникает, потому что java разбирается в типах данных.

Напишем тест 

@Test(enabled = false) //отключение теста
public void testPrimesLong() {
  long n = Integer.MAX_VALUE; //значение переменной будет преобразовано в тип long
Assert.assertTrue(Primes.isPrime(n));
}

В результате, время выполнения теста увеличилось в 3 раза

Теперь сократим количество итераций в 2 раза, время выполнения теста isPrime уменьшилось в 2 раза

public static boolean isPrimeFast(int n) {
for (int i = 2; i < n / 2; i++) { // делителя больше чем n / 2 не может быть. На что нужно умножить делитель, чтобы получилось n? Любой делитель числа меньше чем его половина (n / 2).
  if (n % i == 0) { 
	return false;
  }
}
return true;
}


@Test
public void testPrimesFast() {
Assert.assertTrue(Primes.isPrimeFast(Integer.MAX_VALUE));
}

Предположим что число n имеет делитель, это означает что у него есть второй делитель. То есть n представляется как произведение двух чисел. 
n = a * b 
(а || b) <= sqrt(n) //не могут быть оба делителя > чем корень из n, иначе их произведение > n

Поэтому проверять можно до Math.sqrt(n)   

Простой, но медленный метод проверки простоты заданного числа n известен как перебор делителей. Он состоит из проверки того, является ли n кратным целому числу от 2 до квадратного корня из n.

public static boolean isPrime2Fast(int n) {
    int m = (int) Math.sqrt(n); // значение корня явно приведем к целому числу, посколько корень может быть не целым
    for (int i = 2; i < m / 2; i++) {
      if (n % i == 0) {
        return false;
      }
    }
    return true;
  }

Когда используются циклы, нужно следить чтобы 
- количество повторений было неслишким большим 
- если итераций много, то нужно стремится выполнять действия на каждой итерации как можно быстрее

}
Урок 39. Коллекции наборы элементов {

В уроке пойдет речь о коллекциях и специальных разновидностей циклов, которые предназначены для перебора всех элементов коллекций

Коллекциями/контейнерами в Java принято называть классы, основная цель которых – хранить набор других элементов. 

Создадим новый класс Collections

Массив -  специальная конструкция на уровне языка, которая описывает коллекции 
Например, массивом является параметр функции main (String[] args). 
В нем передается какой то набор строк, те самые строчки которые указаны как параметры запуска в командной строке 

Сделаем массив 

public class Collections {

  public static void main(String[] args) {
    String[] langs = new String[4]; //объявлена переменная типа массив строк
  }
}

На то что переменная является массивом указывают первые [] в декларации (средство для работы с массивами)
Перед [] указывается тип элементов, которые могут хранится в этом массиве
При конструировании массива в квадратных скобках указывается его размер
new String[4] - созданный массив может хранить 4 элемента


public class Collections {

  public static void main(String[] args) {
    String[] langs = new String[4];
	//ниже происходит обращение к элементам массива в формате [порядковый_номер(индекс)]=значение 
    langs[0] = "Java"; //задегларировали и заполнили массив какими то значениями 
    langs[1] = "C#"; 
    langs[2] = "Python";
    langs[3] = "PHP";
  
  
  }
}

Эквивалетная запись элементов массива в одну строчку

public class Collections {

  public static void main(String[] args) {
    String[] langs = {"Java", "C#", "Python", "PHP"}; //Cоздается массив, который состоит из 4 элементов и заполняется какими то значениями
  
  }
} 

Устроим итерацию по элементам этого массива
 
public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 

  for (int i = 0; i <langs.length; i++){//у массива атрибут length 
	System.out.println("Я хочу выучить " + langs[i]); //выбираем из массива элемент с заданным индексом
  }
}
}

Специально для коллекций есть конструкция цикла, которая предназначена для перебора элементов коллекции 


public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 

  for (String l : langs){//теперь переменная l уже не индекс, это ссылка на элемент массива
	System.out.println("Я хочу выучить " + l); 
  }
}
}

Переменная l последовательно указывает на все элементы этой коллекции
Искусственная переменная счетчик не создается, она не нужна. Удобно иметь указатель на элемент массива.
Для каждого элемента l, входящего в коллекцию (массив) langs, выполнить какое то действие. 


Массив - это конструкция, которая поддерживается на уровне языка ([] особый синтаксис для описания массивов)
В Java есть другой способ работы с коллекциями, при помощи спец классов. Классы находятся в пакете java util	
	
https://docs.oracle.com/javase/7/docs/api/index.html?java/utl/Collections.html
	
В основании иерархии находится интерфейс Collection, который описывает произвольные коллекции.
Пример типов коллекций, которые расширяют интерфейс Collection

Интерфейс List (список)
Список предназначен для представления упорядоченных коллекций, то есть он похож на массив. 
В нем точно также как из массива можно взять элемент по индексу (порядковому номеру). В списке могут находится повторяющиеся или равные элементы. 
 
Интерфейс Set (множество)
Множество предназначено для представления неупорядоченных коллекций. У множества можно посчитать количество элементов, перебрать все элементы. Но нельзя взять элемент по индексу, потому что порядок элементов в множестве не определен. В множестве все элементы уникальны. Если попытаться добавить в множество элемент, который в нем уже содержится, то множество не изменится. 

У кажного интерфейса есть конкретные классы, которые эти интерфейсы реализуют. 

/*
Создаем переменную типа WebDriver и присваеваем в нее значение разных типов: firefoxdriver, chromedriver, iedriver
Там тоже существовали разные реализации для одного интерфейса */

Для интерфейса List существует несколько реализаций, самая популярная - класс ArrayList 
 

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 


  List<String> languages = new ArrayList<String>(); //название_интерфейса<тип_элемента>  = new имя_класса<>, который реализует этот интерфейс
  for (String l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

Теперь нужно этот список заполнить значениями 

В отличии от массива, размер которого заранее известен (он указан при инициализации и меняться не может), размер списка при создании равен 0 и его можно менять: добавлять, удалять элементы. При этом его размер будет меняться динамически. 

Итерация по элементам списка устроена также. 
Тот же цикл for у которого указывается переменная, пробегающая все значения какого то списка (коллекции) 

Вернемся к моменту инициализации массива и заполнения его значениями


Как записать элементы списка в одну строку 

Нельзя указать массив в качестве параментра конструктора
List<String> languages = new ArrayList<String>({"Java", "C#", "Python", "PHP"}); // ошибка


Как преобразовать массив в список

С помощью метода asList(), в который можно передать какое то количество строк в качестве параментра. Результатом метода будет список. Аналог инициализации массива с помощью {}. 

import java.util.Arrays;
import java.util.List;

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"};

  List<String> languages = Arrays.asList("Java", "C#", "Python", "PHP");

  for (String l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

По элементам списка можно устраивать итерации при помощи вспомогательной переменной счетчика. 

Список - это обычный объект. Поэтому при работе с объектом всегда обращаемся к нему, вызывая какой то метод // имя_объекта.название_метода

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"};


  List<String> languages = Arrays.asList("Java", "C#", "Python", "PHP");

  for (int i = 0; i < languages.size(); i++){ //атрибут size для списка
	System.out.println("Я хочу выучить " + languages.get(i)); // + обращается к элементу с помощью метода get (индекс)
  }

}
}

Можно создать список элементов произвольного типа //но так лучше не делать 

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 


  List languages = new ArrayList<String>();  
  for (Object l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

}
Урок 40. Количество элементов в коллекции {

C помощью коллекций мы научимся получать список элементов со страницы веб приложения и определять их количество.

Начнем с теста для создания групп

Создадим метод позволяющий узнать количество групп и добавим его проверку 


package ru.testjava.addressbook.tests;

import org.testng.Assert;
import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
	int before = app.getGroupHelper().getGroupCount(); //количество групп до добавления
    app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    int after = app.getGroupHelper().getGroupCount(); //количество групп после добавления
    Assert.assertEquals(after, before + 1); //проверка количества элементов 
  }
}


Для реализации новых методов getGroupCount() воспользуемся методом драйвера (с локатором в качестве параметра)

public int getGroupCount() {
    return driver.findElements(By.name("selected[]")).size(); //метод findElements возвращает список элементов т.е. объект типа лист. У этого списка нужно получить размер и затем вернуть его. Это количество и будет результатом работы метода.

  }

Если элемент не найден, то метод findElements() возвращает пустой список, в отличии от метода findElement(), который падает и выбрасывает исключение NoSuchElementException.


}
Урок 41. Выбор элемента списка по порядковому номеру {


Сейчас в тестах для удаления и модификации групп неявно предполагается, что выбирается первая группа
Эта логика спрятана внутри метода selectGroup()

Реализуем возможность передавать туда параметр - индекс или номер группы, которую нужно изменить / удалить.
0 // первый элемент 
before - 1 //последний = колличество - 1 (т.к. нумерация начинается с 0)


Теперь метод selectGroup() будет принимать в качестве параметра индекс элемента

public void selectGroup(int index) { 
    click(By.name("selected[]"));
  }
Нужно как то использовать этот индекс

1) Можно построить локатор, который сразу найдет нужный элемент. В самом локаторе использовать этот индекс.
2) Лучше работать со списком элементов


  public void selectGroup(int index) {
    driver.findElements(By.name("selected[]")).get(index).click(); //находим все элементы по локатору, затем среди этих элементов выбираем нужный по индексу, и именно по этому элементу выполняем клик
  }

}
Урок 42. Формирование коллекции {

Со страницы веб приложения получим список элементов, который содержит информацию о группах. В цикле последовательно перебирем эти элементы, извлечем из каждого элемента текст и другую информацию. 
На основании полученной информации построим собственные объекты типа GroupData (модельные объекты) и сформируем из этих объектов список.  Список будет использоваться в тестах сравнения. В этом уроке для проверки корректности изменения количества групп, в следующем - для сравнения содержимого групп.


Начнем с теста создания группы 

//Как будет выглядеть тест после того как нужный метод будет реализован?

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList(); //переменная before раньше содержала количество элементов, теперь будет содержать список элементов (объектов) типа GroupData
    app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    List<GroupData> after = app.getGroupHelper().getGroupList(); //переменная after содержит список элементов, после того как будет создана новая группа
    Assert.assertEquals(after.size(), before.size() + 1);
  }



Выполним реализацию метода getGroupList()

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();//создадим список, который будем заполнять
    return groups; //в конце метода этот список будет возвращаться
  }

ArrayList<> потому что мы должны указать конкретный класс, который реализует интерфейс List


Далее нужно заполнить список объектами. Данные для создания этих объектов будут извлекаться со страницы веб приложения.
Для этого нужно понять откуда, из какого элемента со страницы можно извлечь нужную информацию.

<span class="group">
	<input type="checkbox" name="selected[]" value="1" title="Select (test1)">
	"test1"
	<br>
</span> 

Возьмем элемент span, который имеет класс group и получим его текст. Тем самым мы сразу получаем название группы.

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group")); //найти все элементы, которые имеют тег span и класс group
    return groups;
  }

Теперь нужно по этим элементам пройти в цикле и для каждого из них выполнить какие то дейсвия

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();	//создадим список, который будем заполнять названиями групп
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group")); //ищем все элементы с тегом span и классом group и создаем новый список
    for (WebElement element: elements) {	//переменная element пробегает по списку
      String name = element.getText(); 	//из каждого элемента получаем текст, это будет имя группы. При работе с элементом всегда обращаемся к нему, вызывая какой то метод (имя_элемента.название_метода)
      GroupData group = new GroupData(name, null, null); 	//создаем объект типа GroupData, в котором header & footer нам неизвестны
      groups.add(group);	//добавляем созданный объект в список
    }
      return groups;
  }

/* Теперь сравниваем размеры списков, которые получены с помощью метода getGroupList(). Фактически проверяется тоже самое (количество групп)
Следующий шаг - сравнение списка целиком */

Перепишем тесты для удаления и модификации групп, чтобы в них использовался новый метод, возвращающий список групп.

}
Урок 43. Сравнение коллекций {

Реализуем проверку, которая контролирует что действительно удалилась нужная группа.
Для этого мы будем сравнивать списки целиком до и после удаления. 

Начнем с теста для удаления групп

Имеем два списка after и before, где размер after больше размера before на 1 элемент.

Поэтому перед тем как сравнивать сами списки, удалим лишний элемент. 

 @Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() - 1);
    app.getGroupHelper().deleteSelectedGroups();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size() - 1);

    before.remove(before.size() -1); //из списка удаляем элемент с тем же индексом, который выбирали 
  }

Теперь имеем два одинаковых списка before и after. Переменная before ссылается не на оригинальный старый список, а на старый список, в котором удален лишний элемент.
Старый список должен содержать теже элементы, что и новый.
Проверить совпадение элементов можно с помощью цикла.

for (int i = 0; i < after.size(); i++){
  Assert.assertEquals(before.get(i), after.get(i));
}

Запускаем тест, получаем сообщение об ошибке 

Expected :ru.testjava.addressbook.modul.GroupData@fd0e5b6
Actual   :ru.testjava.addressbook.modul.GroupData@4eed46ee

Из описания не понятно какие именно элементы списка сравнивались // тип@идентификатор (адрес объекта в памяти)


Чтобы увидеть текстовое представление элемента, нужно в классе GroupData сгенирировать специальный метод toString(). Он используется для преобразования в строку.

Code > Generate > toString()   

Далее нужно указать какие именно атрибуты объекта должны влючаться в строковое предствление. Указываем только name, так как header и footer неизвестны.

  @Override
  public String toString() {
    return "GroupData{" +
            "name='" + name + '\'' +
            '}';
  }

Теперь сообщение об ошибке имеет вид

Expected :GroupData{name = 'test1'}
Actual   :GroupData{name = 'test1'}

Java не знает как сравнивать объекты типа GroupData. Никаких правил для сравнения этого типа данных нет.
Нужно определить собственные правила сравнения, с помощью метода Equals. Он будет сравнивать атрибуты объекта по смыслу. 

Code > Generate > equals() and hashCode()

Указываем какие атрибуты будут участвовать в сравнении (указываем только name) 
Оставляем пустыми Select all-null fields  // указать какие поля не могут принимать значения null 

Тест успешно завершился. Теперь списки логически равные, потому что они состоят из равных объектов по смыслу. 
Списки построены отдельно, независимо друг от друга. Объекты физически разные, они хранятся в памяти в разных местах.  

Тестовый фрейворк умеет сам сравнивать списки без указания цикла.
Можно вызвать метод Assert.assertequals(befor, after) и передать туда два списка. 

  @Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().deleteSelectedGroups();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size() -1);

    before.remove(before.size() -1); 
    Assert.assertEquals(before, after);

  } 

}
Урок 44. Множества. Неупорядоченные коллекции {


Реализуем аналогичную проверку для теста модификации групп. Необходимо учесть, что при модификации группы меняется ее имя. Группа может перепрыгнуть на другое место в списке, потому что в тестируемом приложении группы сортируются по именам. Поэтому нужно сравнивать без учета порядка.  

Нужно преобразовать эти списки в множества и сравнить их.


public class GroupModificationTests extends TestBase{

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData("test1", "test2", "test3"); //4- добавили локальную переменную
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    //3 - ниже модифицируем старый спискок, чтобы предсказать ожидаемый результат

    before.remove(before.size() -1); //удаляли последний элемент
    before.add(group); //вместо него добавим тот, который должен появится после модификации


    //1 - добавим сравнение множеств

    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); // 2 - преобразуем списки в множества
  }
} 


Можно было модифицировать объект, который находится в этом списке, не удаляя его от туда и не добавляя вместо него другой. Но с логической точки зрения никакой разницы нет. Проще удалить не нужный и вместо него добавить тот, который нам требуется. А уже после того как это сделано, можно преобразовать полученнные списки в множества и сравнивать их друг с другом.        

Запускаем тест, он зеленый. Но не все так хорошо на самом деле. 

Модифицируем состояние тестируемой системы, создадим список из трех групп test1, test2, test3

Что сделает тест? 
Он меняет последнюю группу test3, давая ей имя test1
Теперь у нас две группы с именем test1 и одна с test2

Поставим точку остановы в строке и выполним тест в отладчике 
Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));


У нас есть before и after, в каждом из них находится по 3 элемента.
  
Провалимся во внутрь метода assertEquals()
и поставим точку остановки внутри него 

public static void assertEquals(Set<?> actual, Set<?> expected) { //сравниваются два множества, построенных из разных списков
    assertEquals(actual, expected, null);
  }
  
Продолжаем выполнение и видим, что здесь сравниваются 2 множества, имеющих размер 2.

Куда пропал третий элемент?
Проблема в том что множества не позволяют дублирование элементов, а мы сравниваем объекты (группы) по именам. Следовательно, все группы с одинаковыми именами схлопываются.
 
Вывод: если группа test3 получила бы имя test2 вместо test1, то наш тест решил бы что множества равны. 

test1		test1
test1		test2
test2		test2

Это некорректная проверка.

Решение 
Если бы группы имели уникальные идентификаторы, тогда бы при преобразовании списка в множества схлопывания не происходило.
Нужен уникальный идентификатор для каждого объекта. 


<input type="checkbox" name="selected[]" value="1" title="Select (test1)"> //value="1" 


Извлечем эти идентификаторы и будем их использовать при сравнении объектов

1 часть
 
public class GroupData {
  private final String id; //добавим атрибут 
  private final String name;
  private final String header;
  private final String footer;

  }
  public GroupData(String id, String name, String header, String footer) { //добавим параметр в конструктор
    this.id = id; //присваивать значение параментра в атрибут - в поле объекта
    this.name = name;
    this.header = header;
    this.footer = footer;
  }


2 часть
Делаем для этого поля метод getter, которое позволяет получить значение поля 
Code > Generate > Getter

public class GroupData {
  public String getId() {
    return id;
  }
}

Перегенерируем методы toString() / equals() 

Code > Generate > toString //указываем для id и name и заменяем для всех
Code > Generate > equals and hashCode //заменить существующие, default, указываем для id и name

3 часть

Модификация GroupHelder

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));// 3 - получили элемент, который является частью списка
    for (WebElement element: elements) {
      String name = element.getText();
	  String id = element.findElement(By.tagName("input")).getAttribute("value");  //2 - откуда взять id?  4 - Ищем внутри одного элемента другой и берем из него атрибут value
      GroupData group = new GroupData(id ,name, null,null); //1 - GroupHelper должен откуда то id извлекать, и передавать его в качестве параметра в конструктор, он используется при сравнении
      groups.add(group);
    }
      return groups;
  }

//**но это не чек-бокс - это элемент внутри которого, находится чек-бокс
<span class="group">
	<input type="checkbox" name="selected[]" value="5" title="Select (test2)">
	"test2"
	<br>
</span>


После модификации, появились ошибки компиляции
- можно их исправлять, везде передавать вкачестве идентификатора null 
- можно добавить конструктор в классе GroupDate

//группа с неизвестным идентификатором, она не прочитана из веб интерфейса, а создана искусственно 	
  public GroupData(String name, String header, String footer) { //не принимает идентификатор (String id) в качестве параметра 
    this.id = null; //если вызывается этот конструктор, то присваивается null в качестве идентификатора
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  public GroupData(String id, String name, String header, String footer) {
    this.id = id;
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

Повторяем запуск отладчика с выставленными ранее точками остановы

В методе assertEquals() видим что сравниваются два множества, которые имеют размер 3
Схлопывания нет, потому что все элементы различные. У них разные идентификаторы. Но с логической точки зрения, они должны быть равны. 

Тест падает. Проблема в том, что множества оказываются разными. Во втором множестве, есть элемент, у которого id = null. Этот тот самый, который модифицировали.  
 
Нужно ему установить правильный идентификатор. 
А откуда его узнать? Из уже существующего объекта, это будет последний элемент списка before

GroupData group = new GroupData(before.get(before.size() -1).getId(),"test1", "test2", "test3"); //используем идентификатор той группы, который был до модификации

При модификации группы мы указываем новые name, header, footer, а идентификатор остается старым.


}
Урок 45. Поиск максимального элемента в коллекции {

Добавим аналогичную проверку в тест для создания групп.

Проблема: новая созданная группа добавляется не в конец, а в какое то произвольное место
Решение: сравнивать старый список с новым нужно без учета порядка

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null); //2 - выделим переменную
    app.getGroupHelper().createGroup(group); //3 - используем выделенную переменную
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    //предсказываем ожидаемый результат
    before.add(group); //1 - добавляем в список ту группу, которую создали в тестируемом приложении
	
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); //4 - преобразуем списки в множества и сравниваем их
  }

Проблема: Что насчет идентификатора новой добавленной группы? Как узнать какой идентификатор присвоен новой группе?
Решение: Мы может опираться на предположение, что в новом списке это добавленная группа имеет максимальный идентификатор. //В тестируемом приложении новому индентификатору присваивается максимальное значение для того, чтобы они были уникальными.
Среди всех элементов, которые входят в новый список after, нужно найти тот, который имеет максимальный идентификатор. Это будет предсказанным ожидаемым идентификатором новой группы. Группа с таким идентификатором должна имеить те свойства, с которыми мы пытались ее создать.


Как узнать максимальный идентификатор?

Для начала меняем ему тип String на int
private final String id; // тип Строка не подходит для сравнения 

Испортились методы, в которых этот атрибут используется. Перегенерируем equals() и hashCode().


Исправим метод getGroupList(), который этот идентификатор вычисляет. Теперь он должен быть не строкой, а числом.

Было 
public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      String id = element.findElement(By.tagName("input")).getAttribute("value");
      GroupData group = new GroupData(id, name, null,null); 
      groups.add(group);
    }
      return groups;
  }

Стало
public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
	  int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value")); // преобразуем значение атрибута из строки в число с помощью метода Integer.parseInt()
      GroupData group = new GroupData(id, name, null,null);
      groups.add(group);
    }
      return groups;
  }

Теперь можно перейти к сравнению и определению максимального идентификатора


public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group); 
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);


    before.add(group);
    //устраиваем цикл по всем элементам
    int max = 0;  
    for (GroupData g : after) {
      if (g.getId() > max) {
        max = g.getId();
      } 
    group.setId(max); //в конце найдется самый большой, присвоим его в качестве идентификатора новой группы; сгенерируем метод setter 
    }
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }

}


Для начала присваиваем переменной max значение 0, потом постепенно сравниваем уже найденный максимум с идентификатором каждого элемента, если идентификатор окажится больше, то значение переменной max меняем на новый найденный максимум.  


Сгенерируем метод setter 

//сеттер всегда имеет модификатор void и только один параметр, для изменения значения одного поля

private final int id; //модификатор final означает что менять атрибут нельзя. То значение, которое присвоено в конструкторе оно и остается навсегда. 

Мы хотим менять индентификатор, final убирем
private int id;


Запускаем тест. Тест зеленый. 
  
}
Урок 46. Лямбда-выражения (анонимные функции) и элементы функционального программирования {

До версии Java 8 можно было функции только вызывать, обращаться к ним по имени. 

Основаная идея функционального програмирования заключается в том, что с функцией можно работать как с объектом. Ее можно присвоить в переменную, передать в качестве параметра при вызове другой функции. То есть функция такая самостоятельная сущность.

//поиск элемента с максимальным идентификатором 
//старый способ сравнения
int max = 0;
for (GroupData g : after) {
  if (g.getId() > max) {
	max = g.getId(); 
  }
}

Как сделать функцию , которая вычисляет максимальный элемент для списка, который содержит произвольные объекты (не только числа)?
Нужно передать в такую функцию в качестве параметра описание того, как сравниваются элементы. То есть передать функцию, которая умеет сравнивать объекты. 


1 способ
Использовать встроенную возможность, которая появилась в стандратной библиотеке Java 8

Список можно превратить в поток Stream.

Превращаем список в поток, у него есть метод max(), который позволяет вычислять максимальный элемент. В метод max() передадим в качестве параметра компаратор (сравниватель).

after.stream().max(byId) //Если предположить что метод отработал, то есть нашел максимальный элемент, то мы можем при помощи метода get() этот элемент получить и взять у него идентификатор  

int max = after.stream().max(byId).get().getId(); //чтобы это заработало, реализуем сравниватель 

Alt + Enter > Create local variable //создается переменная правильного типа 


Comparator<? super GroupData> byId; //компаратор, который умеет сравнивать объекты типа GroupDate
int max = after.stream().max(byId).get().getId();


Инициализируем переменную, присвоим в нее конкретное значение //добавим = new Comparator<GroupData>()

Comparator<? super GroupData> byId = new Comparator<GroupData>() {
      @Override
      public int compare(GroupData o1, GroupData o2) {
        return 0;
      }

}

Компаратор - это интерфейс, который не имеет реализации он только декларирует, объявляет какие методы должны быть. Но реализации этих методов не содержит. 
Можно создать класс, который наследуется от / реализует этот интерфейс. Но это делать не обязательно. Когда создаются такие одноразовые объекты, можно использовать аннонимные классы для которых реализация пишется здесь и сейчас.    


//новый способ сравнения
//1 - сравниватель для двух объектов типа GroupData
Comparator<? super GroupData> byId = new Comparator<GroupData>() { //должен быть реализован один единственный метод compare(), при помощи которого должны сравниваться два объекта типа GroupData
  @Override
  public int compare(GroupData o1, GroupData o2) {
	return Integer.compare(o1.getId(),o2.getId()); //используем метод compare(), который умеет сравнивать числа
  }
};
//2 - вычисление максимального объекта 
int max1 = after.stream().max(byId).get().getId(); //max(byId) сравниваются объекты при помощи компаратора 
group.setId(max1);


Лямбда-выражения - анонимные функции 


Переделаем анонимный класс в анонимную функцию //установив режим совместимости Project Structure > Modules > Language level - 8

Comparator<? super GroupData> byId = new Comparator<GroupData>() {} //класс new Comparator<GroupData>() является функциональным интерфейсом , поэтому его можно заменить на лямбда - выражение 
@FunctionalInterface - означает что внутри него имеется одна единственная функция, которая может быть представлена как самостоятельная сущность.   

Comparator<? super GroupData> byId = (Comparator<GroupData>) (o1, o2) -> Integer.compare(o1.getId(),o2.getId());
    int max1 = after.stream().max(byId).get().getId();
    group.setId(max1);



//названия параметров (o1, o2) -> тело функции Integer.compare(o1.getId(),o2.getId());
//от локальной переменной можно избавится, аннонимную функцию лямбда выражение можно передать в качестве параментра при вызове метода max() 
	
int max1 = after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId();	
	
/*список превращаем в поток
 по этому потоку пробегает функция сравниватель и находит максимальный элемент
 при этом сравниваются объекты типа GroupData путем сравнивания их индентификаторов
 get() на выходе этой функции будет максимальный объект, то есть группа с максимальным идентификатором
 getId() остается взять этот идентификатор
*/ 
	
	
	
  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    group.setId(after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId());
    before.add(group);
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }	
	

}
Урок 47. Сортировка списков {

В тесте для модификации групп реализуем другой способ решения проблемы сортировки.
Вместо того, чтобы игнорировать порядок, мы наведем свой собственный. Например, упорядочим группы по идентификаторам. 


  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData(before.get(before.size() -1).getId(),"test1", "test2", "test3");
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    before.remove(before.size() -1);
    before.add(group);
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }
/* 
Мы не знали в каком порядке находятся элементы. После модификации группы она могла находится в другом месте. 
Потому что сортировка в тестируемом приложении выполняется по неизвестному правилу. 
Мы решили полностью игнорировать порядок и сравнивать множества вместо списков.
*/

Как сортировать список?

// Старый способ Collections.sort()

В Java 8 у списка появился метод sort(), который в качестве параметра принимает компаратор т.е. описание правил сравнения объектов 

before.sort(byId); //сравниваем по идентификаторам

Просим среду разработки, чтобы она создала локальную переменную byId

Сразу пишем лямбда-выражение
 
Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId()); 
/*
= анонимная функция, которая на вход принимает два параметра(группа_1, группа_2) 
и выполняет сравнение идентификаторов Integer.compare(первый_идентификатор,второй_идентификатор) 
это и будет возвращаемый результат этой аннонимной функции
*/


  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() - 1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData(before.get(before.size() - 1).getId(),"test1", "test2", "test3"); 
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    before.remove(before.size() - 1);
    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }

Модифицируем тест для создания группы
Упорядочим группы и сравним получившиеся списки, в которых группы находятся в одинаковом порядке. При этом даже не нужно определять идентификатор новой добавленной группы, потому что она должна оказаться в конце.

было
  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    group.setId(after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId());
    before.add(group);
	
	 
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); 
  }

стало

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }

Как добится чтобы новая группа оказалась в самом конце?  

  public GroupData(String name, String header, String footer) {
    this.id = Integer.MAX_VALUE; //дефолтное значение для индентификатора  
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

Теперь достаточно сравнивать только name

Перегенерируем функцию equals()

Запустим тест. Тест зеленый.


}


Занятие 5. Улучшение кода тестов. Работа со строками
Урок 48. Как правильно запускать браузер {

Оптимизируем тесты 

Для каждого теста запускается отдельный экземляр браузера.
Можно попробовать сэконоить, использовать один и тот же браузер (одно и тоже окружение для выполнения нескольких тестов подряд).

//Надо стараться делать тесты независимыми, чтобы они могли для себя подготовить тестовую ситуацию. Где каждый тест проверяет предусловие и сам для себя создает все что ему необходимо.     


Ведущую роль играет класс TestBase, в котором вызывается метод init() в начале (в классе ApplicationManager, который в свою очередь запускает браузер) и метод stop() в конце. 
Это происходит перед каждым тестовым методом, потому что указана анатация @BeforeMethod  //дает указание тестовому фреймворку выполнять метод setUp() перед каждым тестовым методом  

Посмотрим какие есть варианты Ctrl+Space

@BeforeMethod //тот метод, который помечен этой анатацией, запускается перед каждым тестовым методом

@BeforeClass //запускается перед всеми тестовыми методами, которые выходят в какой-то класс 
 
@BeforeGroups //в TestNG можно указать, что тестовый метод принадлежит какой-то группе 

@BeforeSuite 

В TestNG Suite всегда один единственный, он соответствует одному запуску. Он может состоять из нескольких тестов.
Сделать Suite, который состоит из нескольких тестов, можно только с помощью специального конфигурационного файла. 
Если тесты запускаются из среды разработки (ПКМ на пакет / класс), то автоматически создается Suite, который состоит из одного единственного теста. То есть в данном случае, никакой разницы между Suite и тест нет. Она возникает, когда используется конфигурационный файл.
Suite всегда один единственный, а тестов может быть несколько. Тест это часть Suite. Тест включает в себя классы. Классы состоит из нескольких тестовых методов. Suite > Test > Class > Method


Если мы хотим запустить один единственный экземляр браузера, его нужно запустить в методе, который помечен анатацией @BeforeSuite, а останавливать @AfterSuite.

Тесты упали, потому что не получили доступ к браузеру. 

Тесты разложены по разным классам. И для того чтобы их запустить TestNG, создает экземляр тестового класса, этот тестовый класс наследуется от класса TestBase  //получает доступ к переменной app

Но когда создается другой экземляр, другого тестового класса, то это будет совсем другая переменная app. Каждая из них ассоциирована со своим объектом. Этих объектов много, по одному для каждого тестового класса. А метод @BeforeSuite выполняется один раз. 
В каком именно из этих многочисленных объектов он будет выполняться? Ни в каком.
 
TestNG сначала создаст экземляр класса TestBase, в котором будет ссылка на ApplicationManager и в этом объекте выполнит инициализацию, а потом создаст экземляр какого то тестового класса, в котором тоже будет ссылка на ApplicationManager. Но она не будет инициализирована.  
Единственная инициализированная, находится в том самом объекте типа TestBase, который вообще не используется для запуска тестов. Он играет чисто вспомогательную роль. 

Как эту проблему решить?
Нужно ссылку на ApplicationManager сделать общей для всех тестов. Объявим ее static

protected static final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);

Все функции находятся внутри какого-то класса. Несмотряна это, для вызова static функции не нужно создавать объект этого класса. К ней можно обращаться непосредственно / на прямую. Тоже относится к переменным. 


Если пометить переменную static, то она становится независимой. То есть не является частью какого-то объекта. Это самостоятельная глобальная переменная. К ней может получить доступ кто угодно по ее имени (TestBase.app)

**
TestNG в самом начале создает экземляр класса TestBase, в нем выполняется код инициализации app.init(), который инициализируем глобальную переменную. Далее создается экземляр класса например  GroupCreationTests, который тоже пользуется этой переменной. Потом создается другой экземляр, другого класса, и в самом конце TestNG выполняет tearDown(), обращается к глобальной переменной app.stop().   
}
Урок 49. Улучшение кода тестов - ещё немного реструктуризации кода {

Код тестовых сценариев - фасадная часть работы тестировщика автоматизатора 

В TestBase есть глобальная инициализация @BeforeSuite 

Для одного теста или группы тестов может существовать локальные инициализации, которые нужны чтобы подготовить состояние именно для конкретного теста.

//данный фрагмент кода будет общий для всех тестов проверки модификации групп 
    app.getNavigationHelper().gotoGroupPage();  
    if (!app.getGroupHelper().isThereAGroup()) { //проверка предусловия
      app.getGroupHelper().createGroup(new GroupData("test1", null, null)); //если предусловие не выполняется, то подготовка состояния
    } 

Поместим его в отдельный метод с анатацией @BeforeMethod


public class GroupModificationTests extends TestBase {

  @BeforeMethod //перед каждым тестовым методом должна выполняться проверка предусловия
  public void ensurePreconditions() {
    app.getNavigationHelper().gotoGroupPage();
    if (!app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
  }

  @Test
  public void testGroupModification() {
    List<GroupData> before = app.getGroupHelper().getGroupList();
    int index = before.size() - 1;
    GroupData group = new GroupData(index, "test1", "test2", "test3");
    app.getGroupHelper().modifyGroup(index, group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size());

    before.remove(index);
    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(), g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }


}

Самое главное требование, которое предъявляется к тестам - это легкость их восприятия / понятность. 

А когда инициализация находится в другом классе, это негативно складывается на восприятии. 


}
Урок 50. Улучшение названий методов {

 

Некотороые методы начинаются на get /set.
Наличие такого метода обычно означает, что у объекта есть атрибут. Но прямой доступ к этому атрибуту не разрешен. И к нему можно обратиться только с помощью вспомогательного метода - название которого обычно является производным от названия атрибута. 


В AM имеется атрибут, который называется NavigationHelper. Ему соответствует парный метод getNavigationHelper(). //традиционное соглашение об именах 

Называйте методы так, чтобы их было легко читать. 

}
Урок 51. Fluent-интерфейсы {

Fluent (плавный / гладкий) - интерфейсы, целью которых является увеличение понятности и легкости чтения кода.

Основной прием реализации интерфеса - вытягивание методов в цепочки / каскадный вызов методов //app.contact().create()



В классе GroupData удаляем отметку final

Генерируем Setters

Меняем завание getName на withName

добавляем возвращаемое значение

меняем тип void на GroupData


public GroupData withId(int id) {
    this.id = id;
    return this; //метод будет возвращать тот самый объект, в котором он вызван. Это позволяет строить каскады - вытягивать методы в цепочку
  }
//это ссылка на самого себя внутри экземпляра класса
//метод вернет экземляр класса GroupData, вызвавший его

Удаляем конструкрторы, добавив дефолтное значение атрибуту 


Фактически у нас остается один единственный конструктор, который не принимает никаких параметров. 
И при этом новый созданный объект инициализируется дефолными значениями

public class GroupData {
  private int id = Integer.MAX_VALUE; //макс значение перенесли из удаленного констуктор
  private String name; //три атрибута будут иметь значение null
  private String header;
  private String footer;   

}


Теперь сломались все места в которых сломался контсруктор. Исправляем

было
public void testGroupCreation() {
  ...  
    GroupData group = new GroupData("test2", null, null);
  ...	
	}



стало
public void testGroupCreation() {
  ...  
    GroupData group = new GroupData().withName("test2");
  ...	
	}

Теперь легко читается как обычный английский тест, в этом и состоит идея гладкости 

GroupData group = new GroupData().withId(before.get(index).getId()).withName("new1").withHeader("new2").withFooter("new3");
    

Аналогично меняем в других методах, где создается новый объект типа GroupData

public List<GroupData> list() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value")); 
      GroupData group = new GroupData().withId(id).withName(name); //со значением null не надо указывать 
      groups.add(group);
    }
}

Каждый вызываемый метод, возвращащает тот же самый объек, который мы модифицируем шаг за шагом. И в конце тоже возвращается тот же самый объект, который в конечном итоге присваивается в переменную.   	
	
	
Конструировать объекты стало приятнее, потому что мы явно указываем какой атрибут принимает какое значение.	
	
Шаблон билдер - интерфейс, который описывает способ использования плавных интерфейсов для конструирования объектов  	


}
Урок 52. Повсеместное использование уникальных идентификаторов объектов {


Нужно определить способ для того, чтобы найти нужный элемент, который нужно удалить /модифицировать. 

Можно искать элементы по уникальным идентификаторам, вместо порядковых номеров. 

Перейдем к тесту для создания групп

Как опредилить максимальный идентификатор (нового элемента)?

Переделаем GroupHelper

Создадим метод, который возвращает не список, а уже готовое множество 

  public Set<GroupData> all() {
    Set<GroupData> groups = new HashSet<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value"));
      groups.add(new GroupData().withId(id).withName(name));
    }
    return groups;
  }




public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.goTo().groupPage();
    Set<GroupData> before = app.group().all();
    GroupData group = new GroupData().withName("test2");
    app.group().create(group);
    Set<GroupData> after = app.group().all();
    Assert.assertEquals(after.size(), before.size() + 1);

    before.add(group);
    Assert.assertEquals(before, after);
  }

}

В классе GroupData указываем сравнение по id и name, чтобы элементы не схлопывались


В тесте новой добавленной группе нужно присвоить идентификатор

group.withId(вычисление максимального идентификатора)

group.withId(after.stream().mapToInt((g) -> g.getId()).max().getAsInt(); //поток типа GroupDate превращаем в поток идентификаторов (чисел)
before.add(group);
Assert.assertEquals(before, after);


Функция mapToInt() в качестве параметра принимает описание того, как объект преобразуется в число. 
То есть туда мы должны передать аннонимную функцию, которая будет последовательно применяться ко всем элементам потока и каждый из них будет последовательно преобразовать в число. 
В результате, из потока объекта типа GroupData получаем поток целых чисел.   
 

(g) -> g.getId() //аннонимная функция, которая в качестве параметра принимает группу, а в качестве результата выдает идентификатор этой группы, то есть преобразует объект в число 

поток целых чисел. max() //функция не принимает никаких параметров, потому что Java сама умеет сравнивать числа 

getAsInt() //преобразуем в обычное целое число  

/*
before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);



*/



Модифицируем тест для удаления групп

заменяем вызов метода list() на all()

меняем тип переменной List на Set

оранжевый цвет намекает на то, что какие то проблемы есть: "Множество объектов типа GroupData не может содержать множество объектов типа Integer"

Фармально это ошибкой не является, потому что метод remove() на вход принимает произвольный объект (Object). Можно попытаться удалить из этого множесва все что угодно. Но с логической точки зрения, удалять нужно группу. А по индексу из множества удалить ничего нельзя, потому что порядок не определен. 
Следовательно, вместо index нужно использовать какой то конкретный объект. 


GroupData deletedGroup = before. //нужно извлечь любой элемент из множества (нам все равно какой удалять), но методов get нет. и нет методов чтобы возвращал объект типа GroupData	
before.remove(deletedGroup);

Сначала нужно получить iterator(), который позволяет последовательно перебирать элементы, а потом вызвать метод next(), он вернет первый попавшийся элемент множества. 

При этом если множество пустое, то возникнет проблема. Будет выбрашено исключение, которое сообщает что извлечь элемент из множества не удалось. Для этого у нас есть проверка предусловия, поэтому точно знаем что множество не пустое.

GroupData deletedGroup = before.iterator().next();
before.remove(deletedGroup);
 
//нужно удалять элемент по идентификатору

app.group().delete(deletedGroup);
 
Можно в качестве параметра передавать не идентификатор, а непосредственно объект, который сожержит id и всю остальную информацию об удаляемой группе

Реализуем новый вспомогательный метод delete()

  public void delete(int index) {
    selectGroup(index); //выбор по порядковому номеру
    deleteSelectedGroups();
    returnToGroupPage();
  }

  public void delete(GroupData deletedGroup) {
    selectGroupById(deletedGroup.getId()); //выбор по идентификатору номеру
    deleteSelectedGroups();
    returnToGroupPage();
  }

Нужно сделать второй метод selectGroupById(), потому что идентификатор это тоже целое число, и нельзя использовать один и тот же метод selectGroup(), у которого тип параметра int потому по типу параметра различить не получается. 

  public void selectGroup(int index) {
    driver.findElements(By.name("selected[]")).get(index).click();
  }

  public void selectGroupById(int id) { //если передается идентификатор, то нельзя взять список элементов, и потом по индексу выбрать нужный
    driver.findElement(By.cssSelector("input[value='" + id + "']")).click();//вместо этого нужно сразу построить локатор элементов, в котором id участвует 
  }

//локатор: тег input атрибут value="75" (склеивание строки)
// findElements замена на findElement потому что сразу найдется нужный элемент

Теперь элемент из списка выбирается случайным образом

Перейдем к тесту для модификации групп

	//теперь мы работаем с несортированными наборами элементов
	
  public void testGroupModification() {
    Set<GroupData> before = app.group().all(); //set , all
    GroupData modifiedGroup = before.iterator().next(); // select random object
    GroupData group = new GroupData().withId(modifiedGroup.getId()).withName("new1").withHeader("new2").withFooter("new3");
    app.group().modify(group);  
    Set<GroupData> after = app.group().all();
    Assert.assertEquals(after.size(), before.size());

    before.remove(modifiedGroup);
    before.add(group);
    Assert.assertEquals(before, after);
  }


}
Урок 53. Hamcrest - улучшение внешнего вида проверок {

Библиотека Hamcrest предоставляет флуент интерфейс. 
Вместо класса Assert используется класс MatcherAssert


MatcherAssert.assertThat(after, CoreMatchers.equalTo(before));
	
//ctrl + space чтобы подтянулись названия методов, а не только классов

//CoreMatchers проверялка	
	
	
Указывать префекс необязательно, вместо этого можно выполнить статический импорт //Это можно делать только для статических (глобальных) функций

Alt + enter > add static import //Добавляется импорт не класса, а конкретного метода

  @Test
  public void testGroupCreation() {
    app.goTo().groupPage();
    Set<GroupData> before = app.group().all();
    GroupData group = new GroupData().withName("test2");
    app.group().create(group);
    Set<GroupData> after = app.group().all();
    assertThat(after.size(),equalTo(before.size() + 1));

    group.withId(after.stream().mapToInt((g) -> g.getId()).max().getAsInt());
    before.add(group);
    assertThat(after, equalTo(before));
  }

Сделаем следующий шаг, прикрутим флуент интерфейс к спискам

assertThat(after, equalTo(before.withAdded(group)); 


Но добавить метод withAdded(), в уже существующий интерфейс Set<GroupData> before = app.group().all() нельзя, и даже в существующий класс нельзя.
Поэтому нам придется сделать свой собственный класс. Который с одной стороны, ведет себя как обычный традиционный Set (множество), с другой в него можно добавить свои собственные методы. Метод, который добавляет элемент в множество; метод - удаляет элемент из множества. 

Реализуем такой класс при помощи библиотеки Гуава
В ней есть специальный набор вспомогательных классов, которые предназначены для построения коллекций с расширенным набором методов ForwardingSet и ForwardingList 	
	
/*
Шаблон проектирования или паттерн (англ. design pattern) — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях. 
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.

*/

	
В пакет modul добавим класс Groups, который расширяет ForwardingSet 


public class Groups extends ForwardingSet<GroupData> {  //делаем расширенную версию множества типа GroupData
}
 	
Alt+enter > Implement methods 	//нужно реализовать обязательный метод delegate() 

Библиотека Гуава реализует шаблон проектирования Декоратор
http://github.com/google/guava/wiki/collectionhelpersexplained
	
Суть заключается в том, что все вызовы методов делегируются к какому то объекту (реальному списку / множеству), который вложен во внутрь обертки.
Кроме того, в этой обертке мы может реализовать свои дополнительные методы, которые тоже будут взаимодействовать с объектом, которому все это делегируется.  Также, при помощи этого механизма, можно предопределить поведение уже существующих методов.

Мы хотим, чтобы стандартные методы просто делегировались вложенному списку / множеству - эту задачу на себя берет класс ForwardingSet(). А мы добавим свои собственные методы. 


public class Groups extends ForwardingSet<GroupData> {  

  private Set<GroupData> delegate; //объект - множество, которому все будет делегироваться (атрибут объекта) 

  @Override
  protected Set<GroupData> delegate() { //метод, который будет возвращать этот объект
    return delegate;
  }
  
  public Groups withAdded(GroupData group) { //добавили свой метод
	  
  }
  
}

Чтобы можно было вытягивать методы в цепочки и строить из них каскады, необходимо чтобы возвращался объект типа Groups.   
 
1 способ 
Поэтому нужно в уже существующее множество private Set<GroupData> delegate добавить тот объект, который передан в качестве параметра withAdded(GroupData group) и вернуть this. То есть тот объект, в котором вызывается метод withAdded().

2 способ
Сделать копию, так чтобы старый объект остается неизменным. А метод withAdded() возврал новый объект c добавленной новой группой.
Копировани объектов дает возможность работать со старым множеством без добавленной группы и с новым множеством с добавленной группой. 

public class Groups extends ForwardingSet<GroupData> {

  private Set<GroupData> delegate;

  //конструктор, будет строить копию существующего объекта
  
  public Groups(Groups groups) { 
    this.delegate = new HashSet<>(groups.delegate); //берем множество из существующего объекта, который передан в качестве параментра groups. = Строим новое множество, которое содержит теже самые элементы, и присваиваем this. новое множество в качестве атрибута в новый создаваемый этим конструктором объект delegate  
  
  /*  
	(Groups groups) // конструктор в качестве параметра получил объект типа "множество" 
	groups.delegate //взяли множество из существующего объекта  
	= new HashSet<>() //строим новое пустое множество 
	= new HashSet<>(groups.delegate) - строим новое множество, в которое добавляем все элементы существующего множества
	this.delegate //указываем на атрибут объекта типа "множество"
	this.delegate = new HashSet<>(groups.delegate) - присваиваем новое множество (копию) в качестве атрибута в новый создаваемый этим конструктором объект   
  */
  
  }

  @Override
  protected Set<GroupData> delegate() {
    return delegate;
  }

  public Groups withAdded(GroupData group) { //добавили свой метод
    Groups groups = new Groups(this); //создали копию
    groups.add(group); //в копию добавлили объект, который передан в качестве параментра
    return groups; //вернули построенную копию с добавленной группой
  }
  
//аналогично сделаем копию, из которой удалена какая то группа 

  public Groups without(GroupData group) {
    Groups groups = new Groups(this);
    groups.remove(group);
    return groups;

  }	
}

Возвращаемся обратно в тест

Меняем тип Set<GroupData> на Groups

Изменим метод all(), чтобы он возвращал объект типа Groups 


  public Groups all() {
    Groups groups = new Groups(); //не хватает конструктора без параметров**
	
	//дальше копии строится не будут, заполнится только тот объект который мы создали
	//Никакой необходимости в клонировании нет, потому что нет старого списка, который мы хотели бы сохранить
	
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value"));
      groups.add(new GroupData().withId(id).withName(name));
    }
    return groups; //и в конце он вернется
  }
  
//**создадим конструктор без параметров	
  public Groups() {
    this.delegate = new HashSet<>();
  }	

А в тестах очень плезно делать копии. Потому что старый список, может еще пригодится для каких то других проверок. 

В итоге получим,

public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.goTo().groupPage();
    Groups before = app.group().all();
    GroupData group = new GroupData().withName("test2");
    app.group().create(group);
    Groups after = app.group().all();
    assertThat(after.size(),equalTo(before.size() + 1)); 
    assertThat(after, equalTo(before.withAdded(group.withId(after.stream().mapToInt((g) -> g.getId()).max().getAsInt()))));

  }
}


GroupData group = new GroupData().getName("test2"); 
GroupData group  //создали переменную и указали ее тип //переменная указывает на объект GroupData
GroupData group = new GroupData()// оператор new вызывает конструктор для объекта group (Конструктор предоставляется автоматически, используется по умолчанию и инициализирует все переменные экземпляра их значениями по умолчанию) // создается копия объекта с пустыми полями
getName("test2")// сеттер, присваивает значение полю name тому объекту, для которого он был вызван
GroupData().withName("test2") //вызываем метод сеттер у пустого объекта и передаем ЕМУ в качестве аргумента строку, и эта строка присваивается в поле name нашего объекта




Проверку assertThat(after.size(),equalTo(before.size() + 1)) можно поставить как перед, так и после; потому что объект before() остается неизменным, в сравнении участвует его копия. А before сохраняет старый размер. Удобно когда можно не заботится о порядке проверок.  




Переходим к тесту удаления

public class GroupDeletionTests extends TestBase {

  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) {
      app.group().create(new GroupData().withName("test1"));
    }
  }

  @Test
  public void testGroupDeletion(){
    Groups before = app.group().all();
    GroupData deletedGroup = before.iterator().next();
    app.group().delete(deletedGroup);
    Groups after = app.group().all();
    assertEquals(after.size(),before.size() -1);
    assertThat(after, equalTo(before.without(deletedGroup)));
  }

}


К тесту мофидификации


public class GroupModificationTests extends TestBase {

  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) {
      app.group().create(new GroupData().withName("test1"));
    }
  }

  @Test
  public void testGroupModification() {
    Groups before = app.group().all();
    GroupData modifiedGroup = before.iterator().next();
    GroupData group = new GroupData()
            .withId(modifiedGroup.getId()).withName("new1").withHeader("new2").withFooter("new3");
    app.group().modify(group);
    Groups after = app.group().all();
    assertEquals(after.size(), before.size());
    assertThat(after, equalTo(before.without(modifiedGroup).withAdded(group)));
  }

}



	
}
Урок 54. Кеширование результатов длительных операций {
	
public class GroupDeletionTests extends TestBase {
  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) { //загружаем группы 1 раз
      app.group().create(new GroupData().withName("test1"));
    }
  }

  @Test
  public void testGroupDeletion(){
    Groups before = app.group().all();//загружаем группы 2 раз
    GroupData deletedGroup = before.iterator().next();
    app.group().delete(deletedGroup);
    Groups after = app.group().all(); //загружаем группы 3 раз
    assertEquals(after.size(),before.size() -1);
    assertThat(after, equalTo(before.without(deletedGroup)));
  }
}

Ускорим работу теста со списком, состоящим из сотни групп 

Ускорить чтение списка не можем. Но может сократить количество раз, которые мы делаем эту сложную операцию. 

Реализовать кеширование означает запомнить результат выполнения какой то операции. И потом вместо после повторного выполнения этой операции использовать ранее запомненный ранее результат. 

Реализуем кеш в GroupHelder

public Groups groupCache = null; //создадим пустое поле

public Groups all() {
	if (groupCache != null) { //добавим проверку, если кеш не пустой 
	  return new Groups(groupCache); //возвращаем копию кеша. Именно копию, чтобы кеш никто не испортил
	}
	//иначе если кеш не заполнен, придется прочитать список со страницы веб приложения 

    groupCache = new Groups(); //инициализируем кеш
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value"));
      groupCache.add(new GroupData().withId(id).withName(name));
    }
    return new Groups(groupCache); //в конце возвращаем копию кеша
  } 


Но в какие то моменты кеш надо сбрасывать. Например, когда точно знаем список групп поменялся. 

app.group().delete(deletedGroup);
groupCache = null;


submitGroupModification();
groupCache = null;

submitGroupCreation();
groupCache = null;

После всех этих действий кеш будет очищен, и при следующем обращении к методу all() будет создан заново. 

Таким образом, эта тяжеловесная операция будет выполняться минимальное количество раз, именно тогда,когда чтото поменялось.

	
}
Урок 55. Хеширование и предварительные проверки {
	
Создадим неготивный тест, который проверяет что нельзя создать группу с именем содержащей символ ' 
//приложение запрещает

При этом размер списка не должен поменяться. 
И старый список должен быть равен новому списку.

  @Test
  public void testBadGroupCreation() {
    app.goTo().groupPage();
    Groups before = app.group().all();
    GroupData group = new GroupData().withName("test2'"); //вводится запрещенный символ
    app.group().create(group);
    Groups after = app.group().all();
    assertThat(after.size(),equalTo(before.size())); //размер старого и нового списка одинаковый 
    assertThat(after, equalTo(before)); //новый список равен старому
  }
 

А что если группа не должна создаваться, а она создается?
Тогда тест падает, потому что не сойдется размер списков



Groups after = app.group().all(); // загружается список
assertThat(after.size(),equalTo(before.size())); // падает здесь

Зачем загружать весь список если нужно проверить только количество элементов?
Можно переставить вышеуказанные строки местами 
Но просто так это сделать нельзя, потому что нужен альтернативный список узнать количество групп //ошибка в after.size()

  public int Count() { 
    return driver.findElements(By.name("selected[]")).size(); //происходит одно единственное обращение к браузеру
  }

Вместо загрузки информации о сотни групп, и делать примерно 200 обращений к браузеру, количество можно узнать за одну единственную операцию. 	

  @Test
  public void testBadGroupCreation() {
    app.goTo().groupPage();
    Groups before = app.group().all();
    GroupData group = new GroupData().withName("test2'");
    app.group().create(group);
    assertThat(app.group().сount(), equalTo(before.size())); //простая проверка будет выполнятся до того, как перейти к сложной проверки
    Groups after = app.group().all();
    assertThat(after, equalTo(before));
  }
	
С точки зрения производительности, проверки	размеров списка надо ставить как можно раньше. И для получения количества групп использовать более быструю операцию. 

Это называется хеширование - предварительная проверка при помощи более быстрой операции. 

Прежде чем загружать список групп надо проверить сходится ли количество.

 //пример хеширования, которое генерируется одновременно с методом equal()
  @Override
  public int hashCode() { //генерируются парой с equals() и согласованы друг с другом
    int result = id;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    return result;
  }	
	
Прежде чем сравнивать объекты при помощи метода equals(), можно попытаться выполнить более быструю проверку и сравнить хешкоды объектов. 
У равных объектов должны быть равные хешкоды. У разных объектов хешкоды могут случайно совпасть. 
Но если хешкоды не совпали, то проверка с помощью метода equals() уже не нужна.	
Хеш код это способ ускорения проверки, операция которая выоплняется быстрее чем equals() и позволяет выполнить предварительную проверку.
	
	
	

}	
Урок 56. Способы построения сложных локаторов {
	
Поговорим о регулярных выражениях, которые используют разделители для разрезания строк

Создадим тест, который проверяет корректность представления телефонов на главной страницы приложения

	
	
public class ContactPhoneTests extends TestBase {



  @BeforeMethod //добавим предусловие	
  public void ensurePreconditions() {
    app.goTo().HomePage();
    if (app.contact().all().size() == 0) {
      app.contact().create(new ContactData().withFirstname("Alex").
              withLastname("Jackson").withAddress("My street").
              withMobileNum("111").withHomeNum("222").withWorkNum("333").withGroup("test1"), true);
    }
  }

  @Test
  public void testContactPhones(){
    app.goTo().HomePage();
    //загружаем множество контактов, выбираем случайным образом какой то контакт
    ContactData contact = app.contact().all().iterator().next();
    //далее будем сравнивать информацию на главной странице с данными в форме редактирования контакта
	//для отладки оставим в таблице один контакт 
    //сделаем вспомогательный метод
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact);	
	
	}
}
	
	
	
//вспомогательный метод который загружает информацию из формы редактирования
  public ContactData infoFromEditForm(ContactData contact) {
    initContactModificationById(contact.getId()); //выбор контакта по идентификатору
    String firstname = driver.findElement(By.name("firstname")).getAttribute("value");
    String lastname = driver.findElement(By.name("lastname")).getAttribute("value");
    String home = driver.findElement(By.name("home")).getAttribute("value");
    String work = driver.findElement(By.name("work")).getAttribute("value");
    String mobile = driver.findElement(By.name("mobile")).getAttribute("value");
    return new ContactData().withId(contact.getId()).withFirstname(firstname).
            withLastname(lastname).withHome(home).withWork(work).withMobile(mobile);
  }
	
	
//вспомогательный метод, который выбирает контакт по идентификатору	
  private void initContactModificationById(int id) {
    driver.findElement(By.xpath(String.format("a[href='edit.php?id=%s']", id))).click(); //способ 1, с помощью ChroPath
  }	
 
  
	
//способ 2 последовательный приближений
  private void initContactModificationById2(int id) {
	  
	//находим чек-бокс
	//ищем элемент, который имеет тег input и атрибут value равное заданному значению  
    WebElement checkbox = driver.findElement(By.cssSelector(String.format("input[value='%s']",id)));
	
	//ищем строку
	//выполняем поиск относительно элемента checkbox 
	//нам нужно от этого чек бокса перейти к ячейке, а от ячейке к строчке
	WebElement row = checkbox.findElement(By.xpath("./../../")); 
	//xpath позволяет перейти к родительскому элементу, то есть к тому в котором находятся данные 
	// By.xpath("./ точка означает поиск с текущего элемента
	// .. переход вверх
	
	//надо попасть в ту ячейку, в которой находится кнопка Edit
	//берем полный список ячеек
	//ищем внутри строки все элементы которые имеют имя td
	List<WebElement> cells = row.findElements(By.tagName("td"));
	
	//среди этих ячеек берем по номеру нужную, внутри ячейки находим ссылку по имени тега а
	cells.get(7).findElement(By.tagName("a")).click();	
	


//способ 3 (в языке запросов xpath нумерация начинается с 1)
driver.findElement(By.xpath(String.format("input[]value=%s/../../..td[8]/a", id))).click(); 


//способ 4 xpath с подразпросами
driver.findElement(By.xpath(String.format("//tr[.//input[@value='%s']]/td[8]/a", id))).click();
//хочу найти строку внутри которой есть чек-бокс с заданным идентификатором
//tr - поиск строки //tr[ограничения (c подзапросом]
//.//input[@value='%s'] подзапрос (означает, что внутри этой строки находится input с заданным атрибутом value)
//когда найдется такая строка, относительно этой строки ищем восьмую ячейку и в ней ссылку   

//способ 5 "хитрый" ссылка тоже содержит идентификатор <a href="edit.php?id=38"></a>
//можно сразу поискать по этому признаку 

driver.findElement(By.cssSelector(String.format("a[href='edit.php?id=%s']", id))).clicl(); //строим css селектор, в котором ищется элемент а, имеющий атрибут href такого вида. 



}	
}
Урок 57. Режем строки (и немного про регулярные выражения) {
	
Загрузим с главной страницы приложения информацию о телефонах и реализуем проверки того, что эта информация действительно представлена корректно. 
	
Как получить телефоны с формы редактирования мы разобрались в прошлом уроке.
Теперь разберемся с главной страницей, то есть обратимся к методу all()	

//было
  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td")); //<tr class name="entry"></tr>
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText(); //это текст второй ячейки
      String firstname = cells.get(2).getText(); //это текст третьей ячейки
      //дальше можем получит строчку, которая содержит все телефоны одновременно
	  String allPhones = cells.get(5).getText();
	  //для того, чтобы заполнить атрибуты объекта типа ContactData нужно три отдельных телефона, поэтому строчку нужно разрезать на части
	  allPhones.split("\n"); //в качестве параметра в этот метод передается регилярное выражение - то есть шаблон поиска (перевод строки) 
	  // "\n" - перевод на следующую строку
	  //результатом будет массив String[], который состоит из трех элементов. Его нужно поместить в переменную Alt+Enter > Introduce local var
      contacts.add(new ContactData().withId(id).withFirstname(firstname)).withLastname(lastname);

    }
    return contacts;
  }
	
//стало 
    	
  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td"));
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText();
      String firstname = cells.get(2).getText();
      String[] phones = cells.get(5).getText().split("\n");
      contacts.add(new ContactData().withId(id).withFirstname(firstname).withLastname(lastname));//* сюда добавим атрибуты с номера телефонов
    }
    return contacts;
  }
	
Теперь полученные данные используем для того, чтобы заполнить атрибуты нашего модельного объекта	

public ContactData infoFromEditForm(ContactData contact)
    contacts.add(new ContactData().withId(id).withFirstname(firstname).withLastname(lastname).withHome(phones[0]).withMobile(phones[1]).withWork(phones[2])); //передали элемент массива в качестве параметра 	
	
Возвращаемся к методу testContactPhones() и добавляем проверки 

  @Test
  public void testContactPhones(){
    app.goTo().HomePage();
    ContactData contact = app.contact().all2().iterator().next();
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact);
    assertThat(contact.getHome(), equalTo(contactInfoFromEditForm.getHome()));
    assertThat(contact.getMobile(), equalTo(contactInfoFromEditForm.getMobile()));
    assertThat(contact.getWork(), equalTo(contactInfoFromEditForm.getWork()));
  }

Но если изменить текст в ячейке с номерами телефонов на 
Home + 7 (111)
Mobile 22-22	
Work 33 33 33
	
То на главной отобразится
+7111
2222
333333	
	
Тест упадет, потому что номера телефонов выглядят по разному 
Expected :+ 7 (111)
Actual   :+7111

Сначала сравниваемые объекты приводятся к общему каноническому виду, оба упрощаются а затем сравниваются. 
 
В классе ContactPhoneTests напишем вспомогательную функцию, которая будет приводить телефон к правильному очищенному виду.	
	
//метод, который удаляет лишнии символы
public String cleaned(String phone) {
  return phone.replaceAll("\\s",""); //заменить все вхождения чего-то на что-то
}
	
Первый параметр - регулярное выражение. 
Внутри строки ищем фрагмент, который подходит под некоторый шаблон и заменяем его на то значение, которое передано в качестве второго параметра (в нашем случае это будет пустая строка)  	
	
Регулярные выражения - мощный язык


Плагин IDEA для тестировани регулярных выражений
https://plugins.jetbrains.com/plugin/2917-regexptester


Онлайн-редактор регулярных выражений 
(можно также в гугле поискать по запросу regex tester java)
http://myregexp.com


\\s означает любой пробельный символ (пробел, табуляция, перевод строки)


public String cleaned(String phone) {
  return phone.replaceAll("\\s","").replaceAll("[-()]",""); //добавим еще один сеанс
}

Остается применить функцию к тем данным, которые получены с формы редактирования. Чтобы привести их к тому виду, который представлен на главной странице. Обратное преобразование невозможно. Потому что неизвестно какие символы надо добавить, легче удалить лишнии символы. 



}
Урок 58. Клеим строки - метод обратных проверок {
Испортим свойства того контакта, телефоны которого проверяются в тесте. 
В форме редактирования очистим поле Mobile.

Теперь на главной странице представлены 2 телефона, но не понятно какие именно телефоны. //в коде приложения тоже не указано

Тест падает, потому что третьего телефона нет.  

Воспользуемся методом обратных проверок
Если нельзя разрезать что то на кусочки и потом эти кусочки сравнить с чем то, значит нужно пойти с противоположного конца. Из известных кусочков склеить большую строку и сравнивать ее целиком.    

Мы не знаем как разрезать телефоны на главной странице, зато мы можем взять атрибуты того объекта, который загружен на главной странице с формы редактирования склеить из них строчку, которая должна выглядеть точно также как на главной странице. И сравнивать ее целиком.



было
  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td"));
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText();
      String firstname = cells.get(2).getText();
      String[] phones = cells.get(5).getText().split("\n"); //исправим то место которое падает
      contacts.add(new ContactData().withId(id).withFirstname(firstname).
              withLastname(lastname).withHome(phones[0]).withMobile(phones[1]).withWork(phones[2]));
    }
    return contacts;
  }

стало

  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td"));
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText();
      String firstname = cells.get(2).getText();
      String allPhones = cells.get(5).getText(); //один большой кусок текста
      contacts.add(new ContactData().withId(id).withFirstname(firstname).
              withAllPhones(allPhones)); //ввели специальный служебный атрибут 
    }
    return contacts;
  }

В GroupData 

добавили атрибут 

private String allPhones;

добавили Getter и Setter


  public String getAllPhones() {
    return allPhones;
  }

  public ContactData withAllPhones(String allPhones) {
    this.allPhones = allPhones;
    return this; //для вытягивания в цепочку
  }

Теперь ContactHelper не будет падать. Он вместо заполнения трех отдельных атрибутов, будет заполнять четвертый атрибут, который содержит эти телефоны вместе.   

Возвращаемся в тест 

  @Test
  public void testContactPhones() {
    app.goTo().HomePage();
    ContactData contact = app.contact().all2().iterator().next(); //контакт, который загружен с главной страницы содержит только правильное значение атрибута allPhones, а отдельные телефоны у него не заполнены
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact); //контакт который загружен с формы редактирования, содержат отдельные атрибуты для телефонов, но пустой allPhones
	
	//поэтому сравнивать нужно будет allPhones того контакта, который загружен с главной страницы и строчку которую будем клеить  
    assertThat(contact.getHome(), equalTo(mergePhones); //делаем вспомогательный метод 
   
  }
  
  //метод, который удаляет лишнии символы
  public String cleaned(String phone) {
    return phone.replaceAll("\\s","").replaceAll("[-()]",""); //заменить все вхождения чего-то на что-то
  }
  
  private String mergePhones(ContactData contact) {
    return null;
  }

Старый способ до появления элементов функционального программирования в java 8 

  private String mergePhones(ContactData contact) {
	String result = ""; //делаем пустую строчку
	if (contact.getHomePhone() != null) {//добавляем в нее что-нибудь
		result = result + contact.getHomePhone(); //и так далее для всех 3 телефонов 
		} //кроме того между ними нужно в качестве разделителя вставить перевод строки 
    return result; 
  }


Как склеить номера телефонов при помощи элементов функционального программирования 
 	
Функциональное программирование используется для того, чтобы последовательно обрабатывать элементы коллекции. 
Поэтому с начала из наших телефонов нужно сформировать коллекцию, которую потом будем склеивать. 

private String mergePhones(ContactData contact) {
 Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork()); //получили список, который состоит из трех элементов
//из этого списка нужно отсеить те элементы, которые равны 0 а остальные будем склеивать
//для этого сначала превращаем список в поток stream()
//фильтруем поток 

Выбрасываем из него те элементы, которые равны пустой строке, иначе они будут мешать при склеивании 
Для этого используется функция filter(), в качестве параметра нужно передать аннонимную функцию
Которая на вход принимает строку, поскольку это поток, построенный из списка строк. И возвращать эта функция должна true или false (оставить элемент или выбросить его).
Оставит нам надо те элементы, которые не равны пустой строке. 


  private String mergePhones(ContactData contact) {
     Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork()).
            stream().filter((s) -> ! s.equals("")); 
			//теперь получаем новый поток, в котором выбрашены пусты строчки
			//остались только непустые строчки, которые нужно склеить вместе. 
			
			
    return null;
  }

Для склеивания используется функция collect() //собрать, в качестве параметра нужно передать Collector 
В стандартной библиотеки java уже есть набор коллекторов классе Collectors, например Collectors.joinings()
Коллектро, который склеивает все элементы потока в одну большую строку, в качеств е параметра передается разделитель "\n"
Эта та строчка, которая будет вставлятся между склеиваемыми фрагментами.  
Результатом метода collect() является строка. 


  private String mergePhones(ContactData contact) {
    return Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork())
            .stream().filter((s) -> ! s.equals("")) //нужно ко всем элементам потока применить функцию очистки 
			.map(ContactPhoneTest::cleaned) //для очистки используем map - ее назначение "применить ко всем элементам потока какую то функцию и вернуть поток, состоящий из результатов жтой функции
			//в java 8 в качестве параметра можно передать не только аннонимную, но и уже существующую глобальную функцию (static)
            .collect(Collectors.joining("\n"));
  } 


В итоге получаем, 


  @Test
  public void testContactPhones() {
    app.goTo().HomePage();
    ContactData contact = app.contact().all2().iterator().next();
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact);
    assertThat(contact.getAllPhones(), equalTo(mergePhones(contactInfoFromEditForm)));
  }

  private String mergePhones(ContactData contact) {
    return Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork())
            .stream().filter((s) -> ! s.equals(""))
            .map(ContactPhoneTests::cleaned)
            .collect(Collectors.joining("\n"));
  }

  //метод, который удаляет лишнии символы
  public static String cleaned(String phone) {
    return phone.replaceAll("\\s","").replaceAll("[-()]",""); //заменить все вхождения чего-то на что-то
  }



  
}
}


Занятие 6. Работы с файлами
Урок 59. Пути к файлам и директориям {
	
Научимся работать с объектами, которые хранят описание файлов, хранящихся на диске. 	
Научимся определять	путь к файлу, установим различия между относительными и абсолютными путями.
    
Например, если при создании контакта хотим прикрепить фото, нужно в поле ввести полный абсолютный путь к файлу, содержащий рисунок.    	
	
Для хранения ссылки на файл с рисунком добавим атрибут типа File в класс GroupData.  	//File находится в пакете java.io (input / output)
	
Делаем для него геттер и сеттер	
	
Сеттер меняем на другой, который позволяет вытягивать методы в цепочку, делать каскад и использовать флуент интерфейс. 
  
  public ContactData withPhoto(File photo) {
    this.photo = photo;
    return this;
  }	

Теперь при создании объекта можно вызвать метод withPhoto(), и передать в него в качестве параметра локальную переменную. 
  @Test
  public void testContactCreation() {
    app.goTo().HomePage();
    Contacts before = app.contact().all();
    File photo = new File().; //инициализируем переменную типа File, после точки нужно указать путь к этому файлу
    ContactData contact = new ContactData().withFirstname("Alex").withLastname("Jackson")
            .withAddress("My street").withMobile("111").withHome("222").withWork("333").withPhoto(photo); //добавили метод с параметром
  
  } 

У каждого файла есть абсолютный путь, относительно корня диска. 
Например, c:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests\src\test\resources\  

Но на другом пк путь к файлу будет уже другим. Поэтому удобнее указать относительный путь, относительно рабочей директории. 
У каждой программы есть рабочая директория. У теста тоже она есть. 

Создадим вспомогательный тест, в котором будет определять какая	директория является текущей во время выполнения тестов. 

  @Test
  public void testCurrentDir() {
    File currentDir = new File("."); //точка означает текущую директорию
  }

Чтобы посмотреть как будет выглядеть объект, какой путь внутри него будет указан, ставим точку останова и запускаем тест. 	
	
В объекте так и написано "." //то есть нет информаци где эта директория расположена 
По косвенным признакам можно догадаться что это не корневая директория проекта, а корневая директория модуля. 

Опредленим абсолютный путь к этой директории. 

  @Test
  public void testCurrentDir() {
    File currentDir = new File(".");
    System.out.println(currentDir.getAbsolutePath());
  }	 
	
	C:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests\. //это корневая директория модуля
	
Если мы хотим указать относительный путь к какому-то файлу, надо указывать путь относительно этой директории, то есть 
	
File photo = new File("src/test/resources/stru.png");
    ContactData contact = new ContactData().withFirstname("Alex").withLastname("Jackson")
            .withAddress("My street").withMobile("111").withHome("222").withWork("333").withPhoto(photo);
	
Перед тем как создавать контакт с рисунком, нужно убедится, что рисунок действительно существует. 
	
  @Test
  public void testCurrentDir() {
    File currentDir = new File(".");
    System.out.println(currentDir.getAbsolutePath());
    File photo = new File("src/test/resources/stru.png"); //созданим объект типа файл, который соответствует уже существующему файлу, находящимуся на диске 
    System.out.println(photo.getAbsolutePath()); //выведем на консоль полный путь к этому файлу
    System.out.println(photo.exists()); //проверим, что файл существует 
  }

В результате получим:
C:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests\src\test\resources\stru.png
true

Доработаем метод fillContactForm()


  public void fillContactForm(ContactData contactData, boolean creation) {
 ...
    type(By.name("photo"), contactData.getPhoto().getAbsolutePath());
    //нужно передать в качестве параметра не просто результат выполнения метода getPhoto()
    // а нужно преобразовать его в строку, которая содержит абсолютный путь к файлу
    //ведь у браузера, который рапускается как отдельный самостоятельный процесс, другая рабочая директория
	//и поэтому он не сможет преобразовать путь относительно проекта в полный путь 
	//поэтому надо сделать это явно	
}
Во время выполнения теста создания группы в приложении видно, что файл прикрепился, но вместе с ним открылось диалоговое окно для выбора файла. Оказывается, что файловые поля ввода действительно заполняется при помщи метода sentKeys. Но кликать по ним не надо. //chrome сам закрывает окно и идет продолжает работу 

protected void type(By locator, String text) {
click(locator);
    if (text != null) {
      String existingText = driver.findElement(locator).getAttribute("value");
      if (! text.equals(existingText)) { 
        driver.findElement(locator).clear();
        driver.findElement(locator).sendKeys(text);}
}
}

Поэтому для ввода файлов, нужно сделать отдельный метод sendKeys без клика. 

Копируем метод type()

было 
  protected void attach(By locator, String text) {
    click(locator);
    if (text != null) {
      //оптимизация, которая проверяет совпадение уже существующее значения, с тем которое мы пытаемся ввести //убираем
      String existingText = driver.findElement(locator).getAttribute("value");
      if (! text.equals(existingText)) {
        driver.findElement(locator).clear(); 
		//убираем очистку поля ввода, потому что в отличии от текстового поля ввода, где новое значение просто допишется в конец для файлового поля ввода, очистка выполняется автоматически
        driver.findElement(locator).sendKeys(text);}
      }
    }

стало
  protected void attach(By locator, File file) { //так как метод предназначен для заполнения файлового поля ввода, передаем в качестве параметра объект типа файл
    if (file != null) {
        driver.findElement(locator).sendKeys(file.getAbsolutePath()); //здесь можно определять абсолютный пусть к файлу, который должен в качестве значения передаваться в метод sendKeys()
    }
  }

Возвращаемся в fillContactForm() и дописываем
attach(By.name("photo"), contactData.getPhoto());

Запускаем тест. Тест зеленый. Диалоговое окно не открывается.



}
Урок 60. Генератор тестовых данных, запись данных в файл {
	
Постепенно движемся в сторону создания тестов, которые будут загружать тестовые данные из внешнего файла 
 	
package ru.testjava.addressbook.generators;

//метод генерирует инфо о группах
public class GroupDataGenerator { 


  public static void main(String[] args){ //запускаемый файл
    //при запуске программы передадим параметры через массив строк Edit Configuration > Configuration > Program arguments 
    int count = Integer.parseInt(args[0]); //количество групп
    File file = new File(args[1]);//путь к файлу

	//1 часть генерация данных
    List<GroupData> groups = generatorGroups(count);
	//2 часть сохраненние данных в файл
    save(groups, file);

  }

  private static List<GroupData> generatorGroups(int count) {
    List<GroupData> groups = new ArrayList<GroupData>();
    for (int i = 0; i < count; i++) {
      groups.add(new GroupData().withName(String.format("test %s", i))
              .withHeader(String.format("header %s", i))
              .withFooter(String.format("footer %s", i)));
    }
    return groups;
    }

  private static void save(List<GroupData> groups, File file) { //выбирем формат coma Separeted Values
    //открываем файл на запись
	//создаем объект типа Writer, через него будет выполняться запись 
    Writer writer = new FileWriter(file); //IDE предупреждает об ошибке Unhandled exception
  }


}	
	
Причины исключения могут быть разными: 
- файл уже существует и у нас нет прав на запись, 
- файла нет и нет директории в которой он должен быть создан (java автоматически создавать директории не будет), 
- указано недопустимое имя файла, ОС не может создать и открыть файл


Есть два пути : //Alt+Enter
- перехват исключения и принять какие то меры, например вывести сообщение об ошибке
- дать возможность исключению пролететь дальше


В декларацию этого метода добавляется информация о том, что во время работы этого метода может возникнуть исключение типа IOException.
И тогда save() перекладывает эту проблему на main(), который тоже может декларировать, что он выбрасывает исключение типа IOException. Но конечно, перехватывать его уже некому и поэтому программа упадет. Нас такой вариант устроит.


  
  private static void save(List<GroupData> groups, File file) throws IOException { //выбирем формат comma separated values (CSV)
    //открываем файл на запись
    Writer writer = new FileWriter(file);
    for (GroupData group : groups) {
      writer.write(String.format("%s;%s;$s\n", group.getName(),group.getHeader(),group.getFooter()));
    }
    //закрываем файл
    writer.close();
  }	
	
Те данные, которые пишутся в объект типа writer не сохраняются мнгнованно на диск, они кешируются. Точно также, как мы пытались кешировать выполнение тяжеловесных операций. Запись данных на диск это медленно. 
Поэтому нужно сначала накопить большой кусок данных в памяти и потом одновременно сбросить их на диск.
Но если программа завершается в тот момент, когда данные еще не полностью сохранены на диск, а находятся в кеше, они могут быть потерены. 
Поэтому нужно явно вызвать writer.closed(). В этот момент содержимое записывается на диск, файл закрывается. Это гарантия того, что все данные благополучно сохранились. 

Запускаем тест - получаем ислючение IndexOutOfBoundsException 
Надо передавать параметры сount, file
	
Открываем настройку конфигурации запуска Run / Debug Configurations	
	
Вводим в поле Arguments	
10 src/test/resources/groups.csv	
	
	
	
В начале метода save посмотрим какая у нас текущая директория 

System.out.println(new File(".").getAbsolutePath());	

На этот раз рабочая директория проекта, а не модуля		
C:\Users\kobzev\Documents\GitHub\java_test\.
	
Когда запускаются тесты, то рабочей является директория модуля, а когда программы - директория проекта. 
	
Поменемся текущую директорию 
//рабочая директория и путь должны сойтись
//укажем что программа должна запускаться здесь 
C:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests 	
	
	
	
}	
Урок 61. Анализ опций командой строки при запуске генератора данных {

Как правильно работать с параметрами или опциями, которые передаются при запуске программы из командной строки. 

В случае наличия ошибки при запуске программы нужно, чтобы пользователь получал подробную информацию об исключении. Что именно он сделал не правильно, и что нужно сделать чтобы программа запустилась. Какие опции она поддерживает? В каком порядке следует их указывать.  
Все это программа должна сообщать, когда пользователь пытается вызвать ее с неправильными параметрами. 	

Реализуем это при помощи библиотеки, которая предназвачена для обработки опций командной строки
http:\\jcommander.org 


Подключаем библиотеку через http:\\search.maven.org

  
JC определяет список атрибутов в текущем классе, у каждого атрибута можно получить инфо о том, какие аннотации связаны с этим атрибутом, и дальше прочитать параметры аннотации.     

Ниже приведена простейша форма JC: 

Класс 
список атрибутов 
@Parameter (параметры аннотации ) //аннотация 
атрибут1; //числа, строки, списки но не файлы
@Parameter (параметры аннотации ) //аннотация 
атрибут2; 

Нам нужны опции коммандной строки count и file, которые сделаем атрибутами


@Parameter(names = "-c", description = "Group count") //дадим этим опциям имена и описание
public int coutn;

@Parameter(names = "-f", description = "Target file")
public String file; //тип String потому что библиотека jc напрямую работу с файлами не поддерживает

А теперь делаем так как написано в документации jc

Сначала создаем объект теущего класа, затем создаем объект типа 
JCommander (параметр1, параметр2)
где 
параметр1 - объект, в котором должны быть заполнены соответствующие атрибуты 
параметр2 - те опции, которые переданы коммандной строке 


Теперь запускаем generator.run()

Создадим run() и переместим туда 

  private void run() throws IOException {
	//1 часть генерация данных
    List<GroupData> groups = generatorGroups(count);
    //2 часть сохраненние данных в файл
    save(groups, new File(file)); //преобразуем, потому что теперь атрибут file имет другой тип String file;  

  }

А save() и generateGroups() можно убрать static, потому что все методы вызываются внутри объекта generator

Запускаем тест получаем исключение
Was passed main parameter '10' but no main parameter was defined in your arg class

Нужно добавить сообщение о том, как программу запускать правильно. 



  public static void main(String[] args) throws IOException {
    GroupDataGenerator generator = new GroupDataGenerator();
    JCommander jCommander = new JCommander(generator); //создаем объект и помещаем его в какую-то локальную переменную
    jCommander.parse(args); //помещаем в качестве параметра наши аргументы , но так как при этом может возникнуть исключение ParameterException перехватим его, завернем parse() в метод try() - catch ()
  }


  public static void main(String[] args) throws IOException { //запускаемый файл
    GroupDataGenerator generator = new GroupDataGenerator();
    JCommander jCommander = new JCommander(generator);
    try {
      jCommander.parse(args);
    } catch (ParameterException ex) {//перехватываем исключение
      jCommander.usage(); //если исключение возникло, то выводим на консоль инфо о доступных опциях при помощи метода usage()
      return; //метод генератор запускать не надо
    }
  }

Снова запускаем тест, получаем сообщение 

Usage: <main class> [options]
  Options:
    -c
      Group count
      Default: 0
    -f
      Target file

Переходим в конфигурацию теста и исправляем значение аргументов

-c 20 -f src/test/resources/groups.csv

Благодаря тому, что мы реализовали возможность указывать параметры строки с именами, значение аргументов можно указывать в другом порядке. 


	
}
Урок 62. Параметризация тестовых методов {
	
Как создать параметризованный тест в TestNG

Тестовые данные это свойство той группы,которую мы собираемся создавать (name, header, footer).

Если нужно выполнить тест многократно на разных тестовых данных, то можно сделать цикл 
	
@Test
  public void testGroupCreation() {
    String[] names = new String[]{"test1", "test2", "test3"}; //делаем массив строк, в котором перечисляем тестовые данные
    for (String name : names) { //устраиваем цикл и выполняем основное тело теста
	  GroupData group = new GroupData().withName(name); //вместо конкретного значения подставляем переменную, которая перебирает элементы массива  
	  app.goTo().groupPage();
      Groups before = app.group().all();
      app.group().create(group);
      Groups after = app.group().all();
      assertThat(after.size(), equalTo(before.size() + 1));
      assertThat(after, equalTo(before.withAdded(group.withId(after.stream().
              mapToInt((g) -> g.getId()).max().getAsInt()))));
    }
  }

1-й проблемный момент
Запустился тест, но что он делал, на каких тестовых данных выполнялся из отчета не видно. 
Хотелось бы отобразить то, что мы запускали тест 3 раза на разных тестовых данных.


2-й момент
Если хотя бы одни тестовые данные содержат не допустимый символ ('), то весь тест падает. Остальные тестовые данные вообще не использованы, несмотря на то что на них тест мог отработать корректно. В отчете не видно на каких тестовых данных, тест упал. 


Решим эти проблемы при помощи провайдера тестовых данных


Это специальный метод, который помечается аннотацией @DataProvider, возвращаемое значение, которого должно быть достаточно сложным  


  @DataProvider
  public Iterator<Object[]> validGroups(){ 	//название_интерфейса<тип_элемента>, где тип_элемента это массив каких-то объектов - итератор массива объектов
    List<Object[]> list = new ArrayList<Object[]>(); 	//название_интерфейса<тип_элемента> имя_переменной присваемое значение имя_класса<тип_элемента>, который реализует интерфейс - список массивов объектов
    list.add(new Object[] {"test1", "header 1", "footer 1"}); 	//заполняем список тестовыми данными 1й-набор тд //в список добавляем объект, который является массивом строк
    list.add(new Object[] {"test2", "header 2", "footer 2"}); 	
    list.add(new Object[] {"test3", "header 3", "footer 3"});		
    return list.iterator(); ////возвращает объект-итератор для обхода элементов этого списка
  }

Основная задача коллекций – хранить элементы, а итератора – выдавать эти элементы по одному

Итератор позволяет поочередно получить все элементы коллекции; обходить элементы составных объектов, не раскрывая их внутреннего представления.

А теперь этот провайдер тестовых данных нужно привязать к тесту.
Для этого нужно во первых у аннатации тест указать параметр  

@Test(dataProvider = "validGroups")

Во вторых у тестового метода нужно сделать столько параметров, сколько содержится в каждом массиве объектов. То есть у него должно быть три параметра типа String.

Теперь параметры в тестовый метод будут передаваться из вне. Поэтому цикл нужно убрать. Цикл фактически оказывается снаружи и этот цикл устраивает фрейворк TestNG.


@Test(dataProvider = "validGroups")
  public void testGroupCreation(String name, String header, String footer) { 
    GroupData group = new GroupData().withName(name).withHeader(header).withFooter(footer); //заполняем объект тестовыми данными
    app.goTo().groupPage();
    Groups before = app.group().all();
    app.group().create(group);
    Groups after = app.group().all();
    assertThat(after.size(), equalTo(before.size() + 1));
    assertThat(after, equalTo(before.withAdded(group.withId(after.stream().
            mapToInt((g) -> g.getId()).max().getAsInt()))));
  }


Запускаем тест, в отчете видим, что тест запускался три раза и указаны явно тестовые данные, которые использоватлись при каждом запуске. 


В провайдере данных 
@DataProvider
  public Iterator<Object[]> validGroups(){
    List<Object[]> list = new ArrayList<Object[]>(); //список массивов объектов
	//каждый массив содержит набор данных для одного запуска тестового метода
	//сколько будет наборов, столько раз запустится тестовый метод 
    list.add(new Object[] {"test1", "header 1", "footer 1"});  
    list.add(new Object[] {"test2", "header 2", "footer 2"}); 
    list.add(new Object[] {"test3", "header 3", "footer 3"});	
    return list.iterator(); //возвращается итератор этого списка. Тестовый фрейворк по очереди при помощи этого итератора из списка вытаскивает один набор параметров за другим и запускает тестовый метод несколько раз, помещает полученную информацию о результатах в отчет
  }

Но передавать тестовые данные в виде набора строк это не удобно. 
В самом начале от этого избавились и создали модельный класс, который внутри себя содержит эту информацию. Удобнее передавать данные как один объект типа GroupData 

public void testGroupCreation(String name, String header, String footer) 

public void testGroupCreation(GroupData group) 

В этом случае, провайдер будет передавать не массив строк а массив объектов типа GroupData. Правда этот массив будет состоять всего из одного единственного элемента, потому что у тестового метода один параметр.  

было

    list.add(new Object[]{"test1'", "header 1", "footer 1"}); //массив из 3 строк
 
стало 

    list.add(new Object[]{new GroupData().withName("test1'").withHeader("header 1").withFooter("footer 1")});//массив из одного объекта
 
Запускаем тест и видим, что теперь в отчете представлен один объект и его строковое представление формируется при помощи метода

GroudData > 
@Override
  public String toString() {
    return "GroupData{" +
            "id='" + id + '\'' +
            ", name='" + name + '\'' +
            '}';
  }


}	
Урок 63. Загрузка тестовых данных из файла {
	
Общая идея - разделение зон ответственности: тестовый сценарий отдельно от тестовых данных. 

Переделаем провайдер таким образом, чтобы он загружал тестовые данные из внешнего файла.


  @DataProvider
  public Iterator<Object[]> validGroups() throws FileNotFoundException { //добавим это исключение в декларацию метода 
  //если не найден, то пусть тесты падают  
    List<Object[]> list = new ArrayList<Object[]>();
    Reader reader = new FileReader(new File("src/test/resources.groups.csv")); //здесь может возникать исключение
    //класс FileReader создает объект типа Reader, который можно использовать для чтения содержимого файла
	//java понимает \/ к путям к файлам
    return list.iterator();
  }


	

read() возвращается int читает из файла один символ, возвращает его код
read(char[] cbuf) int возвращает набор символов. Для этого сначала нужно создать массив символов, элементов типа char. И какая длина у  массива, столько символов будет прочитано. Нужно прочитать строчку целиком, такого метода в классе Reader нет. 

В классе BufferedReader есть readLine(), который читает из потока построчно и возвращает целую строчку. 
Поэтому сделаем обертку: меняем тип объекта на BufferedReader, и обычный FileReader заворачиваем в new BufferedReader.


BufferedReader reader = new BufferedReader(new FileReader(new File("src/test/resources.groups.csv")));
String line = reader.readLine(); //здесь тоже может возникнуть исключение, которое мы тоже добавляем в декларацию     
//FileNotFoundException заменяется на IOException, которое является более общим видом исключения



	//таким образом можно прочитать только первую строчку
  @DataProvider
  public Iterator<Object[]> validGroups() throws IOException {
    List<Object[]> list = new ArrayList<Object[]>();
    BufferedReader reader = new BufferedReader(new FileReader(new File("src/test/resources.groups.csv")));
    String line = reader.readLine();
    return list.iterator();
  }	
	
	
  @DataProvider
  ...
    String line = reader.readLine();
    //неизвестно сколько строк в файле, поэтому используем цикл while
    while (line != null) {
      line = reader.readLine(); //продолжаем выполнение этого цикла, на каждой следующей итерации выполняется выражение - читать следующую строчку из тогоже самого файла
    }//когда все строки кончатся, вместо очередной строки вернется значение null и выполнение цикла прекратится

	
	
В итоге получаем,	
	
  @DataProvider
  public Iterator<Object[]> validGroups() throws IOException {
    List<Object[]> list = new ArrayList<Object[]>();
    BufferedReader reader = new BufferedReader(new FileReader(new File("src/test/resources.groups.csv")));
    //чтение построчно
    String line = reader.readLine();
    //неизвестно сколько строк в файле, поэтому используем цикл while
    while (line != null) {
      String[] split = line.split(";");//выполнение обработки прочитанных строк
      //строим из полученных кусочков объект, который помещаем в массив
      //массив состоит из одного этого объекта(элемента). Добавляем массив в список
      list.add(new Object[]{new GroupData().withName(split[0]).withHeader(split[1]).withFooter(split[2])});
      line = reader.readLine(); //выполнение этого цикла, на каждой следующей итерации выполняется выражение - читать следующую строчку из тогоже самого файла
    }//когда все строки кончатся, вместо очередной строки вернется значение null и выполнение цикла прекратится
    return list.iterator();
  }	
	
	
	
}	
Урок 64. Формат XML {
	
Задача: необходимо набор объектов тестовых данных сохранить в формате xml. Для этого будем использовать особую разновидность библиотек  для работы с форматом xml, которые называются сериализатор данных. 
Они предназначены для того, чтобы автоматически преобразовать какие то объекты языка программирования в формат xml и наоборот, анализировать данные в формате xml и автоматически строить объекты нужного типа.

Подключим библиотеку Xstream

https://search.maven.org/artifact/com.thoughtworks.xstream/xstream/1.4.11.1/jar
	

Недостатки формата csv:
- структура нарушается формата, если поля состоят из нескольких строк
- структура формата нарушается, если поле содержит ;
- большое количество полей

Переделаем гененатор

public class GroupDataGenerator { //генерирует инфо о группах


  @Parameter(names = "-c", description = "Group count")
  public int count;

  @Parameter(names = "-f", description = "Target file")
  public String file; //тип String потому что библиотека jc напрямую работу с файлами не поддерживает


  public static void main(String[] args) throws IOException { //запускаемый файл
    GroupDataGenerator generator = new GroupDataGenerator();
    JCommander jCommander = new JCommander(generator);
    try {//заворачиваем в метод try
      jCommander.parse(args);
    } catch (ParameterException ex) {//перехватываем исключение
      jCommander.usage(); //если исключение возникло, то выводим на консоль инфо о доступных опциях при помощи метода usage()
      return; //метод генератор запускать не надо
    }
    generator.run();
  }

  private void run() throws IOException {
	//1 часть генерация данных
    List<GroupData> groups = generatorGroups(count);
    //2 часть сохраненние данных в файл
    save(groups, new File(file)); //преобразуем

  }


  private List<GroupData> generatorGroups(int count) {
    List<GroupData> groups = new ArrayList<GroupData>();
    for (int i = 0; i < count; i++) {
      groups.add(new GroupData().withName(String.format("test %s", i))
              .withHeader(String.format("header %s", i))
              .withFooter(String.format("footer %s", i)));
    }
    return groups;
  }

  private void save(List<GroupData> groups, File file) throws IOException {
    //открываем файл на запись
    System.out.println(new File(".").getAbsolutePath());
    Writer writer = new FileWriter(file);
    for (GroupData group : groups) {
      writer.write(String.format("%s;%s;%s\n", group.getName(), group.getHeader(), group.getFooter()));
    }
    //закрываем файл
    writer.close();
  }


}

Сделаем дополнительный параметр - опцию командной строки
  @Parameter(names = "-d", description = "Data format")
  public String format;

Теперь при запуске нужно указывать третий параметр Edit Configuration
-f src/test/resouces/groups.xml -c 3 -d xml


Нужно добавить проверку в run()


   private void run() throws IOException {
    List<GroupData> groups = generatorGroups(count);
    if (format.equals("csv")) { //свернутая конструкция if, где идет серия однотипных проверок
      saveCsv(groups, new File(file));
    } else if (format.equals("xml")) {
      saveXml(groups, new File(file));
    } else { //в конце нужно сообщить пользователю, если он указан нераспознаваемый формат
      System.out.println("Unrecognized" + format);
    }
  }

Создаем saveXml()

  private void saveXml(List<GroupData> groups, File file) { //(список групп, который нужно сохранить, файл, в который нужно сохранить)
  
  }

Смотрим как надо работать с библиотекой http://x-stream.github.io/tutorial.html


Создаем объект типа xstream

XStream xstream = new XStream();

Now, to convert it to XML, all you have to do is make a simple call to XStream:

String xml = xstream.toXML(groups); //в качестве параметра передаем тот объект, который нужно сериализовать 
//то есть превратить их объектного представления в строчку в формате xml

Делаем writer, который может выбрасывать исключение. Поэтому добавляем эту инфо в декларацию метода.

  private void saveXml(List<GroupData> groups, File file) throws IOException {
    XStream xstream = new XStream();
    String xml = xstream.toXML(groups);
    Writer writer = new FileWriter(file);
    writer.write(xml);
    writer.close();
  }


Запускаем и получаем новый файл, в котором 

<list> //список объектов
  <ru.testjava.addressbook.model.GroupData> //представлен объект, внутри которого перечисляются его свойства (атрибуты) //переименуем этот тег для удобства чтения
    <id>2147483647</id>
    <name>test 0</name>
    <header>header 0</header>
    <footer>footer 0</footer>
  </ru.testjava.addressbook.model.GroupData>


Переименование тега

Способ 1
Для этого настроим созданный объект xstream 

private void saveAsXml(List<GroupData> groups, File file) throws IOException {
    XStream xstream = new XStream();
    xstream.alias("group", GroupData.class); //указываем какой тег используется для сохранения определенных типов данных
    String xml = xstream.toXML(groups);
    Writer writer = new FileWriter(file);
    writer.write(xml);
    writer.close();
  }

Получим, 

<list>
  <group>
    <id>2147483647</id>
    <name>test 0</name>
    <header>header 0</header>
    <footer>footer 0</footer>
  </group>

Способ 2 
Настроим у самого класса GroupData

Надо в самом начале добавить

@XStreamAlias("group")
public class GroupData {

и настроить 

private void saveAsXml(List<GroupData> groups, File file) throws IOException {
    XStream xstream = new XStream();
    xstream.processAnnotations(GroupData.class); //для класса GroupData нужно прочитать подсказки, которые в нем самом написаны
    String xml = xstream.toXML(groups);
    Writer writer = new FileWriter(file);
    writer.write(xml);
    writer.close();
  }

  
В файле остались лишнии строчки с тегом <id></id>, потому что id у нас одно и тоже = макс целому числу 
  
@XStreamAlias("group")
public class GroupData {
  @XStreamOmitField
  private int id = Integer.MAX_VALUE;  //пропустить это поле, не сохранять его в формате xml 
  
  Так как мы ранее уже написали, 
  xstream.processAnnotations(GroupData.class);
  
  xstream должен обработать аннатацию в этом классе, никаких доп действий делать не нужно   
  
Запускаем, получаем

<list>
  <group>
    <name>test 0</name>
    <header>header 0</header>
    <footer>footer 0</footer>
  </group> 
  
  
Таким образом, с помощью аннотаций можно управлять тем, как именно сохраняются данные типа GroupData в формате xml

---

Меняем провайдер, чтобы он читал данные в формате xml 

Как прочитать данные  
  
Person newJoe = (Person)xstream.fromXML(xml); // в качестве параметра можно передать строку
   
Поэтому сначала нужно прочитать все содержимое файла, и только после этого мы сможем использовать библиотеку xstream   




@DataProvider
  public Iterator<Object[]> validGroups() throws IOException {

    //чтение данных
    String xml = "";
    BufferedReader reader = new BufferedReader(new FileReader(new File("src\\test\\resources\\groups.xml")));
    //чтение построчно
    String line = reader.readLine();
	
	//чтение всего содержимого файла в переменную типа String, чтобы сработал fromXML()
    while (line != null) {
      xml += line; //добавляем к переменной строчки
      line = reader.readLine();
    }
	
	//инициализируем объект типа экстрим
    XStream xstream = new XStream();
    //с помощью объекта вызвали метод для чтения нашей строчки xstream.fromXML(xml)
	//метод возвращает объект непонятного типа, но мы точно знаем, что это список контактов (см файл)
	//поэтому нужно явно привести объект к типу List<ContactData>

    //xstream должен обработать аннотации
    xstream.processAnnotations(GroupData.class);
    //xstream должен прочитать данные типа (List<GroupData>) из файла xml
    List<GroupData> groups = (List<GroupData>)xstream.fromXML(xml);
    

    //метод iterator() возвращает объект-итератор, то есть должен возвращать объект типа ContactData с атрибутами
	//надо каждый объект завернуть в массив, так как тип интерфейса массив объектов
	//для этого преобразуем список в поток, каждый элемент потока (объект) обернем в массив
	//поток преобразуем обратно в список
	//у списка берем итератор и возвращаем итератор 
    //(List<GroupData>) явное преобразование типа, потому что fromXML() возвращает объект какого то неизвестного типа
    //но точно известно что это список групп, поэтому можно сделать такое приведение типа
    return groups.stream().map((g) -> new Object[] {g}).collect(Collectors.toList()).iterator();
            //к каждому объекту нужно применить аннонимную функцию, которая этот объект типа GroupData завернет в массив, который состоит из одного этого объекта - так хочет фрейворк TestNG
            //collect() должен собрать из потока собрать обратно список
            //iterator() у получившегося списка берем итератор его и нужно возвращать

  }



}}
}	
Урок 65. Формат JSON {

Задача:  сериализовать набор объектов в текстовый вид и сохранить в файл формата json, потом прочитать этот файл и обратно восстановить структуру объектов  

Подключим библиотеку gson 
https://github.com/google/gson
https://github.com/google/gson/blob/master/UserGuide.md#TOC-Object-Examples

Доработаем генератор 

	//добавим новый метод для сериализации объекта 
  private void saveAsJson(List<GroupData> groups, File file) throws IOException {
    //создадим объект типа Gson
    Gson gson = new Gson();
    //вызовим метод, который сериализует объект
    //результатом его работы будет срочка
    String json = gson.toJson(groups);
    Writer writer = new FileWriter(file);
    writer.write(json);
    writer.close();
  }


Меняем настройки запуска генератора 

-c 3 -f src/test/resources/groups.json -d json

Запускаем программу, получаем файл, который плохо отформатирован. 

Настроим генератор, чтобы результат выглядел красиво 

вместо 

Gson gson = new Gson();

сделаем

Gson gson = new GsonBuilder().setPrettyPrinting().create();

//используется флуент интерфейс и шаблон проектирования билдер
//только здесь используется отдельный вспомогательный класс в качестве построителя объекта типа json 

Запускаем снова, теперь файл отформатирован

Как избавится от лишних полей с id

Нужно в классе GroupData указать аннотацию @Expose для тех полей, которые должны быть сериализовы.


Получаем, 


public class GroupData {
  @XStreamOmitField
  private int id = Integer.MAX_VALUE;
  @Expose
  private String name;
  @Expose
  private String header;
  @Expose
  private String footer;

}
 Еще нужно при построении объекта, указать настройку, которая означает, что он должен пропускать все поля, которые не помечены аннотацией @Expose

 Gson gson = new GsonBuilder().setPrettyPrinting().excludeFieldsWithoutExposeAnnotation().create();
    

Запускаем генератор, получаем файл без id

---

Как загружать файлы в JSON


Клонируем существующий DataProvider

Нужно прочитать все содержимаое файла в строчку и потом ее обрабатывать


Gson gson = new Gson();
//в качестве параметра указываем (строка, тип_данных, которые должны быть сериализованы)
gson.fromJson(json, List<GroupData>.class); //такой тип данных указать нельзя 
Если нам нужно десиреализовать один объект, то можно написать
gson.fromJson(json, GroupData.class);
Но когда есть джинерики <>, которые указывают на тип данных в коллекции, то простой способ не работает. 

Поэтому нужно сделать 

gson.fromJson(json, new TypeToken<List<GroupData>>() {}.getType()); // List<GroupData>.class

 

  @DataProvider
  public Iterator<Object[]> validGroupsFromJson() throws IOException {
    String json = "";
    BufferedReader reader = new BufferedReader(new FileReader(new File("src\\test\\resources\\groups.json")));
    String line = reader.readLine();

    while (line != null) {
      json += line;
      line = reader.readLine();
    }
    Gson gson = new Gson();
    List<GroupData> groups = gson.fromJson(json, new TypeToken<List<GroupData>>() {}.getType());
    return groups.stream().map((g) -> new Object[] {g}).collect(Collectors.toList()).iterator();
  }


}
Урок 66. Автоматическое закрытие файлов после использования {

Когда пишутся данные в файл, они не сразу сохраняются на диск, а сначала накапливаются в кэше (оперативной памяти). Если программа завершится в тот момент, когда кеш еще не сохранился на диск, то эти данные могут быть потерены. 

Особенно важно закрыть writer, потому что есть риск потери данных. 
Если не закрыть reader, то ничего страшного, все равно прочитали из него все что нужно. Самый большой риск - исчерпания количества открытых файлов.

Как не забыть закрыть файл

Использовать конструкцию, которая автоматически закрывает файл
try (инициализация writer/ ресурса) {использование writer /ресурса} 


Пример, 

  private void saveAsJson(List<GroupData> groups, File file) throws IOException {
    Gson gson = new GsonBuilder().setPrettyPrinting().excludeFieldsWithoutExposeAnnotation().create();
    String json = gson.toJson(groups);
    try (Writer writer = new FileWriter(file)) {
      writer.write(json);
    }
  }

Теперь ресурсы расходуются экономно.



}
Урок 67. Конфигурационные файлы для описания тестовых наборов {

С увеличением количества тестов, возникает потребность выделить тесты в группы и запускать их по отдельности.
Эти группы называют тестовыми наборами, Suite

TesnNG предлагает для описания таких тестовых наборов использовать конфигурационные файлы.

Создадим в каталоге resurces конфигурационный файл, который описывает все тесты.  

Заготовку возьмем из документации
http://testng.org/doc/documentation-main.html

<!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" >

<suite name="Suite1" verbose="1" >
    <test name="Groups" >
        <classes>
            <class name="ru.testjava.addressbook.tests.GroupCreationTests" />
            <class name="ru.testjava.addressbook.tests.GroupModificationTests" />
            <class name="ru.testjava.addressbook.tests.GroupDeletionTests" />
        </classes>
    </test>

    <test name="Contacts">
        <classes>
            <class name="ru.testjava.addressbook.tests.ContactCreationTests" />
            <class name="ru.testjava.addressbook.tests.ContactModificationTests" />
            <class name="ru.testjava.addressbook.tests.ContactDetailsTests" />
            <class name="ru.testjava.addressbook.tests.ContactDeletionTests" />
        </classes>
    </test>
</suite>



Suite всегда один, тестов внутри него может быть несколько. 
Каждый тест может состоять из нескольких классов, и они в свою очередь включают какое то количество методов. 
И для каждой сущности есть аннотация @BeforeSuite, @BeforeClass, @BeforeMethod и аннотация @AfterSuite, @AfterClass, @AfterMethod. 
Отчет также будет сконструирован в соответствии с этим описанием.    

Название классов должны быть указаны полностью, вместе с пакетом.  

Тесты будут выполняться в указанной последовательности сверху вниз. Но это не означает, что между ними будут какие то зависимости.
Упорядочивание позволяет оптимизировать выполнение тестов. Например, чтобы минимизировать расходы на выполнение предусловий в тестах для модификации и удаления. Если в начале группы насоздаются, то потом они же будут модифицироваться и удаляться. 

Запускаем конфиг файл из среды разработки
При этом порядок выполнения тестов, то есть элементов верхнего уровня, неопределен. А порядок выполнения классов внутри каждого теста, в соответствии с указанной последовательностью.


Запускаем конфиг файл из консоли  

gradlew test //тесты запускаются командой 

C:\Users\Admin\Documents\GitHub\java_test\addressbook-web-tests>gradlew test

Но он ничего не нашел. Потому что по уполчанию gradle пытается найти и запустить тесты, созданные с использованием фрейворка JUnit.
У нас используется TestNG поэтому необходимо в конфигурационном файле build.gradle написать:

test {
	useTestNG()
}

Запускаем , теперь гредл нашел и запустил все тесты 
gradlew test
Чтобы запускались только те, которые нам нужны и в определенном порядке. 
Поэтому надо указать конфиг файл, где описан тестовый набор 

test {
	useTestNG() {
		suites 'src/test/resources.testng.xml'
	}
}

Запускаем gradlew test
Если он отказался выполнять тесты, то выполним команду 
gradlew cleanTest test 


Теперь разобьем конфиг файл на два части - группы и контакты отдельно

В конфиг файла build.gradle можно указать два тестовых набора одновременно, но мы хотим выбирать 

Для этого надо описать альтернативную задачу, которая выглядит по другому

task testGroups(type: Test) {
	useTestNG() {
		suites 'src/test/resources.testng-groups.xml'
	}
}

task testContacts(type: Test) {
	useTestNG() {
		suites 'src/test/resources.testng-contacts.xml'
	}
}

Конфиг файл для gradle это тоже программа, написанная на языка Groove



}
Урок 68. Описание конфигурации тестового стенда {

Рассмотрим формат "файлы свойств", которые используются для создания конфигурационных файлов. Они поддерживаются стандартной библиотекой java.

Будем использовать файлы в таком формате, чтобы хранить там данные о тестируемой системе (url, логин, пароль). Сейчас это указанно непосредтсвенно в коде, при инициализации ApplicationManager. В коде менять неудобно. 
Хотелось бы иметь конфигурационные файлы, которые описывают характеристики этих разных сред и при запуске определять какой конфигурационный файл использовать.

Задача: как в командной строке передать какие нибудь параметры, например информацию о том какой браузер использовать.

Для этого можно использовать системные свойства (system properties). //не имеют никакого отношения к файлам свойств

В классе TestBase , там где явно указан браузер хром напишем  
 //взять значение системного свойства браузер
  protected static final ApplicationManager app = new ApplicationManager(System.getProperty("browser");

Для того, чтобы передать значение этого системного свойства, в настройках конфигурации запуска теста (создания контаков) Edit Configurations, нужно в поле VM options написать

-ea -Dbrowser=firefox

Запускаем тест, вместо chrome стартует firefox

Если firefox не указать, то все падает. Потому что в init() возникает NullPointerException, так как переменная не определена.
Чтобы этой проблемы избежать, нужно установить какое то дефолтное значение, которое будет использоваться в том случае если системное свойство при запуске не указано. 

protected static final ApplicationManager app = new ApplicationManager(System.getProperty("browser", BrowserType.CHROME); //это удобнее всего сделать здесь, System.getProperty() принимает второй необязательный параметр, которое указывает дефолтное значение для этого свойства

Итак, мы научились передавать это системное свойство при запуске тестов из среды разработки.
Теперь надо научиться это делать при запуске из консоли. 

Для этого в файл build.gradle нужно дописать


task testContacts(type: Test) {
    useTestNG() {
        suites 'src/test/resources.testng-contacts.xml'
    }
    systemProperty 'browser', "${browser}" // где ${название_свойства_сборщика},   'browser'- устанавливается системное свойство с таким же именем для запускаемых тестов 
    //на языке Groovy, на котором пишется конфиг файл, в '' подстановки переменных не выполняется, а в "" выполняется 
}


При запуске тестов (любых задач) при помощи сборщика gradle можно передать ему свойства при помощи опции -P. Это его собственное свойство. Нужно теперь его свойство преобразовать в обычное системное свойство для запускаемой java VA (VirtualMachine), которая будет выполнять тесты. 

Запускаем тесты. В консоли указываем 

gradlew -Pbrowser=firefox testContacts

Если это свойство не указать, то тест упадет

gradlew testContacts


Добавим проверку условия в build.gradle

task testContacts(type: Test) {
    useTestNG() {
        suites 'src/test/resources.testng-contacts.xml'
    }
    if (project.hasProperty('browser')) {//где project тот проект , который мы сейчас собираем
    	systemProperty 'browser', "${browser}" //устанавливать системное свойство браузер для запускаемой VA. 
    } //а иначе делать ничего не надо, будет использоваться дефолтное значение, которое определено в TestBase при инициализации AM
    
}

Передадим другое свойство -Ptarget будет указываеть имя, название конфигурационного файла в котором хранится информация о тестируемой системе.

gradlew -Ptarget=local testContacts // если указано такое свойство, то инфо о ТС должна быть загружена из файла resources/local.properties

--rerun-tasks //добавляем опцию для перезапуска, в случае если gradle не запускает тесты а обновляет 

Пробрасываем это системное свойство через сборщик в запускаемую VA  


task testContacts(type: Test) {
    useTestNG() {
        suites 'src/test/resources.testng-contacts.xml'
    }
    if (project.hasProperty('browser')) {
        systemProperty 'browser', "${browser}"        
    }

    if (project.hasProperty('target')) {
        systemProperty 'target', "${target}"
    }
}


Теперь нужно это свойство где то использовать, очевидно в АМ. Добавим инициализацию свойства в конструктор.

public ApplicationManager(String browser) {

    this.browser = browser;
    properties = new Properties();//создаем объект типа properties и сохраняем его в поле этого класса, потому что он пригодится в будущем
  }

Добавим остальную реализацию в метод инит 

public void init() throws IOException {
    String target = System.getProperty("target", "local"); //часть имени конфигурационного файла
    properties.load(new FileReader(new File(String.format("src/test/java/resources.%s.properties"), target)));//в load в качестве параметра передаем Reader

    //после того , как свойства загружены - можно их использовать
    if (browser.equals(BrowserType.CHROME)) {
      driver = new ChromeDriver();
    } else if (browser.equals(BrowserType.FIREFOX)) {
      driver = new FirefoxDriver();
    } else if (browser == BrowserType.IE) {
      driver = new InternetExplorerDriver();
    }
  String target = System.getProperty("target", "local"); //часть имени конфигурационного файла
   
	
добавляем оба исключения в декларацию метода 

После того , как свойства загружены - можно их использовать

Убираем конкретные значения, вместо этого будут использоваться свойства загруженные из конфигурационного файла 
вместо 
driver.get("http://localhost/addressbook");
sessionHelper.login("admin", "secret");

напишем 
driver.get(properties.getProperty("web.baseUrl"));
sessionHelper.login(properties.getProperty("web.adminLogin"), properties.getProperty("web.adminPassword"));
  
Создадим конфигурационный файл local.properties

web.baseUrl=http://localhost/addressbook
web.adminLogin=admin
web.adminPassword=secret

Тем самым мы получаем возможность создавать разные конфигурационные файлы и при запуске указывать какой именно из них хотим использовать. 

Теперь при запуске тестов мы можем указывать где они должны работать, в каком бразуре, какой тестовый набор использовать. И все это является независимыми настройками, запуск тестов становится гибким.  


Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.



}
Урок 69. Протоколирование (лог-файлы) {


Вместо того, чтобы выводить на консоль нужно использовать специальные бибилиотеки, которые предназначены для протоколирования.
Они позволят перенаправить сообщения не только на консоль, но и в файл или вложить в бд.

Смотрим докуменатнацию
https://logback.qos.ch/manual/configuration.html

Подключаем библиотеку
https://search.maven.org/artifact/ch.qos.logback/logback-classic/1.3.0-alpha4/jar

Задача: в тесте для создания групп, в начале теста нужно выводить сообщение о запуске тест с некоторыми параметрами.


Для этого сначала создадим специальную переменную типа Logger
Классов с таким названием великое множество, потому что каждая библиотека так или иначе реализует протоколирование. 
Нужно взять тот класс, который находится в пакете org.slf4j (simple logging fasad for java)
Создавать объект будем при помощи LoggerFactory, который тоже находится в том же самом пакете.
При создании логгера указывается класс с которым этот логгер будет ассоциирован. Смысл ассоциации в том, в сообщениях будет видно название этого класса.


public void testGroupCreation(GroupData group) {
    Logger logger = LoggerFactory.getLogger(GroupCreationTests.class);   
	logger.info("Start testGroupCreation"); //используем его 

	//в конец добавляем
	logger.info("Stop testGroupCreation");


Запускаем тест, получаем

21:04:09.326 [main] INFO ru.testjava.addressbook.tests.GroupCreationTests - Start testGroupCreation
21:04:12.475 [main] INFO ru.testjava.addressbook.tests.GroupCreationTests - Stop testGroupCreation

Точное время сообщения /поток, из которого сообщение отправлено / уровень сообщения / название класса, с которым ассоциирован логгер

Уровни: ingo, debug, error, warn, trace

Через конфигурационный файл можно управлять какие сообщения выводятся какие нет. Кроме того, в нем можно настроить куда эти сообщения должны идти. Удобно сохранять результаты теста в файле. 

Настроим систему протоколлирования, чтобы она сохраняла в файл.

Создаем файл logback.xml в каталоге resources. Он должен называться именно так, потому что файл с таким названием будет искать библиотека logback чтобы прочитать конфигурацию.

//настройки по умолчанию 
//если нет никакого конфиг файла, будет использоваться этот 


  <configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n</pattern>
        </encoder>
    </appender>

    //добавляем блок о сохранении файла 
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>testFile.log</file>
        <append>true</append> //настройка означает, что новые данные при следующем запуске тестов будут дописываться в конец файла 
        //если настройку убрать то тогда, при каждом следующем запуске, файл будет создаваться заново и потерется информация о предыдущих запусках 

        <!-- set immediateFlush to false for much higher logging throughput -->
        <immediateFlush>true</immediateFlush>
        <!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg%n</pattern>
        </encoder>
    </appender>
    

  <root level="debug">
    <appender-ref ref="FILE" /> //добавляем информацию о необходимости сохранять в файл
    <appender-ref ref="STDOUT" />
  </root>
</configuration>

Хотелось бы чтобы при каждом запуске создавался отдельный файл с новым именем. 

Сначала надо создать timestamp, то есть переменную которая будет содержать текущее время 

 <timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/>

Теперь в имени файла можно использовать эту переменную


было 

 <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>testFile.log</file>

стало


 <timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/>
 <appender name="FILE" class="ch.qos.logback.core.FileAppender">
		<file>test-${bySecond}.log</file>

Запускаем тест, получаем новый файл, который содержит информацию о запуску тестов

В файле время выполнения представлено от начала, так как абсолютное время запуска теста указано в названии.

%-4relative //относительное время
%d{HH:mm:ss.SSS} //абсолютное время 



Но засорять тестами, строчками logger.info() идея так себе. 
Лучше сделать в классе TestBase сделать отдельные методы и выводить сообщения там 

@BeforeMethod //метод будет выполняться перед каждым тестовым методом
public void logTestStart () {

}


@AfterMethod (alwaysRun = true) //указать опцию, чтобы метод всегда выполнялся, даже если тест завершился неуспешно
public void logTestStop() {

}

Перенесем туда протоколирования, но для этого нужно узнать название метода который запускается.

В метод, который помечен аннотацией Before / AfterMethod можно передать параметр тип Method (из пакета java.lang.reflect). Он будет содержать информацию, о методе который сейчас запускается

Переносим logger в базовый класс, привязываем к классу TestBace чтобы было видно откуда сообщение выводится 

public class TestBase {
  Logger logger = LoggerFactory.getLogger(TestBase.class);

Переносим строчки log.info в методы 


  @BeforeMethod(alwaysRun = true)
  public void logTestStart(Method m) {
    logger.info("Start test" + m.getName());


  }

  @AfterMethod(alwaysRun = true)
  public void logTestStop (Method m) {
    logger.info("Stop test" + m.getName());

  }

Запускаем тест, получаем

5429 [main] INFO  r.t.addressbook.tests.TestBase - Start testtestGroupCreation 
10841 [main] INFO  r.t.addressbook.tests.TestBase - Stop testtestGroupCreation 

Можно дополнить лог информацией о параметрах тестовых методов 

Для этого нужно объявить еще один параметр типа Object[], который будет содержать параметры тестового метода. И добавить эту информацию в протокол.  

  @BeforeMethod(alwaysRun = true, Object[] p)
  public void logTestStart(Method m) {
    logger.info("Start test" + m.getName() + "with parameters " + p); //но выводить в таком виде не удобно, потому что у массива объектов нет метода toString()
    //нужно преобразовать в список Arrays.asList(p)

 

  }


}


Занятие 7. Работа с базами данных
Урок 70. Драйвер базы данных. Получение данных из БД {

Как работать с базами данных. Начнем с технологии Java Database Connectivity (JDBC)

Получать информацию о группах и контактах можно не только через веб интерфейс , но и напрямую обращаясь к бд. 

Для веб интерфейся мы использовали специальную библиотеку - драйвер, которая позволяет управлять браузером. 
Для взаимодействия с бд нам тоже понадобится драйвер, но другого типа. Для каждого сервера управления бд существует свой драйвер. В нашем случае используется сервер MySQL, драйвер используется MySQL Connector/j

Подлючаем библиотеку (драйвер) mysql:mysql-connector-java:8.0.15

Чтобы убедится что мы может взаимодействовать с бд, создадим вспомогательный тест

//тест, который проверяет что можно установить соединие и извлечь информацию из бд

package ru.testjava.addressbook.tests;
public class DbConnectionTest {
  @Test
  public void testDbConnection() {

    
  }
}


 
Как установить соединие с бд
https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-usagenotes-connect-drivermanager.html

com.mysql.jdbc.Driver //информация о классе, который содержит драйвер

 
Для установки соединения используется DriverManager, который находится в пакете java.sql.DriverManager и входит в стандартную библиотеку java. DriverManager по адресу базы данных, который передается в метод getConnection, догадывается какой именно драйвер должен использоваться для установления соединения с бд автоматически. Главное чтобы был правильно указан адрес бд.

Копирум весь врагмент, вставляем внутрь теста 
 
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

Connection conn = null;
...
try {
    conn = DriverManager.getConnection("jdbc:mysql://localhost/test?user=minty&password=greatsqldb"); 
  

    // Do something with the Connection

   ...
} catch (SQLException ex) {
    // handle any errors
    System.out.println("SQLException: " + ex.getMessage());
    System.out.println("SQLState: " + ex.getSQLState());
    System.out.println("VendorError: " + ex.getErrorCode());
}

Теперь нужно указать правильный адрес бд


"jdbc:mysql://localhost:3306/addressbook?user=root&password="  


"jdbc" протокол 

"mysql" тип базы даных 

"//localhost" адресс

"3306" порт указывать необязательно, если используется стандартный порт, драйвер сам догадается  

"/addressbook" название базы данных 

"root" имя пользователя 

" пароль пустой

Пробуем запустить код, если не упадет значит соединение успешно установилось

 
Следующий шаг, пытаемся извлечь из бд какую то информацию  

public class DbConnectionTest {


@Test
public void testDbConnection() { 
	//копируем и вставляем блок кода из документации 
  Connection conn = null;
  try {
	conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/addressbook?user=root&password=");
	//создадим объект
	Statement st = conn.createStatement();

	//c помощью этого объекта, вызовим метод, в который в качестве параметра передадим SQL запрос к бд
	st.executeQuery("select group_id, group_name, group_header, group_footer  from group_list ");


Чтобы узнать названия полей и таблиц, нужно заглянуть в структуру бд с помощью инструмента phpmyadmin

http://localhost/phpmyadmin/db_structure.php?server=1&db=addressbook

Поместим результат запроса в переменную с помощью среды разработки. Тип переменной будет ResultSet это некий аналог коллекции, по сути является наобором строк, которые извлекаются из таблицы. 

ResultSet rs = st.executeQuery("select group_id, group_name, group_header, group_footer  from group_list ");
        

Но это не обычный список / коллекция, поэтому напрямую использовать цикл for, который пробегается по элементам коллекции, здесь не удается.    

Вместо этого нужно сделать цикл while
 
	//пока есть еще какие то элементы, в этом множестве результатов, можно с ними выполнять какие то действия
	//когда функция next вернет false, т.е все множество результатов исчерпалось - цикл заканчивается
	while (rs.next()) {
	  //создадим объект и заполним его атрибуты теми данными, которые извлечены из бд
	  //в качестве параметра getInt указываем название столбца
	new GroupData().withId(rs.getInt("group_id"));

Мы обращаемся напряму к объекту rs типа ResultSet и извлекаем int вместо того, чтобы извлечь отдельную строчку и работать с этой строкой.  
Но так сложилось, что это древний интерфейс. 
Считается что, в каждый момент времени переменная rs указывает на некую строку (как бы курсор, который движется по строчкам таблицы). 
И вызов метода next() сдвигает курсор на следующую строку. То есть ResultSet это как бы с одной стороны вся таблица,а с другой в каждый момент времени этот объект указывает на одну единственную строчку в этой таблицы.
И когда мы извлекаем данные, то мы их извлекаем из текущей строки который указывает этот курсор             
Поэтому метод getInt() берет из текущей строки значение, которое хранится в столбце group_id и возвращает его как целое число.  

package ru.testjava.addressbook.tests;

import org.testng.annotations.Test;
import ru.testjava.addressbook.model.GroupData;
import ru.testjava.addressbook.model.Groups;
import java.sql.*;

public class DbConnectionTest {


  @Test
  public void testDbConnection() { 
      Connection conn = null;
      try {
        conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/addressbook?user=root&password=");
        //создадим объект
        Statement st = conn.createStatement();

        //вызовим метод, в который в качестве параметра передадим SQL запрос к бд
		//получаем данные в виде своеобразной таблицы 
        ResultSet rs = st.executeQuery("select group_id, group_name, group_header, group_footer  from group_list ");

        Groups groups = new Groups(); //добавим в него созданные объекты, чтобы после завершения цикла получить полную коллекцию объетов

        //пока есть еще какие то элементы, в этом множестве результатов, можно с ними выполнять какие то действия
        //когда функция next вернет false, т.е все множество результатов исчерпалось - цикл заканчивается
        while (rs.next()) {
		  //преобразуем полученные данные из таблицы в объект GroupData 			
          //создадим объект и заполним его атрибуты теми данными, которые извлечены из бд
          //в качестве параметра getInt указываем название !столбца!
        groups.add(new GroupData().withId(rs.getInt("group_id"))
                .withName(rs.getString("group_name"))
                .withFooter(rs.getString("group_footer"))
                .withHeader(rs.getString("group_footer")));
        }
        //чтобы не было потери ресурсов, нужно соединение с бд закрывать
        //ресурсы после использования надо освобождать
        rs.close(); //означает, что мы больше не собираемся из него читать никакие данные и можно освободить память
        st.close(); //означает, что мы больше не собираеимся выполнять никакие запросы
        conn.close(); //закрываем соединение с бд
        //теперь можно вывести на консоль ту инфо, которую мы извлекли
        System.out.println(groups);

      } catch (SQLException ex) {
        // handle any errors
        System.out.println("SQLException: " + ex.getMessage());
        System.out.println("SQLState: " + ex.getSQLState());
        System.out.println("VendorError: " + ex.getErrorCode());
      }

    }
}

  
Запускаем тест, получаем результат 
[GroupData{id='1', name='test 0'}, GroupData{id='2', name='test 1'}, GroupData{id='3', name='test 2'}]



	
}
Урок 71. Object Relational Mapping (ORM) {
	
Объекто-реляционные преобразователи - инструменты, которые позволяют с помощью специальный библиотек автоматически (при помощи небольших подсказок) преобразовывать объекты в какой то формат и обратно.

Подключим библиотеку hibernate     	
	
http://hibernate.org/ 	
http://hibernate.org/orm/releases/5.1/	
https://search.maven.org/artifact/org.hibernate/hibernate-core/5.1.17.Final/jar	
	
Для работы с mysql нужно подключить обе звыисимости

implementation 'mysql:mysql-connector-java:8.0.15' //для работы hebernate нужен драйвер 
implementation 'org.hibernate:hibernate-core:5.1.17.Final'
 
	
Делаем вспомогательный тест, в котором будем учиться устанавливать соединение с бд при помощи hebernate	

package ru.testjava.addressbook.tests;
import org.testng.annotations.Test;
public class HdConnectionTest {
  @Test
  public void testHdConnection() {
    
  }
}
	
Обращаемся к документации
http://docs.jboss.org/hibernate/orm/5.1/quickstart/html_single/#tutorial-native

Сначала нужно сделать конфигурационный файл hibernate.cfg.xml 	

Содержимое можно взять из http://docs.jboss.org/hibernate/orm/5.1/quickstart/html_single/hibernate-tutorials.zip	
	
Копируем полностью из ~\hibernate-tutorials\annotations\src\test\resources\	и вставляем в наш проект 
	
Теперь нужно его доработать:
-поменяем драйвер базы данных		
 <property name="connection.driver_class">com.mysql.cj.jdbc.Driver</property>

- поменяем адрес бд 
<property name="connection.url">jdbc:mysql://localhost:3306/addressbook</property> //указываем отдельно юзера и пароль
<property name="connection.username">root</property>
<property name="connection.password"></property>
 
 - диалект 
<property name="dialect">org.hibernate.dialect.MySQLDialect</property> 

- Будем смотреть какие запросы генерирует hebernate, для контроля 
<property name="show_sql">true</property>


!Важно
<!-- Drop and re-create the database schema on startup --> //Удалить или пересоздать схему бд во время запуска 
<property name="hbm2ddl.auto">create</property>

Значение create опасно, если сделать неправильную привязку объектов к базе данных, внезапно могут создаться новые таблицы или новые столбцы в уже существующих таблицах.

Укажем значение validate. Это означает, что hebernate должен только проверить правильность привязки. Он проверит, что нужные таблицы, столбцы в бд существуют. Если не существуют, то он об этом сообщит, но создавать ничего не будет. Базу данных менять нельзя.  

Привязки или mapping 
<!-- Names the annotated entity class -->
<mapping class="ru.testjava.addressbook.model.GroupData"/>

Нужно описать привязку для каждого класса, который привязывается к базе данных, то есть ему соответствует какая та таблица в бд, .     
В конфигурационном файле нужно только объявить, что привязка существует.

Возвращаемся в тест
Как установить соединение с бд
Обращаемся к док http://docs.jboss.org/hibernate/orm/5.1/quickstart/html_single/#hibernate-gsg-tutorial-basic-test

Добавляем блок кода и помечаем аннотацией 

//функция которая устанавливает соединение с бд

@BeforeClass
protected void setUp() throws Exception {
	// A SessionFactory is set up once for an application!
	final StandardServiceRegistry registry = new StandardServiceRegistryBuilder() //добавляем импорты
			.configure() // configures settings from hibernate.cfg.xml
			.build();
	try {
		sessionFactory = new MetadataSources( registry ).buildMetadata().buildSessionFactory(); //добавляем поле 
	}
	catch (Exception e) {
		// The registry would be destroyed by the SessionFactory, but we had trouble building the SessionFactory
		// so destroy it manually.
		StandardServiceRegistryBuilder.destroy( registry );
	}
}

Эта стандартная процедура инициализации, во время которой будет прочитан конфиг файл, из него извлечена вся информация о бд, проверено что есть доступ к бд, извлечена информация о меппингах (привязках) объектов к таблицам и будет проверено что эта привязка корректная, то есть есть все необходимые таблицы и поля в них.

Кроме инициализации нужно написать код теста, который извлекает информацию о группах 

Обратимся к документации

//Example 6. Obtaining a list of entities
session = sessionFactory.openSession();//проще session удалить, и заново создать локальную переменную с помощью среды разработки
session.beginTransaction();
List result = session.createQuery( "from Event" ).list();//List импортируем, можно явно указат тип, меняем запрос
for ( Event event : (List<Event>) result ) { //event меняем на GroupData, так как уже указали тип, то здесь приводить к типу не надо
    System.out.println( "Event (" + event.getDate() + ") : " + event.getTitle() );
}
session.getTransaction().commit();
session.close();


стало

  @Test
  public void testHdConnection() {
    Session session = sessionFactory.openSession();
    session.beginTransaction();
    List<GroupData> result = session.createQuery("from GroupData").list();
    for (GroupData group : result) {
      System.out.println(group);
    }
    session.getTransaction().commit();
    session.close();
  }

Запрос к базе данных createQuery("from GroupData") 
При использовании инструментов такого типа (ORB) вместо языка запросов SQL используется OQL (Object Quary Language) язык запросов к объектам.
Вместо того, чтобы писать название таблицы, пишем название объектов а все остальное сделает инструмент: он размеберется какая таблица соответствует этим объектом, извлечет данные и сразу вернет список объектов нужного типа. 

На данном этапе можно запустить тест, чтобы убедится в правильности конфиг файла , что информация от туда загружается и hebernate может установить соединение с бд. Но если попытка окажется не удачной, мы не узнаем, потому что перехватывается исключение и инфо о нем пропадает.
Добавляем вывод сообщения об ошибке

catch (Exception e) {
	e.printStackTrace(); //вывести сообщение об ошибке на консоль
	StandardServiceRegistryBuilder.destroy( registry );

Добавим зависимость в build.gradle

https://stackoverflow.com/questions/51916221/javax-xml-bind-jaxbexception-implementation-of-jaxb-api-has-not-been-found-on-mo
compile('javax.xml.bind:jaxb-api:2.3.0')
compile('javax.activation:activation:1.1')
compile('org.glassfish.jaxb:jaxb-runtime:2.3.0')

Запускаем тест. Наша задача убедится, что соединие с бд устанавливается, то есть во время выполнения метода инициализаци не возникает ошибок.
Тест прошел дальше и упал при попытке выполнить запрос creatyQuery()
Caused by: org.hibernate.hql.internal.ast.QuerySyntaxException: GroupData is not mapped

Привязка к бд осуществляется при помощи аннотаций //оставляем инструменту подсказки 


package ru.testjava.addressbook.model;

@XStreamAlias("group")
@Entity//объявляет класс GroupData привязанным к бд
//Если бы таблица называлас также как класс GroupData, то никакие дополнительные параметры были бы не нужны. Инструмен сопоставил бы их автоматически.
//У нас таблица называется по другому, поэтому необходимы дополнительные указания
@Table(name="group_list")
public class GroupData {
  @XStreamOmitField
  @Id //атрибут id используется как идентификатор, поэтому ему присваивается особая аннотация
  @Column(name = "group_id")//если бы название столбца совпадало с названием атрибута, то ничего доп указывать не нужно
  private int id = Integer.MAX_VALUE;
  @Expose
  @Column(name = "group_name")
  private String name;
  @Expose
  @Column(name = "group_header")
  private String header;
  @Expose
  @Column(name = "group_footer")
  private String footer;

Запускаем тест, он падает
Schema-validation: wrong column type encountered in column [group_footer] in table [group_list]; found [mediumtext (Types#LONGVARCHAR)], but expecting [varchar(255) (Types#VARCHAR)]



Иногда преобразование типов hebernate может сделать самостоятельно, но иногда ему нужна подсказка
добавляем в описание типа 

@Type(type="text") //эти поля многострочные, поэтому в бд они храняться по другому 	


Запускаем тест, получаем результат 

ru.testjava.addressbook.model.GroupData{footer=footer 0, name=test 0, header=header 0, id=37} 
ru.testjava.addressbook.model.GroupData{footer=footer 1, name=test 1, header=header 1, id=38} 
ru.testjava.addressbook.model.GroupData{footer=footer 2, name=test 2, header=header 2, id=39} 

В лог файл и на консоль выводится много инфо уровня debug. Есть возможность это настроить в конфигурационном файле logback.xml

Для аппендера, который пишет на консоль нужно настроить фильтр 
<appender name="STDOUT" 

Идем читать документацию, https://logback.qos.ch/manual/filters.html


ThresholdFilter

 <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      <level>INFO</level>
    </filter>



 <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level> //выводит на экран уровень инфо и или выше
        </filter>
        <encoder>
            <pattern>%-4relative [%thread] %-5level %logger{35} - %msg %n</pattern>
        </encoder>
    </appender>



	
}
Урок 72. Условия отбора данных {
	
Извлечем информацию о контактах

Сначала изменим тест 

было
@Test
  public void testHdConnection() {
    Session session = sessionFactory.openSession();
    session.beginTransaction();
    List<GroupData> result = session.createQuery("from GroupData").list();
    for (GroupData group : result) {
      System.out.println(group);
    }
    session.getTransaction().commit();
    session.close();
  }
	
стало	
  @Test
  public void testHdConnection() {
    Session session = sessionFactory.openSession();
    session.beginTransaction();
    List<ContactData> result = session.createQuery("from ContactData").list();
    for (ContactData contact : result) {
      System.out.println(contact);
    }
    session.getTransaction().commit();
    session.close();
  }	
	
Запускаем тест, тест падает с ожидаемым исключением. Для объектов ContactData не описаны привязка к бд.

Сначала отправляемся в класс ContactData и объявляем его 
@Entity
	
Дальше указываем в какой таблице хранится информация об объектак такого типа

@Table(name="addressbook") // из пакета javax.persistence.	
	
@Entity
@Table(name="addressbook")
public class ContactData {

@XStreamOmitField	
@Id
@Column(name="id")
private int id = Integer.MAX_VALUE;

@Column(name="firstname")
private String firstname;


Аналогично, указать аннотации для других простых атрибутов


Для сложных атрибутов	
	
Привязка к группам нигде не хранится. Такого столбца в таблице нет. Информацию о том, в каких группах хранится контакт мы научимся получать позже. 

А сейчас нужно пометить поле, чтобы оно было пропущено, не извлекалось из бд.
Есть два способа: 

способ 1
@Transient
private String group;	

способ 2
transient private String group;	

Тоже надо сделать с остальными сложными атрибутами

Кроме	
	
@Column(name="photo")
private File photo; //атрибут типа файл, но в базе хранится строка а не сам файл 	
//если оставим тип File, то hebernate не сможет это прочитать из бд

Нужно поменять тип на String

@Column(name="photo")
private String photo;	

Чтобы не исправлять getter() и setter() и другие места в коде, преобразовывать эту строчку в файл можно внутри getter() и setter()  

было	
public File getPhoto() {
	return photo;
}	
  
public ContactData withPhoto(File photo) {
	this.photo = photo;
return this;
}  
	
	
стало

public File getPhoto() {
	return new File(photo);
}


public ContactData withPhoto(File photo) {
	this.photo = photo.getPath();
	return this;
}	

То есть для внешнего наблюдателя, будет казаться что мы работаем с файлом, а внутри объекта хранится строка - путь к этому файлу. 
И в таком виде, с бд связывать этот объект получается уже проще. 

Указав аннотации для всех атрибутов, переходим к конфигурационному файлу hibernate.cfg.xml

В нем нужно написать, что такая привязка существует

<mapping class="ru.testjava.addressbook.model.ContactData"/> //привяза должна быть указана явно

Запускаем тест, тест падает 

Schema-validation: wrong column type encountered in column [address] in table [addressbook]; found [text (Types#LONGVARCHAR)], but expecting [varchar(255) (Types#VARCHAR)]

	
Для номеров телефонов нужно дополнительно указать аннотацию
@Column(name="home")
@Type(type="text")
private String home;		

Это видно из лога, в сообщении об ошибке	
Schema-validation: wrong column type encountered in column [address] in table [addressbook]; found [text (Types#LONGVARCHAR)], but expecting [varchar(255) (Types#VARCHAR)]	

Поле в бд имеет тип LONGVARCHAR, и это соответствует типу text с точки зрения hebernate. Этот тип нужно указать рядом с соответствующим полем.  
	
//для mediumtext можно указать text	
	
Запускаем тест, получаем результат
4 объекта типа ContactData

Смотрим на приложение через веб интерфейс, там указан 1 контакт. В базе данных 4 контакта. 
Оказывается, что все предыдущие ранее были созданы, а потом удалены. И в бд они физически не удалились, вместо этого они помечены как удаленные. В поле deprecated (устаревший) стоит дата удаления. Если стоит 00-00-00, это означает что он пока не удален.

Соответственно, нам нужно из бд извлекать только те контакты, у которых в поле deprecated написано 00-00-00

Доработаем запрос

List<ContactData> result = session.createQuery("from ContactData where deprecated = '0000-00-00'").list();
    
Теперь на консоль выводится 1 контакт, неудаленный.	
	
	
}	

Урок 73. Сравнение данных, загруженных из БД {
	
Используем возможность быстрой загрузки данных из бд на примере теста для модификации групп

Если в списке порядка 100 групп, то тест работает медленно (6 сек). Потому что ему придется прочитать со странице веб приложения список групп два раза - до и после модификации. 

При разработке автотестов нужно придерживаться общего правила - если вы можете какие то не основные вспомогательные действия сделать через более быстрый интерфейс, нужно это сделать. 
 
В тесте для модификации группы мы проверяем корректность работы функции, которая модифицирует группу. Значит основным действием является
app.group().modify(group);
 
Все остальное можно считать вспомогательными действиями. В частности, получаение списка групп - самое длительная и дорогостоящая операция, которая выполняется многократно: при проверки предусловия, перед и после модификации группы; может быть выполнена через более быстрый интерфейс.

Например, путем прямого обращения к бд. Да, мы не контролируем список групп, который выводится на страницу приложения. Но это можно сделать отдельным тестом, он не связан на прямую с операцией модификации группы. Здесь тестируется именно операция модификации, поэтому все остальное нужно постараться сделать максимально быстрым способом. 

Создадим новый класс DbHelper в ApplicationManager
В отличии оcтальных, он не наследуется от TestBase и передавать webdriver в качестве параметра ему не нужно.

Но инициализировать в init() его все равно придется
dbHelper = new DbHelper(); //в контсруктор не будет передавать никакие параметры, он будет загружать все необходимую информацию из файла hebernate.cfg.xml

Добавляем соответствующие поле в AM
private DbHelper dbHelper;
	
Создаем метод, который будет возвращать этого помощникам
  public DbHelper db() {
    return dbHelper;
  }

Если мы хотим указывать разные адреса бд, точно также как делали для веб приложения (local.properties), то правильнее всего было бы в local.properties добавить специальный параметр, который указывает на разные конфигурационные файлы для hebernate.

Возвращаемся в DbHelper 
Во первых нужно сделать конструктор, в котором будет инициализироваться SessionFactory (фабрика сессий)

public class DbHelper {

  public DbHelper() {
    final StandardServiceRegistry registry = new StandardServiceRegistryBuilder()
            .configure() // configures settings from hibernate.cfg.xml
            .build();

    sessionFactory = new MetadataSources(registry).buildMetadata().buildSessionFactory();
  }
}

Методы try / catch убираем, если соединение не установится пусть тест падает прямо на этапе инициализации помощников в AM. 
Чтобы сэкономить, и падение случилось как можно раньше, перенесем инициализацию помощника в самое начало, еще до того как мы начанаем запускать браузеры. Потому что нет смысла запускать браузеры, когда нельзя установить соединение с бд.



public void init() throws IOException {
    String target = System.getProperty("target", "local");
    properties.load(new FileReader(new File(String.format("src/test/resources/%s.properties", target))));
    
    dbHelper = new DbHelper(); //перенесли инициализацию метода для установки соединения с бд наверх
    
    if (browser.equals(BrowserType.CHROME)) {
      driver = new ChromeDriver();

	}
}

Сначала нужно инициализировать те помощники , которые инициализируются быстро, если их удалось инициализировать правильно, то можно переходить к инициализации более медленных помощников.   


Создаем поле для хранения SessionFactory 

Делаем 2 метода, один делаем чтобы получить список групп, другой - список контактов.

public Groups groups(){
    //копируем сюда, код из учебного теста testHdConnection()
    }


  public Groups groups() {
    Session session = sessionFactory.openSession();
    session.beginTransaction();
    List<GroupData> result = session.createQuery("from GroupData").list(); //исправляем тип коллекции, запрос 
    session.getTransaction().commit();
    session.close(); //убрали цикл
    return new Groups(result); //вернуть нужно список результатов + добавляем конструктор 
  }


Добавить конструктор, который по произвольной коллекции строит объект типа Groups

public Groups(Collection<GroupData> groups) {
    this.delegate = new HashSet<GroupData>(groups); //копируем / строим новое множество объектов типа GroupData из коллекции
  }


Возвращаемся в метод проверки предусловия
public class GroupModificationTests extends TestBase {


//было

  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) {
      app.group().create(new GroupData().withName("test1"));
    }
  }

//стало
  @BeforeMethod
  public void ensurePreconditions() {
    if (app.db().groups().size() == 0) {
    app.goTo().groupPage();
    app.group().create(new GroupData().withName("test1"));
  }


Теперь сам тест 

assertEquals(app.group().сount(), before.size()); 
Проверка, которая реализовывала хеширование, то есть оптимизацию - быструю проверку перед более медленной, теперь становится не очень нужной. Функцию хеширования она больше не выполняет, более того это проверка скорее всего будет выполняться медленнее, чем загрузка информации из бд. То есть наоборот она теперь не ускоряет, а замедляет выполнение тестов.      
Но оставим ее здесь, чтобы минимально контролировать пользовательский интерфейс, убедится что там количество групп неизменилось. 
А точное и подробное сравнение информации о группах будет происходить другим способом - эту информацию мы загружаем не из пользовательского интерфейса, а из бд.   


  @Test
  public void testGroupModification() {
    Groups before = app.db().groups(); //берем список напрямую из бд
    GroupData modifiedGroup = before.iterator().next();
    GroupData group = new GroupData()
            .withId(modifiedGroup.getId()).withName("new1").withHeader("new2").withFooter("new3");
	app.goTo().groupPage();		
    app.group().modify(group);
    assertEquals(app.group().сount(), before.size());
    Groups after = app.db().groups();//берем список напрямую из бд
    assertThat(after, equalTo(before.without(modifiedGroup).withAdded(group)));
  }

Запустим тест, время выполнение 0,9 сек


Как мы сравниваем объекты типа GroupData

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    GroupData groupData = (GroupData) o;

    if (id != groupData.id) return false;
    return name != null ? name.equals(groupData.name) : groupData.name == null;
  }

Мы сравниваем только name, потому что другая информация из веб интерфейса нам не доступна.
И в тесте при модификации, группы мы указываем header и footer но не можем это проверить, потому что в списках это никак не учитывается.

Но все меняется, когда мы загружаем данные из бд. Там содержаться полная инфо об атрибутах объектов, поэтому мы можем поменять функцию сравнения equals и сравнивать не один атрибут а все.   

Перегенерируем функцию equals(), выберем все атрибуты.

Запускаем тест, теперь сравниваются name, header, footer. 

//но теперь необходимо передать тесты для создания группы 

	
}	

Урок 74. Отключаемые проверки UI {
	
Реализовав проверки списков, загружаемых из базы данных, мы потеряли проверки, которые раньше выполнялись, сравнения списков, загруженных из UI. Получается сейчас в тестах никак не контролируется отображение списков в UI.

Добавим проверку во все тесты, так чтобы в них загружались списки из бд и UI. Но при этом тесты снова замедляться. 
Поэтому следаем эту проверку отключаемой. И реализуем специальный параметр конмадной строки. 
Если при запуске тестов этот параметр не указан, то проверка отключена тесты работают быстро. 
Если при запуске указывается специальный параметр, то он включает проверку, тесты работают медленнее но зато более тчательно проверяют UI.

В тест для модификации групп, после сравнения списков до и после модификации, добавим еще одну проверку.
Оформим ее в виде отдельного метода , который поместим в класс TestBase, чтобы можно было эту проверку выполнять в любых тестах, находящихся в разных классах. 

  public void verifyGroupListInUI() {
    Groups dbGroups = app.db().groups();
    Groups uiGroups = app.group().all();
    assertThat(uiGroups,equalTo(dbGroups));


  } 


Пробуем запустить тест, проверка завершается не успешно. ПОтому что из UI загружается инфо только об именах групп, а из бд загружается полная инфо включая header footer. 
Сейчас функция сравнения сравнивает все свойства. Поэтому множества не совпадают.

Что нужно сделать, для того чтобы объекты сравнивались правильно.

Нужно те объекты, которые загружены из бд, упростить. Убрать из них инфо об header footer, оставить только id name.

Для того, чтобы выполнить такое преобразование нам пригодится функициональное программирование. 

Ко всем элементам коллекции, тем даным, которые загружены из бд, нужно применить функцию, которая их упращает. 
Получаем stream и применяем ко всем элементам потока некоторую функциию map
Аннонимная функция, которая принимает на вход группу, а на выходе будет новый объект типа GroupData с идентификатором и именем, таким же как и у преобразуемого объекта. Теперь после того, как ко всем элементам применена эта функция, надо все это собрать при помощи коллектора. 


assertThat(uiGroups,equalTo(dbGroups.stream().map((g) -> new GroupData().withId(g.getId())
.withName(g.getName())).collect(Collectors.toSet())));

В результате, сравнивается уже два множества, которые состоят из объектов, содержащих инфо только об идентификаторах и именах. 

Теперь нужно реализовать возможность отключать эту проверку. 
Для этого нужно добавить проверку условия, в начало метода verifyGroupListInUI()

Если установлено специальное системное свойство и оно имеет значение true, то тогда нужно все эти действия выполнять. Иначе, ничего делать не нужно.

Для того, чтобы получить значение некоторого системного свойства, которое представляет собой буливскую величену можно пойти двумся путями:

- сначала вызвать System.getProperty(),а потом получившуюся строку преобразовать в булевское значение.
- вызать Booleam.getBoolean(). Эта функция получает системное свойство с заданным именем, и автоматически преобразует его в булевскую величину.

public void verifyGroupListInUI() {
    if (Boolean.getBoolean("verifyUI")) {//если это свойство установлено, то проверку делать
      Groups uiGroups = app.group().all();
      Groups dbGroups = app.db().groups();
      assertThat(uiGroups,equalTo(dbGroups.stream().map((g) -> new GroupData().withId(g.getId())
              .withName(g.getName())).collect(Collectors.toSet())));

    }
  }

Запускаем тест, тест быстро завершается, потому что проверка через UI не будет выполняться.

Теперь идем в настройки конфигурации запуска и добавляем опцию -DverifyUI=true //включить проверки

Запускаем тест, тест завершается успешно, но время выполнения увеличилось. 

Если запускать тесты из консоли и там тоже передавать это свойство, нужно сделать проброс

В конфигурационном файле build.gradle для обоих задач для запусков тестов нужно реализовать свойство 

    if (project.hasProperty('verifyUI')) {
        systemProperty 'verifyUI', "${verifyUI}"
    }


Нужно добавить эту проверку во все тесты, чтобы по умолчанию они загружали списки из бд (быстро). А по желанию, можно было включить дополнительные проверки, контролирующие корректность списков в UI.

	
}	

Урок 75. Связи между объектами {

Научились загружать инфо из бд об объектах. Теперь загрузим инфо о связях между объектами.
В тестовом приложении есть группы и контакты. Причем контакт может входить в несколько разных групп, а группа может включать в себя какие то контакты. 
Было бы удобно, если в объекте типа GroupData можно вызвать специальный метод getContacts() и получить список контактов, которые входят в эту групп. И наоборот, в объекте типа ContactData должен быть метод getGroups(), который возвращает список групп, в которые входит этот контакт.

Для того, чтобы реализовать такую функциональность, нужно обратиться к документации 

http://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#associations-many-to-many

Посколько контакт может входитб в несколько разных групп, а группа может содержать несколько разных контактов, то в данном случае мы имеем дело с отношением типа ManyToMany. Для работы с такими отношениями используется аннотация ManyToMany. 

Эта аннотация применяется к атрибутам, которые представляют собой коллекции объектов какого то другого типа. В классе ContactDate у нас будет множество групп, а в классе GroupdData будет множество контактов. 

Сначала реализуем метод в классе ContactData

Имеющееся свойство групп удаляем
 @Transient
  private String group = "[none]";

//использовалось ранее, для того чтобы при создании контакта указать какую то группу 

Вместо этого свойство будет более сложное

  @ManyToMany 
  private Set<GroupData> groups;


Согласно документации, надо сразу инициализировать это свойство 

@ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
	private List<Address> addresses = new ArrayList<>();


То есть в нашем случае создать пустое множество. 

  @ManyToMany
  private Set<GroupData> groups = new HashSet<GroupData>();

Появились красные пометки, это те места, в которых используется удаленный атрибут groups. Удаляем такие getter и setter, потому что контакт ассоциирован не с одной группой, а сразу с несколькими.
Вместо этого нужно добавить getter для нового атрибута.

  public Set<GroupData> getGroups() {
    return groups;
  }


Для единообразия нужно сделать так, чтобы этот getter возвращал объект типа Groups.
 
public Groups getGroups() { //меняем тип возвращаемого значение на Groups
	
//Для этого внутри нужно сделать преобразование 

return new Groups(groups); //вернуть создать копию множество превратить в объект типа Groups

Теперь, также как и для остальных атрибутов, нужно указать где именно храниться инфо об этих связях. 

Как именно связываются контакты и группы? 
Загляним в структуру бд. Это делается с помощью специальной дополнительной таблицы, она называется address_in_groups
Колонка id содержит идентификатор контакта, колонка id_group содержит идентификатор группы

Нужно у аннотации ManyToMany указать, что в качестве связющей таблицы JoinTable (таблица связей) используется address_in_groups

@ManyToMany 
@JoinTable(name = "address_in_groups")

столбец JoinColumns указывает на объект текущего класса, то есть на контакты - это столбец id

@JoinTable(name = "address_in_groups", joinColumns = @JoinColumn(name = "id"))

добавляем второе свойство inverseJoinColumn (обратный столбец), тот который указывает на объект другого типа, то есть на группу.

 
@JoinTable(name = "address_in_groups", joinColumns = @JoinColumn(name = "id"),
          inverseJoinColumns = @JoinColumn(name = "groups"))

Мы описали связь между объектами двух типов.


Теперь в классе GroupData нужно сделать анналогичные изменения, нужно создать 

@ManyToMany
  private Set<ContactData> contacts = new HashSet<ContactData>();

Но заново описывать связь не нужно. Вместо этого, достаточно указать 

@ManyToMany(mappedBy = "groups")

Это означает, что в парном классе ContactData нужно найти свойство/атрибут groups и оттуда взять все описание связи между объектами.

Для того, чтобы убедится, что инфо правильно извлекается из бд, запустим тест testHdConnection. Добавив вывод на консоль список групп в которых состоит контакт 
System.out.println(contact.getGroups());


В результате получаем, 

ContactData{firstname='test11', lastname='test22'} //инфо о контакте

//выполняется запрос к бд, мы узнаем в какие группы входит этот контакт и выводит инфо об этих группах
[GroupData{id='37', name='test 0'}, GroupData{id='43', name='test 3'}, GroupData{id='55', name='test 15'}]


Как именно работате извлечение связанных объектов?

@ManyToMany
@JoinTable(name = "address_in_groups", joinColumns = @JoinColumn(name = "id"), inverseJoinColumns = @JoinColumn(name = "groups"))

Вернемся во временных тест testHdConnection и переставим строки местами 

было
@Test
  public void testHdConnection() {
    Session session = sessionFactory.openSession();
    session.beginTransaction();
    List<ContactData> result = session.createQuery("from ContactData where deprecated = '0000-00-00'").list();
    for (ContactData contact : result) { 
      System.out.println(contact);
      System.out.println(contact.getGroups(
	  ));
    }
    session.getTransaction().commit();
    session.close();
  }

стало


@Test
  public void testHdConnection() {
    Session session = sessionFactory.openSession();
    session.beginTransaction();
    List<ContactData> result = session.createQuery("from ContactData where deprecated = '0000-00-00'").list();
    
    session.getTransaction().commit();
    session.close();
	
	for (ContactData contact : result) {	//переносим этот фрагмент кода после того, как транзакция уже закрыта 
      System.out.println(contact);
      System.out.println(contact.getGroups()); //сбой произошел при выполнении метода getGroups()
    }
  }

После запуска теста в таком варианте, получаем исключение LazyInitializationException. 
Причина сбоя в том, что к моменту выполнения метода getGroups() соединение уже закрыто, а нам надо выполнить еще один запрос. Для того, чтобы получить список групп, в который включен этот контакт. 

Есть два пути
1 способ
Нужно держать транзакцию открытой в течение более длительного времени, например на протяжении всего теста. В начале открываем транзакцию, в конце закрываем. 
Но это не очень хорошо, потому что тест может быть достаточно длинным. А транзакцию стоит закрывать как можно быстрее, после того как необходимая информация из бд получена.

2 способ
Сделать так, чтобы как только информация о контакте из бд извлекается - сразу автоматически извлекалась информация обо всех группах, которые с этим контактом связаны. 

Для этого нужно вернуться в класс ContactData и в аннотации @ManyToMany указать дополнительную опцию

fetch = FetchType.EAGER //жадный, из бд будет извлекаться сразу как можно больше инфо за 1 заход
fetch = lazy //по умолчанию имеет значение lazy , из бд извлекается как можно меньше информации 

Запускаем тест, тест зеленый.

---
Восстановим фрагмент кода, который ранее пришлось закомментировать


//contactData.getGroup());

Создаваемый контакт должен добавляться в какую то группу. Откуда эту группу взять?
Нужно извлечь из бд инфо о всех группах и выбрать какую то из них. 

Делаем первое действие 
@Test
  public void testContactCreationDb() {
    Groups groups = app.db().groups();//добавляем загрузку всех групп 
File photo = new File ("src/test/resources/stru.png"); //подготовку создания объекта перенесем в самое начало 
ContactData newContact = new ContactData().withFirstname("firstname0").withLastname("lastname0").withPhoto(photo)
	.inGroup(groups.iterator().next());
app.contact().create(newContact, true);	//используем значение, которое хранится в переменной
ContactData newContact = new ContactData().withFirstname("firstname0").withLastname("lastname0").withPhoto(photo)
            .inGroup(groups.iterator().next()); //помещаем этот контакт в какую нибудь группу
			
Конечно, нужно в этом тесте реализовать проверку предусловия. 
Если нет ни одной группы, то нужно сначала какую нибудь группу создать

Реализуем метод inGroup(), который будет в существующий набор групп добавлять 

public ContactData inGroup(GroupData group) {
    groups.add(group); //помечаем контакт, как добавленный в какую то группу
    return this; // возвращаем this, чтобы множно было это вытягивать в цепочки contact.inGroup().inGroup()
	
  }
  
Теперь идем в ContactHelper и возвращаем код, который был закоменнтирован

if (creation) {
      if (contactData.getGroups().size() > 0 ) {
		  //то нужно добавить этот контакт в какую нибудь группу
		  //так как на форме создания контакта можно выбрать только одну группу, то нужно сделать доп проверку 
        Assert.assertTrue(contactData.getGroups().size() == 1); //в 2 разные группы мы его не сможем добавить 
		//поэтому такие входные данные. следует считать недопустимыми 
        new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroups().iterator().next().getName());
      }//если не указана никакая группа, значит никуда его не добавляем - ничего не выбираем из выпадающего списка
	  //если указана одна группа, то будем пытаться выбрать из выпадающего списка 
			//если указана 2 или больше. то это не допустимая ситуация
    } else {
      Assert.assertFalse(isElementPresent(By.name("new_group")));
    }

В домашнем задании нужно реализовать тесты для добавления контакта в группу и удаления контакта из группы. 
Не забудьте также реализовать проверку и обеспечение предусловий. Если вы выбрали какой то контакт, то нужно проверить если ли возможность добавить его в какую нибудь группу. 
Может быть он уже во все группы добавлен, и тогда нужно выбрать другой контакт, либо создать дополнительную группу, в которую можно будет этот контакт включить.

	
	
}
Занятие 8.Сетевое программирование. Протоколы прикладного уровня
Урок 76. Установка нового учебного приложения MantisBT {
	
Примеры сетевыйх протоколов прикладного уровня:
HTTP (для работы с веб сервером)
FTP (для передачи данных)	
POP3 (почтовые протокол)
TELNET (для удаленного выполнения команд)

Тестируемое приложение https://www.mantisbt.org/ 

Скачиваем
https://sourceforge.net/projects/mantisbt/files/mantis-stable/1.2.19/

Распаковываем архив в 
c:\xampp\htdocs\

Открываем страницу в браузере	
http://localhost/mantisbt-1.2.19/
	
При первом запуске открывается страница инстолятора, в которой написано название бд, в которой багтрекер все будет хранить.

Создадим эту бд.

Переходим на http://localhost/phpmyadmin/ 	

Можно использоватать то самое имя, которое предлагает инсталятор.
	
bugtracker utf8_general_ci	
	
	
БД готова, импортировать структуру не нужно. Это сделает инсталятор.

Возвращаемся на страницу с инсталятором	http://localhost/mantisbt-1.2.19/
Нажимаем кнопку Install
	
Через некоторое время видем отчет об успешной инсталяции.

То что пароль к бд пустой - ничего страшного в этом нет.

Все остальное дб зеленое.	
	
Переходим по ссылке в конце страницы и попадаем на форму логина.

administrator / root

//красные сообщения внизу предупреждают что используется дефолтный пароль администратора. Менять его не будем.

//директория админ, та самая в которой находился инсталятор. Может быть удалена. 
//можно зайти в корень mantis и удалить / переименовать папку admin 
	
Учебное приложение установлено. 	
	
	
}	
Урок 77. Подготовка проекта для тестирования MantisBT {

Начнем делать тесты для учебного приложения Mantis. Поместим эти тесты в тот же самый проект, но сделаем для них отдельный модуль. 
Необходимо создать в этом модуле минимально необходимую инфрастртуру: 
- создать подкаталог для этого модуля;
- поместить конфиг файл build.gradle и остальные файлы, необходимые для сборщика gradle;
- подлючить зависимости;
- поместим два класса "TestBase" и "ApplicationManager".
	
Делаем подкаталог mantis-tests (в проводнике / TC)

В него из существующего модуля переносим структурные элементы
gradle, gradlew, gradle.bat, build.gradle

На этом этапе модуль можно уже импортировать в idea, чтобы остальные изменения делать там.

File > Product Structure > Modules > + > Import modules >

Выбираем файл C:\..\GitHub\java_test\mantis-tests\build.gradle > Ok

Включаем 
use auto import
use default gradle wrapper
create directories for empty content
Ok

Проверяем на вкладке Sourses режим совместимости с Java старше 11
Ок

Чистим файл build.gradle так как он содержит лишнюю инфо
Отключаем (удаляем) ненужные зависимости.
Оставляем 

    implementation 'org.testng:testng:7.0.0-beta3'
   // implementation 'com.katalon:com.katalon.platform.parent:1.0.5'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'
    implementation 'org.hamcrest:hamcrest:2.1'

Т.к. оставляем для запусков тестов одну единственную (про запас) дадим ей обычное имя test 

В итоге получим 


apply plugin: 'java'


repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.testng:testng:7.0.0-beta3'
    implementation 'com.katalon:com.katalon.platform.parent:1.0.5'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'
    implementation 'org.hamcrest:hamcrest:2.1'
}

test {
    useTestNG() {
        suites 'src/test/resources/testng.xml'
    }
    if (project.hasProperty('browser')) {
        systemProperty 'browser', "${browser}"
    }

    if (project.hasProperty('target')) {
        systemProperty 'target', "${target}"
    }

    if (project.hasProperty('verifyUI')) {
        systemProperty 'verifyUI', "${verifyUI}"
    }
}
 

Не смотря на то, что включен автоимпорт иногда среда разработки не догадывается, что нужно перегенерировать зависимости после того как вы их удалили.

Для того, чтобы это обновить вручную нужно 
View > Tool Windows > Gradle > Refresh (справа) 

При этом происходит импорт конфигурационных файлов Build.gradle и подключение / отключение зависимостей.

Переносим из существующего модуля addressbook другие элементы инфраструктуры

Заходим в test > resources 

Переносим
local.properties //описывает свойства тестового стенда 

В нем указываем 

web.baseUrl=http://localhost/mantisbt-1.2.19
web.adminLogin=administrator
web.adminPassword=root

Создаем пакет ru.stqa.pft.mantis в папке java
Внутри этого пакета делаем пакет tests
Копируем в него класс TestBase


Чистим класс TestBase, оставляем в нем только  инициализацию ApplicationManager

Создаем ru.stqa.pft.mantis.appmanager

Копируем в него класс ApplicationManager

Чистим ApplicationManager. Удаляем всех помощников. Оставляем только инициализацию самого ApplicationManager

Новый модуль готов.
В нем будет TestBase, от которого будут наследоваться все тестовые классы чтобы получить доступ к АМ 
В нем будет АМ, который ссылается на каких то помощников  
Есть файл local.properties который содержит инфо о тестовом стенде. 
И общая инфрастртура, файл конфигурационный файл build.gradle и запускатель gradlew


}
Урок 78. Прямое взаимодействие с сервером по протоколу HTTP {
Протокол HTTP предназначен для взаимодействия с веб сервером. 	

По протоколу HTTP веб приложение (бразузер) общается с сервером. 
Когда мы указываем в адресной строке бразуера адрес страницы, отправляется запрос по протоколу HTTP
В ответ на этот запрос сервер присылает код страницы, который отображается в браузере 

Запрос может содержать не только адрес, но и введенную в поля информацию     

F12 > Network 

На этой вкладке показывается какими запросами браузер обменивался с сервером.

Выполним тот запрос, который выполняет вход в систему.

Вводим administrator / root 
Нажимаем кнопку Login 

Самый первый запрос POST, login , Form Data 

На этот запрос сервер ответил кодом 302 . Это означает перенаправление на другой адрес 
Так выглядит ответ 
Responce Headers 
Location: http://localhost/mantisbt-1.2.19/login_cookie_test.php?return=index.php //место куда нужно отправиться браузеру 

Браузер отправился в это место, проверил что то 
И затем отправился на эту страницу
manage_proj_create_page.php после этого запроса вернулся код 200 и содержимое страницы, которое сейчас отображается в браузере 

http://localhost/mantisbt-1.2.19/manage_proj_create_page.php

Содержимое страницы приходит в виде View Source Page Ctrl + U, которое отображается в окне браузера как мы видим. 

Чтобы отправлять эти запросы по протоколу HTTP вовсе не обязательно иметь браузер. 

Можно использовать специальную библиотеку HTTP Client
Она будет сразу же формировать запрос в нужном виде. Отправлять на сервер, получать ответ. И этот ответ мы может каким то образом анализировать, извлекать из него какую то инфо, использовать в следующих запросах.    

Вместо того, чтобы управлять браузером мы получаем другую схему работы - тесты напрямую взаимодействуют с сервером при помощи HTTP Clienta.

Создаем класс HttpSession в tests. 
Это будущий помощник АМ, который не требует доступа к браузеру. Он легковесный, поэтому в классе AM он будет инициализироваться иначе.

Вместо того, чтобы создать один единственный экземляр помощника и иниализировать его в методе init(), который вызывается один раз в самом начале.

Сделаем метод, который инициализирует помощиника при каждом обращении. 
 
  public HttpSession newSession() {
    return new HttpSession(this);
  }

Почему инициализация выполняется так?

Поскольку этот помощник очень легковесный, он инициализируется мнгновенно, мы может открывать сессий сколько угодно. 	
При тестировании такой системы как багтреккер это очень удобно. Вместо того, чтобы входить выходить в систему под разными учетными записями, мы сразу открываем сессию от имени тестировшика, разработчика, менеджера, админа и выполняем тест - цикл баг репорта. 
То есть можно писать сложный тест, в котором одновременно происходит работа под несколькими учетными записями 

Для экономии ресурсов и для ускорения есть смысл перейти на уровень ниже, выполнять такие тесты на уровне сетевого протокола.

Почему конструктор принимает объект типа ApplicationManager
public HttpSession(ApplicationManager app){ //передали ссылку на АМ
    this.app = app;
    
  }    

Это удобно для того, чтобы не нужно каждый раз думать, а какие именно данные АМ должен передать помощнику. Он передает ссылку на самого себя. 
Помощник знает кто является его менеджером, и когда ему нужна какая то дополнительная информация он обращается к менеджеру. 
В часности, таким образом здесь реализовано получение некототорых свойств, прочитанных из конфиг файла. 
Можно было бы передавать в HttpSession эту информацию, в виде отдельных строчек или как объект типа properties. 
Но мы поступили по другому:
передали ссылку на АМ 
public HttpSession(ApplicationManager app){ 
запомнили ее
private ApplicationManager app;

теперь через эту ссылку помощник имеет возможность образаться к АМ
app.getProperty("web.baseUrl")  //дай мне такое свойство и АМ отдает 


Создадим метод getProperty()
  public String getProperty(String key) { //в качестве параметра принимает имя того свойства, которое надо извлечь
    return properties.getProperty(key); 
  }


Как работает HttpSession

В момент конструирования, когда вызывается newSession

  public HttpSession newSession() {
    return new HttpSession(this);
  }

создается новый экземпляр помощника, в котором создается новый клиент клиент 

 public HttpSession(ApplicationManager app){
    this.app = app;
    httpclient = HttpSession.custom().setRedirectStrategy(new LaxRedirectStrategy()).build(); //новый клиент 
  }

Новый клиент - новая сессия для работы по протоколу http - объект, который будет отправлять запросы на сервер 

Сдесь видем шаблон проектирования builder - вытягивание методов в цепочку (флуент интерфейс)

В созданном объекте устанавливается стратегия перенаправлений setRedirectStrategy 

Если ее не установить совсем, то при первом запросе получим код 302 (т.е. перенаправление на другую страницу) и должны будем сами это направление каким то образом обрабатывать. 

Вместо этого, мы хотим чтобы httpclient, автоматически выполнял все перенаправления, установив
setRedirectStrategy(new LaxRedirectStrategy()) 

Вызвали конструктор, создали новый объект, и помещен в поле httpclient


Далее в этом помощнике реализовано 2 метода

public boolean login(){} //умеет выполнять логин

public boolean isLoggedAs(String username) {} //умеет определять какой пользователь залогинен в данный момент 

Для того, чтобы выполнить логин нужно отправить запрос по адресу (app.getProperty("web.baseURL") + "/login.php")
public boolean login() {
    HttpPost post = new HttpPost(app.getProperty("web.baseURL") + "/login.php"); //создается будущий запрос (пока пустой)
	//тип post то есть у него будет какое то тело, внутри которого могут передаваться какие то параметры  
	//далее идет формирование параметров 
    List<NameValuePair> params = new ArrayList();
    params.add();
	
    post.setEntity(new UrlEncodedFormEntity(params)); //параметры упаковываются в соответствии с установленными правилами и помещаеются setEntity в запрос post
	//теперь запрос сформирован и готов к отправке 
    CloseableHttpResponse response = httpclient.execute(post); //происходит отправка httpclient.execute(post) 
	//запрос выполняется , результатом является ответ response, который получен от сервера 
	//анализ ответа, в частиности получение текст - код html
    String body = getTextForm(response);
	//проверка того, что пользователь успешно вошел
	//действительно ли код страницы содержит указанную строчку, в который написано имя пользователя который вошел в систему 	
    return body.contains(String.format("<span class\"italic\">%s</span>", username));
  }

Аналогичным образом можно проверить, какой пользователь сейчас залогинен в систему


public boolean isLoggedAs(String username) {
	//выполняем запрос на адрес - зайти на главную страницу 
    HttpGet get = new HttpGet(app.getProperty("web.baseUrl" + "/index.php")); //тип get - не собираемся передавать параметры, 
    CloseableHttpResponse response = httpclient.execute(get); //выполняем запрос , получаем ответ 
    String body = getTextForm(response); //получаем текст 
    return body.contains(String.format("<span class=\italic\">%s</span>", username)); //проверяем что на странице содержится нужный фрагмент 
  }

  
Напишем тест, в котором этот помощник используется. 




public class LoginTests extends TestBase{


  @Test
  public void testLogin(){
    HttpSession session = app.newSession();
    assertTrue(session.login("administrator", "root")); //проверка что пользователь успешно залогинился, то есть на странице появился нужный текст 
	assertTrue(session.isLoggedAs("administrator")); 
  }

Запускаем тест, но стартует браузер, который не используется . Потому что так написано в методе init() 

Доп инфо:

http://hc.apache.org/httpcomponents-client-ga/index.html

compile 'org.apache.httpcomponents:httpclient:4.5.7'



}
Урок 79. Ленивая инициализация помощников {
	
В предыдущем уроке мы столкнулись с проблемой производительности. Браузер запускается даже тогда, когда он не нужен. Несмотря на то что он нигде не используется АМ его все равно инициализирует.
Для того, чтобы избавится от этой проблемы - реализуем шаблон проектирования (ленивая инициализация)

Будем делат тест для регистрации нового пользователя в системе. 
Задача: браузер должен запускаться только тогда, когда он понадобится

Сначала создадим тест 

public class RegistrationTests extends TestBase{


  @Test
  public void testRegistration() {
    app.registration().start("user1" , "user1@localhost.localdomain"); //ставим заглушки, создаем новый метод 
  }

}

	
Указываем возвращаемое значение RegistratonHelper
  public RegistratonHelper registration() {
    return null;
  }	
	
Создаем такой класс	
	
	public class RegistratonHelper {



}
	
	
Возвращаемся в АМ
  public RegistratonHelper registration() {
    return RegistratonHelper(this); //в качестве параметра передаем this то есть ссылку на АМ 
  //менеджер нанимает помощника и передает ссылку на самого себя
  }		
	
Создаем такой конструктор	
	
public RegistratonHelper(ApplicationManager applicationManager) {
    this.app = app;
    
  }
	
Создаем поле

public class RegistratonHelper {

  private final ApplicationManager app;

  public RegistratonHelper(ApplicationManager app) {
    this.app = app;
  } 
 
}	
	
Создадим метод  	
	
	  public void start(String username, String email) {
  }
	
Этому помощнику браузер нужен

Поэтому добавим поле 

 private WebDriver driver;	
	
Заполняться это поле будет следующим образом

 public RegistratonHelper(ApplicationManager app) {
    this.app = app;
    driver = app.driver;//просим ссылку на драйвер у менеджера
  }

После этого можно пользоваться драйвером


  public void start(String username, String email) {
    driver.get(app.getProperty("web.baseUrl") + "/signup_page.php");
  }

Нас интересует вопрос инициализации 

Для того, чтобы ссылку присвоилась 

  public RegistratonHelper(ApplicationManager app) {
    this.app = app;
    driver = app.driver; //сюда
  }

она должны быть уже проинициализирована в АМ. Как раз это нас не устраивает, то что инициализация драйвера происходит слищком рано. 

Поменяем это на ленивую инициализацию

Сделаем метод getDriver() и этот метод будет иницилизировать драйвер в момент первого обращения.


  public RegistratonHelper(ApplicationManager app) {
    this.app = app;
    driver = app.getDriver(); //здесь
  }
  
  
Создаем метод 

 public WebDriver getDriver() {
    return driver;
  }

При этом созданную переменную public WebDriver getDriver; удаляем

Для того, чтобы инициализация стала ленивой, нужно ее перенести в этот метод




public WebDriver getDriver() {
    if (driver == null) {//если драйвер не проинициализирован, то тогда нужно его проинициализировать а потом вернуть
      if (browser.equals(BrowserType.CHROME)) { //перемещаем сюда фрагмент кода из метода init()
        driver = new ChromeDriver();
      } else if (browser.equals(BrowserType.FIREFOX)) {
        driver = new FirefoxDriver();
      } else if (browser == BrowserType.IE) {
        driver = new InternetExplorerDriver();
      }
  
      driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);
      driver.get(properties.getProperty("web.baseUrl"));
    }
	//а если уже проинициализирован, то делать ничего не надо
    return driver;	
	
}


В результате при вызове метода init() только разгружается конфиг файл
Реально драйвер будет иницилизироваться, когда кто то к нему обратиться (вызовет метод getDriver())

Для того, чтобы никто к нему случайно не обратился напрямую, только через этот метод нужно сделать переменную 
	
private WebDriver driver;
	
Теперь переменная доступна только изнутри этого класса, и фактически только через метод getDriver().

Кроме того, у нас драйвер останавливаться в самом конце и он может быть не проинициализирован

  public void stop() {
    driver.quit();
  } 

Поэтому останов тоже нужно сделать с проверкой

  public void stop() {
    if (driver != null) {
      driver.quit();
    }
  }

Переходим к   

public RegistratonHelper registration() {
    return new RegistratonHelper(this);
  }

Каждый раз создавать новый экземляр класса необходимости нет. 

  public RegistratonHelper registration() {
    return new RegistratonHelper(this);
  }

Вполне достаточно иметь один экземляр этого класса, потому что он будет работать с браузером. А браузер у нас будет только один.


Возникает естественное желание перенести эту инициализацию в метод init() чтобы сделать это один раз, а не при каждом обращании к методу registration()

Но если мы перенесем это в метод init то внутри контсруктора RegistrationHelper произойдет обращение к методу getDriver()

  public RegistratonHelper(ApplicationManager app) {
    this.app = app;
    driver = app.getDriver();
  }

И браузер вновь запуститься при вызове метода init(). Это то отчего мы пытались избавиться. 

Нужно в конструкторе RegistratonHelper реализовать ленивую инициализацию


Создаем поле 
registratonHelper = new RegistratonHelper(this);

Но инициализируем его не в методе init а при первом обращении к методу registration()

То есть 

  public RegistratonHelper registration() {
    if (registratonHelper == null){ 
      registratonHelper = new RegistratonHelper(this); //выполняем инициализацию
    }
    return registratonHelper; //и возвращаем то что получилось в результате инициализации
  }

А если он уже не null, это означает что его уже инициализировали, и повторно иницилизировать не нужно

Теперь при запуске registartion test открывается браузер, а при запуске login test браузер не открывается. 

Таким образом, с помощью шаблона ленивой инициализации можно откладыват тяжеловесные действия на более поздний этап. А если они никогда не понадобятся, то никогда их не выполнять.

Не обязательно все делать сразу при инициализации, можно это делать только когда какой то ресурс понадобиться.


 
}	
Урок 80. Передача файлов на удалённую машину по протоколу FTP {
	
В тесте регистрации нового пользователя, при заполнении полей ввода возникает проблема с capcha.

Нужно отключить capcha на тестовом стенде. В мантис чтобы ее отключить нужно дописать специальную строчку в конфиг файл.
Предположим, что сервер находится на удаленной машине, то есть просто взять и изменить файл мы не можем. Нужно сделать это удаленно, используя протокол для передачи файлов ftp.

Загрузим на удаленную машину конфиг файл, который отключает эту защиту. 

Добавим в проект помощник FtpHelper. Для его работы нужна дополнительная зависимость. 
	
compile  'commons-net:commons-net:3.4'	
	
https://search.maven.org/artifact/commons-net/commons-net/3.4/jar	
	
package ru.stqa.pft.mantis.appmanager;


import org.apache.commons.net.ftp.FTPClient;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class FtpHelper {
  private final ApplicationManager app;
  private FTPClient ftp;


  public FtpHelper(ApplicationManager app) {
    this.app = app;
    ftp = new FTPClient();
  }

  
  //загружает новый и переименовывает старый
  public void upload(File file, String target, String backup) throws IOException {
    ftp.connect(app.getProperty("ftp.host"));
    ftp.login(app.getProperty("ftp.login"),app.getProperty("ftp.password"));
    ftp.deleteFile(backup);
    ftp.rename(target,backup);
    ftp.enterLocalPassiveMode();
    ftp.storeFile(target, new FileInputStream(file));
    ftp.disconnect();
  }

  //востанавливает исходный файл
  public void restore(String target, String backup) throws IOException {
    ftp.connect(app.getProperty("ftp.host"));
    ftp.login(app.getProperty("ftp.login"),app.getProperty("ftp.password"));
    ftp.deleteFile(target);
    ftp.rename(backup, target);
    ftp.disconnect();
  }

}

	
Помощник готов, теперь его нужно подлючить к АМ, т.е. вызвать конструктор. И сделать ленивую инициализацию


В АМ делаем метод


  public FtpHelper ftp() { //1 - создаем метод 
    if (ftp == null) { //3-если помощник не ицинилизирован, то инициализируем его
      ftp = new FtpHelper(this); //4-в качестве параметра передаем this т.е. ссылка на АМ
    }
    return ftp; //2-будет возвращать объект типа FtpHelper, только в том случае если объект уже инициализирован
  }

создаем поле, которое будет содержать ссылку на этого помощника 

public FtpHelper ftp;	
	
	
	
Рассмотрим помощник

Во первых при вызове помошника создается инициализация - клиент, который будет устанавливать соединения, передавать файлы и др действия.
Задача исходный конфигурационный файл нужно переименовать, добавить новый (поддлельный), а в конце удалить поддельный и вернуть на его место старый исходый.

  public FtpHelper(ApplicationManager app) {
    this.app = app;
    ftp = new FTPClient(); //создается клиент
  }	
	

/*метод будем вызывать в самом начале при инициализации тестируемой системы
метод принимает 3 параметра: 
file новый локальный файл, кот должен быть загружен на удаленную машину 
target имя удаленного файла (куда все загружается)
backup имя резервной копии (если удаленный файл уже существует)
*/
public void upload(File file, String target, String backup) throws IOException {
	//устанавливаем соединение с каким то сервером 
    ftp.connect(app.getProperty("ftp.host"));
	//выполняется логин
    ftp.login(app.getProperty("ftp.login"),app.getProperty("ftp.password"));
	//удаляем предыдущую резервную копию (на всякий случай)
    ftp.deleteFile(backup);
	//переименовываем удаленный файл - делаем резервную копию
    ftp.rename(target, backup);
	//включается пассивный режим передачи данных. Техническая манипуляция, связана с ограничениями ftp сервера 
    ftp.enterLocalPassiveMode();
	//самая главная строчку - здесь передается файл
	//локальный файл file из него делается InputStrea
	//FileInputStream предназначен для чтения бинарных даных - побайтовое чтение
	//эти данные читаются из локального файла, передаются на удаленную машину и там сохраняются в удаленном файле который называется target
    ftp.storeFile(target, new FileInputStream(file));
	//после того, как передача закончилась соединения разрывается
    ftp.disconnect();
  }



//в конце вызываем метод restore, который восстанавливает исходную конфигурацию тестируемой системы
  public void restore(String target, String backup) throws IOException {
    ftp.connect(app.getProperty("ftp.host"));
    ftp.login(app.getProperty("ftp.login"),app.getProperty("ftp.password"));
	//удаляется поддельный файл
    ftp.deleteFile(target);
	//востанавливается оригинальный файл из резервной копии 
    ftp.rename(backup, target);
    ftp.disconnect();
  }
	
	
Файл, который нужно загрузить на ftp сервер, называется config_inc.php	
В отличии от оригинального файла, он содержит строчку которая отключает капчу.	
	
<?php
$g_hostname      = 'localhost';
$g_db_type       = 'mysql';
$g_database_name = 'bugtracker';
$g_db_username   = 'mantisdbuser';
$g_db_password   = '';
$g_signup_use_captcha = 'OFF';
	
	
Для передачи файлов нужен ftp сервер. В XAMPP он называется FileZilla	

Наживаем Start > Admin чтобы создать пользователя, который будет использоваться в тестах
	
Оставляем по умолчанию
127.0.0.1
14147
	
Нажимаем кнопку Displays the user account dialog
Add new 
Называем его mantis
Указываем для него пароль mantis
Указываем для него домашнюю директорию Shared Folders
Выбираем пользователя mantis
Нажимаем кнопку Add в блоке Shared Folders
Указываем где находится наш багтреккер (корневую папку с mantis)
Указываем права на read, write, delete, append
Нажимаем Ок

Пользователь создан, теперь нужно прописать его свойства в конфиг файле. 

FtpHelper использует 3 свойства

Открываем файл свойств local.properties	

ftp.host = localhost 
ftp.login = mantis
ftp.password = mantis

Свойства готовы и осталось только где то вызвать эти методы. 
Надо сделать это в TestBase, 

  public void setUp() throws IOException {
    app.init();
	  app.ftp().upload(new File("src/test/resources/config.php"), "config.php", "config.php.bak");
  
  } 
	
А в конце, перед тем как останавливать приложение и вызывать метод stop нужно написать вызов метода restore	
	
public void tearDown() throws IOException {
    app.ftp().restore("config_inc.php.bak", "config.php");
    app.stop();
  }	


Запускаем тест в отладчика, установив точки остановы в методах connection() и start	
Смотрим на консоль ftp сервера 
Logged on //логин выполнен успешно
Transfer OK	//файл успешно загружен



}	
Урок 81. Получение почты на встроенный в тесты почтовый сервер {

Продолжаем делать тест для регистрации нового пользователя в багтреккере Mantis

Пользователь указывает имя, email нажимает кнопку Sign up после чего, ему на указаный email приходит письмо. 
Это письмо содержит ссылку, по которой необходимо пройти для того чтобы завершить регистрацию. Указать там пароль (на странице, открытой по ссылке) и после этого пользователь сможет войти в систему. 


Создадим класс HelperBase, который реализует все вспомогательные методы, в том числе метод для заполнения полей формы

public class HelperBase {

  protected ApplicationManager app; //вот эта ссылка 
  protected WebDriver driver;

  public HelperBase(ApplicationManager app) {
    this.app = app;
    this.driver = app.getDriver();
  }

  protected void click(By locator) {
    driver.findElement(locator).click();
  }


  protected void type(By locator, String text) {
    click(locator); //клик по полю ввода
    if (text != null) { //не вытается ввести значение которое заменит дефолтное  
      String existingText = driver.findElement(locator).getAttribute("value");
      if (! text.equals(existingText)) {//не вытается ввести текст, если он совпадает с существующим
        driver.findElement(locator).clear();
        driver.findElement(locator).sendKeys(text);
      }
    }
  }

  void attach(By locator, File file) {
    driver.findElement(locator).sendKeys(file.getAbsolutePath());
  }

}

Теперь напишем, что  
public class RegistrationHelper extends HelperBase

поэтому 

было 

public class RegistrationHelper extends HelperBase{
  private final ApplicationManager app;
  private WebDriver driver;

  public RegistrationHelper(ApplicationManager app) {
    this.app = app;
    driver = app.getDriver();
  }


  public void start(String username, String email) {
    driver.get(app.getProperty("web.baseUrl") + "/signup_page.php");

  }
}


стало

public class RegistrationHelper extends HelperBase {
  //private final ApplicationManager app; **поэтому хранить эту ссылку в классе RegistrationHelper уже необходимости нет , этим займется HelperBase ** 
  //private WebDriver driver; **аналогично 
	

  public RegistrationHelper(ApplicationManager app) {
    super(app); //вызов конструктора базового класса, туда передается ссылка на AM ** 
  }


  public void start(String username, String email) {
    driver.get(app.getProperty("web.baseUrl") + "/signup_page.php");

  }
  
  
}

Теперь реализуем заполнение полей имя и email


<input type="text" name="username" size="32" maxlength="32">
	
<input type="text" name="email" size="32" maxlength="64" value="">	

Пишем в методе start() в классе RegistrationHelper

public void start(String username, String email) {
    driver.get(app.getProperty("web.baseUrl") + "/signup_page.php");
	type(By.name("username"), username);
	type(By.name("email"), email);
  }

}

Находим локатор кнопки Sign up по атрибуту value

<input type="submit" class="button" value="Signup">

  click(By.cssSelector("input[value='Signup']")); //ищим элемент input у которого атрибут value="Signup"


Первая часть готова.
После того как эти действия выполненены, на указанный адрес электронной почты отправляется письмо. 

Куда оно придет? На каком почтовом сервере его искать?

Чтобы упростить решение этой задачи, мы можем сделать собственный почтовый сервер. 

В этом модуле мы запустим тестовый сервер, который встроен в тесты. 

Для этих целей будет использоваться помощник MailHelper

В нем будет использоваться библиотека 

compile  'org.subethamail:subethasmtp:3.1.7'
    
эта библиотека подлючила еще одну зависимость javax.mail (отдельно указывать в конфиг файле нет необходимости)

Подлючим помощник к АМ

Вновь реализуем механизм ленивой инициализации в АМ

  public MailHelper mail() {
    if (mailHelper == null){
      mailHelper = new MailHelper(this); //создаем поле в АМ ;  private MailHelper mailHelper;
    }
    return mailHelper;
  }

  
Возвращаемся к MailHelper

  public MailHelper(ApplicationManager app){
    this.app = app;
    wiser = new Wiser();//инициализация почтового сервера 
  }

Для того, чтобы запустить сервер нужно вызвать метод start() и остановить stop() 


  public void start() {
    wiser.start();
  }

  public void stop(){
    wiser.stop();
  }


Таким образом в тест RegistrationTests необходимо добавить некоторое действие, которые будет выполняться перед началом тестов и после того, как тест отработал. 


Для каждого тестового метода, можно запускать заного почтовый сервер. Для того, чтобы старая почта гарантировано пропадала, и не было никаких конфликтов / влияния одного теста на другой (при наличии разных тестов).


  @BeforeMethod
  public void startMailServer(){
    app.mail().start();
  }

  @Test
  public void testRegistration() {
    app.registration().start("user1" , "user1@localhost.localdomain");
  }


  @AfterMethod(alwaysRun = true)//для того, чтобы метод останавливал сервер даже, если тест завершился не успешно
  public void stopMailServer() {
    app.mail().stop();
  }
}

Теперь мы научились запускать поточвый сервер

Как mantis узнает, что почту надо доставлять именно сюда? 

Настроим тестируемую систему на наш почтовый сервер 
В конфигурационный файл багтреккреа config_inc.php нужно добавить 2 опции 

способ доставки почты по протоколу SMTP

$g_phpMailer_method = PHPMAILER_METHOD_SMTP;

адрес доставки почты 

$g_smtp_host = 'localhost';


Настроили, сервер запустили, теперь в него придет письмо. Но почта ходит не быстро, не мнгновенно.
Поэтому необходимо добавить ожидание - для этого предназначен метод waitForMail()

 public List<MailMessage> waitForMail(int count, long timeout) {
 //количество писем, которое должно прийти, время ожидания   


//если почта в течение этого времени не приходит то в конце выбрасывается исключение
//почты нет, точнее она есть но слишком мало; писем пришло меньше чем ожидалось < count 
 throw new Error("No mail :(");

 }
 
Как метод устроен внутри   

public List<MailMessage> waitForMail(int count, long timeout) {
	//запоминаем текущее время
    long start = System.currentTimeMillis();
	
	//в цикле проверяется, что время ожидания еще не истекло; новое текущее время не превышает момент старта + таймаут
	//нужно продолжать ждать почту 
    while (System.currentTimeMillis() < start + timeout) {
		//внутри проверяем, если почты пришло уже достаточно много
      if (wiser.getMessages().size() >= count) {
		  //значит ожидание множно прекращать - выполняется выход из этого метода 
		  
        return wiser.getMessages().stream().map((m) -> toModelMail(m)).collect(Collectors.toList());
      }
	  //если почты слишком мало, то проскакиваем проверку 
      try {
		  //попадаем сюда - ждем 1000 милисек 
		  
        Thread.sleep(1000);
		//и цикл повторяется - с while - снова смотрим, не истек ли таймаут 
		//и так до тек пор пока не придет достаточное количество писем, либо не закончится время ожидания 
		 
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
    throw new Error("No mail :(");
  }

Предположим что почты пришло достаточно много, тогда попадаем в строчку
eturn wiser.getMessages().stream().map((m) -> toModelMail(m)).collect(Collectors.toList());

В которой происходит преобразование реальных объектов в модельные. 
Модельными объектами легко оперировать, которые содержат нужную нам инфо и не зависят от деталей реализации

Разные почтовые сервера могут использовать разный формат представления почты, поэтому мы делаем свой собственный модальный объект, который содержит два интересующих нас поля. 

package ru.stqa.pft.mantis.model;

public class MailMessage {
  public String to; //кому пришло письмо
  public String text; //текст этого письма
  
  public MailMessage(String to, String text) {
    this.to = to;
    this.text = text;
  }
}


Соответственно в помощнике нужно реальные объекты , которые храняться в реальном почтовом ящике на реальном почтовом сервере преобразовать в модальные.

Мы берем список, превращаем в поток, ко всем элементам потока применяем одну и туже функцию, и потом получившиеся новые модельные объекты собирираем снова в список. 

Рассмотрим подробнее, как происходит преобразование реальных почтовых сообщений в наши модельные.   

  private static MailMessage toModelMail(WiserMessage m) {
    try {
		//берем реальный объект 
      MimeMessage mm = m.getMimeMessage();
	  //Во-первых, берем список получателей, и оставляем только первого из них, потому что известно что он там единственный
	  //mantis отправляет два письма первое администратору, о том что зарегистрировался новый пользователь
	  //второе пользователю, в котором содержится ссылка для продолжения регистрации 
	  //Во вторых, так как письмо тестовое, то объект Content представляет собой обычную строку 
	  //поэтому мы его преобразуем в строку 
	  //получившеся значение попадает в объект типа MailMessage
      return new MailMessage(mm.getAllRecipients()[0].toString(), (String) mm.getContent());
	  //оставшаяся часть метода - это перехват каких-то ошибок (создается при помощи среды разработки)
    } catch (MessagingException e) {
      e.printStackTrace();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return null;
  }

Она очень простая, потому что в нашем примере точно известно что mantis точно присылает письма в обычном текстовом формате. 
Но в реальной жизни в ней могут быть картинки, текст в формате HTML, attachments. Поэтому анализ письма штука достаточно сложная. 


Возвращается в RegistrationTests


  @Test
  public void testRegistration() {
    app.registration().start("user1" , "user1@localhost.localdomain");
	//добавляем ожидание
	//app.mail().waitForMail(2,10000);
	//присваиваем возвращаемое значение waitForMail() в какую то переменную 
	List<MailMessage> mailMessages = app.mail().waitForMail(2, 10000); 
  }

Теперь среди этих писем нужно найти то которое, пришло этому пользователю user1@localhost.localdomain
И извлечь из письма ссылку для продолжения регистрации


Организуем рефакторинг 

было 
public class RegistrationTests extends TestBase{



  @BeforeMethod
  public void startMailServer(){
    app.mail().start();
  }

  @Test
  public void testRegistration() {
    app.registration().start("user1" , "user1@localhost.localdomain"); //"user1@localhost.localdomain" ПКМ > Refactor > Extrackt > Variable 
    List<MailMessage> mailMessages = app.mail().waitForMail(2, 10000);
  }

  

  @AfterMethod(alwaysRun = true)
  public void stopMailServer() {
    app.mail().stop();
  }
}

стало

 @Test
  public void testRegistration() {
    String email = "user1@localhost.localdomain";
    String user1 = "user1";
    app.registration().start(user1, email);
    List<MailMessage> mailMessages = app.mail().waitForMail(2, 10000);
    findConformationLink(mailMessages, email);
  }


Создали метод findConformationLink(), в который будут передаваться список писем и адрес электронной почты 
Среди всех писем нужно найти то, которое отправлено на этот адрес и извлечь из него ссылку. 

private String findConformationLink(List<MailMessage> mailMessages, String email) {
    //сначала нужно найти среди всех писем то, которое отправлено на нужный адрес
    MailMessage mailMessage = mailMessages.stream().filter((m) -> m.to.equals(email)).findFirst().get();
  }
Используем функцию filter(), в которую в качестве параметра передается предикат ( т.е. функция возвращающая булевское значение) 
На входе она будет принимать объект типа MailMessage и выполнять проверку (m) -> m.to.equals(email)
В результате фильтрации в потоке останутся только те сообщения, которые отправлены по нужному адресу.
Дальше среди них берем первое findFirst().get()
Возвращаемое значение цепочки помещаем в локальную переменную

	//теперь нужно из текста этого сообщения извлечь ссылку
	
Для этого нам пригодились бы регулярные выражения.
Можно воспользоваться вспомогательной библиотекой verbalregex, с помощью которой можно строить регулярные выражения. 

compile  'ru.lanwen.verbalregex:java-verbal-expressions:1.4'

VerbalExpression regex = VerbalExpression.regex().find("http://").nonSpace().oneOrMore().build();

Сначала ищим такой текст
VerbalExpression regex = VerbalExpression.regex().find("http://")

После него должно идти какое то количество непробельных символов 
nonSpace()

Сколько 
oneOrMore()

Результатом является объект типа VerbalExpression, который внутри содержит построенное регулярное выражение 

Здесь мы видим использование флуент интерфейса, точнее шаблона проектирование билдер - объект строится путем последовательного применения цепочки методов.

Теперь нужно это регулярное выражение применять к тексту нашего письма и получившеся значение вернуть.

regex.getText() возвращает тот кусок текста, который соответствует построенному регулярному выражению 

Получаем,

  private String findConformationLink(List<MailMessage> mailMessages, String email) {
    //сначала нужно найти среди всех писем то, которое отправлено на нужный адрес
    MailMessage mailMessage = mailMessages.stream().filter((m) -> m.to.equals(email)).findFirst().get();
    VerbalExpression regex = VerbalExpression.regex().find("http://").nonSpace().oneOrMore().build();
    return regex.getText(mailMessage.text);
  }

Присваиваем получившуюся ссылку в какуюто локальную переменную 

findConformationLink(mailMessages, email) 

String conformationLink = findConformationLink(mailMessages, email);

И завершаем регистрацию 

app.registration().finish(conformationLink, "password"); //в качестве параметра указываем ссылку и пароль 

Создадим метод finish() внтури RegistrationHelper


 public void finish(String conformationLink, String password) {
	 //проходим по ссылке
    wd.get(conformationLink);
	//вводим пароль 
    type(By.name("password"), password);
	//вводим подтверждение пароля
    type(By.name("password_conform"), password);
	click(By.cssSelector("input[value='Update User']"));
  }

Тем самым регистрация пользователя завершается 

Нужно проверить, действительно ли он может войти в систему

RegistrationTest должен в конце содержать какую то проверку

Реализуем проверку с помощью помощника - по протоколу http

app.newSession().login(user, password);


и добавляем проверку 


assertTrue(app.newSession().login(user, password));


Получаем, 


  @Test
  public void testRegistration() throws IOException {
    String user = "user1";
    String password = "password";
    String email = "user1@localhost.localdomain";
    app.registration().start(user, email); //сюда ставим точку остановы 
    List<MailMessage> mailMessages = app.mail().waitForMail(2, 10000);
    String conformationLink = findConformationLink(mailMessages, email);
    app.registration().finish(conformationLink, password);
    assertTrue(app.newSession().login(user, password));
  }

Тест готов, запускаем.

Сначала запускается почтовый сервер
Отправляется конфигурационный файл по протоколу ftp 
И наконец, мы находимся в точке, в кототорой должен запустится бразузер и в нем должны выполниться какие то действия

app.registration().start(user, email); //сюда ставим точку остановы 
Шаг вперед , на запуск браузера уходит достаточно много времени

Появляется бразузер, заполняются поля, нажимается кнопка signup 
И видим сообщение, в котором сказано что на адрес электронной почты указанный при регистрации отправлено письмо 

Возвращаемся в отладчик, нас интересуют пришли ли письма

Нажимаем ПКМ по app

List<MailMessage> mailMessages = app.mail().waitForMail(2, 10000);

Нажимаем Evaluate и смотрим что находится в переменной mailHelper

В объекте wiser два письма - одно админу, другое пользователю 

Нажимаем next

mailMessage size = 2 
conformationLink = "" //извлечен из письма

Еще шаг вперед и в браузере завершается регистрация, произошло перенаправление на главную страницу  

Выполняется проверка, что пользователь может войти в систему

Тест зеленый

Подлючим библиотеку logback

Если запустить тест второй раз, то он упадет, потому что пользователь с таким же имененем и почтой зарегистрироваться не может  
"That username is already being used. Please go back and select another one."

Поэтому необходимо изменить тесты, так чтобы каждый раз регистрировались новые пользователи 

Создадим уникальные идентификаторы для пользователей.

Например, 

long now = System.currentTimeMillis();

Функция возвращает текущее время в милисекундах


 public void testRegistration() throws IOException {
    long now = System.currentTimeMillis();
    String user = String.format("user%s",now);
    String password = String.format("password",now);
    String email = String.format("user%s@localhost.localdomain", now);;

	
	
	
	ДЗ
	
1. Создаем нового пользователя в ручную. Указываем логин, пароль, адрес
2. Админ выбирает указанного пользователя. 
Например, в поле Search вводит имя пользователя и нажимает кнопку manage user
3. Нажимает кнопку Reset Password на открывшейся странице 
4. На адрес ушло письмо.
5. wiser получил письма, нашел ссылку и передал ее драйверу


Received: from localhost ([0:0:0:0:0:0:0:1])
        by kobzev.enterra.ln
        with SMTP (SubEthaSMTP 3.1.7) id JTIKWRCF
        for user1@localhost.localdomain;
        Thu, 21 Mar 2019 18:55:17 +0700 (GMT+07:00)
Date: Thu, 21 Mar 2019 12:55:17 +0100
Return-Path: <admin@example.com>
To: user1@localhost.localdomain
From: Mantis Bug Tracker <noreply@example.com>
Subject: [MantisBT] Password Reset
Message-ID: <77ef415a566ddb0630692ccb0c2bf581@localhost>
X-Priority: 3
X-Mailer: PHPMailer 5.2.6 (https://github.com/PHPMailer/PHPMailer/)
Auto-Submitted: auto-generated
X-Auto-Response-Suppress: All
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain; charset=utf-8


Someone (presumably you) requested a password change through e-mail
verification. If this was not you, ignore this message and nothing will happen.

If you requested this verification, visit the following URL to change your
password: 

http://localhost/mantisbt-1.2.19/verify.php?id=3&confirm_hash=e5b905ff88f4cc6905f073bcb47aec46


Username: user1 
Remote IP address: ::1 

Do not reply to this message


6. Драйвер прошел по ссылке, 
открылась страница с залогиненным пользователем

http://localhost/mantisbt-1.2.19/verify.php?id=3&confirm_hash=e5b905ff88f4cc6905f073bcb47aec46

нужно ввести новый пароль в поле

<input type="password" size="32" maxlength="1024" name="password">


и подтвердить пароль в поле

<input type="password" size="32" maxlength="1024" name="password_confirm">

нажать кнопку 

<input type="submit" class="button" value="Update User">


через некоторое время просиходит пререход на страницу с логином

http://localhost/mantisbt-1.2.19/login_page.php?return=%2Fmantisbt-1.2.19%2Faccount_page.php

6. На странице с логином вводим username и новый пароль и нажимаем кнопку логин

7. Проверяем имя пользователя с помощью httpHelper

 }
Урок 82. Telnet Выполнение команд {
	
	
Способ, при котором почтовый сервер встроен в тест, хорош если есть персональный тестовый стенд.
Заменяем конфиг файл, почта идет на вашу машину, где работают тесты, и все ок, это никому не мешает.

Но в ситуации когда тестовым стендом пользуются много тестировщиков, менять конфиг файл не очень удобно.

Тогда нужно использователь общий почтовый сервер

Рассмотрим на примере внешнего почтового сервера James

http://archive.apache.org/dist/james/server/james-binary-2.3.1.zip
	
Он реализует такие протоколы как 

SMTP (то есть на него можно отправлять почту)

POP3 (по этому протоколу будем получать почту)

Скачиваем и помещаем в папку c:\Tools\james-2.3.1\ 	
Запускаем консоль в папке c:\Tools\james-2.3.1\bin\
Выполням команду 
run.bat

Получаем сообщение о том, что сервер запущен

Phoenix 4.2

James Mail Server 2.3.1
Remote Manager Service started plain: 4555 //специальный протокол для удаленного управления
POP3
SMTP

Можно установить соединение на порт 4555 по протоколу TELNET и отдавать команды этому почтоому серверу

запустим отдельную консоль и попробуем это сделать
telnet localhost 4555
Login
root
Password
root

Теперь ему можно отдавать какие то команды, 


в частности 


listusers

создать нового пользователя
удалить существующего пользователя
поменять пароль и тп

Останавливаем сессию
quit


Сделаем это в автотестах. Перед тем как создавать нового пользователя в багтрекере мантис тест должен сначала создать пользователя на почтовом сервере а потом указать его адрес при регистрации.

Затем у этого созданного пользователя забрать почту и дальше извлечь от туда ссылку и прололжить регистрации 

Создадим помощник JamesHelper, который будет решать эти задачи

-умеет ходить по протоколу telnet на почтовый сервер и создавать там пользователей
-умеет получать почту по протоколу POP3




Подключим его к АМ
	
public JamesHelper james() {
    if (jamesHelper == null) {
      jamesHelper = new JamesHelper(this);
    }
    return james();
  }
	
Вернемся обратно в тесты RegestrationTest

Так как мы собираемся использовать не встроенный почтовый сервер, а отдельно стоящий - внешний

То нужно откоючить методы инициализации и завершения

//@BeforeMethod

//@AfterMethod(alwaysRun = true)


Теперь вносим изменения в сам тест 

Перед тем как начинать регистрацию пользователя нужно сначала создать его на почтовом серевере

Так как префик и имя пользователя совпадают, значит почта будет доставляться будет именно этому пользователю
user%s@localhost.localdomain
user


письмо будет получать из внешнего почтового сервера


//указываем время ожидания больше. потому что на внешний почновый сервер почта идет дольше



public class RegistrationTests extends TestBase{

  //@BeforeMethod
  public void startMailServer(){
    app.mail().start();
  }

  @Test
  public void testRegistration() throws IOException {
    long now = System.currentTimeMillis();
    String user = String.format("user%s",now);
    String password = String.format("password",now);
    String email = String.format("user%s@localhost.localdomain", now);
    app.james().createUser(user, password); //добавили пользовател на почтовом сервере
    app.registration().start(user, email);
    //List<MailMessage> mailMessages = app.mail().waitForMail(2, 10000);
    List<MailMessage> mailMessages = app.james().waitForMail(user, password, 60000);//изменили способ получения почты
    String conformationLink = findConformationLink(mailMessages, email);
    app.registration().finish(conformationLink, password);
    assertTrue(app.newSession().login(user, password));
  }

  public static String findConformationLink(List<MailMessage> mailMessages, String email) {
    MailMessage mailMessage = mailMessages.stream().filter((m) -> m.to.equals(email)).findFirst().get();
    VerbalExpression regex = VerbalExpression.regex().find("http://").nonSpace().oneOrMore().build();
    return regex.getText(mailMessage.text);
  }



  //@AfterMethod(alwaysRun = true)
  public void stopMailServer() {
    app.mail().stop();
  }
}


Можно это унифицировать, сделать параметр запуска, который определяет какой почтовый сервер использовать - встроенный или внешний. 


Теперь рассмотрим подробнее JamesHelper


Сначала посмотрим как он создает пользователя

Для этого используется TelnetClient, который является частью библиотека commons-net

При инициализации JamesHelpera создается telnetClient


public JamesHelper(ApplicationManager app){
    this.app = app;
    telnet = new TelnetClient();
    mailSession = Session.getDefaultInstance(System.getProperties())
  }
  
  
Смотрим как вышлядит метод createUser(), при помощи которого создается новый пользователь

  public void createUser(String name, String password) {
	//устанавливается соединение по протоколу telnet
    initTelnetSession();
	//вводим команду
    write("adduser " + name + password);
    //ждем до тех пор пока на консоли не появится указанный текст 
	String result = readUntil("User " + name + " added");
	//разрываем соединени
    closeTelnetSession();
  }


Вся сложность, все технические детали спрятаны внутрь этих вспомогательных методов.



Добавим в конф файл информацию о пользователе, от имени которого будет создаваться обычные пользователи 
а они уже будут входить в систему со своим логином и паролем. Но для создания нужен прилигированный пользователь.


Чтобы установить соединение нужно получить инфо из конфигурационного файла

mailserver.host = localhost
mailserver.port = 4555
mailserver.adminlogin = root
mailserver.adminpassword = root
 
 private void initTelnetSession() {
	 //получили свойства из конф файла
    mailServer = app.getProperty("mailserver.host");
    int port = Integer.parseInt(app.getProperty("mailserver.port"))
    String login = app.getProperty("mailserver.adminlogin");
    String password = app.getProperty("mailserver.adminpassword");
	
	/начинается основная часть
    try {
	  //устанавливаем соединение с почтовым сервером
      telnet.connect(mailServer, port);
	  //после того, как соединение установлено берем у него входной поток
	  //входной используется для чтения данных, который телнет клиент отправляет нам
      in = telnet.getInputStream();
	  //выходной поток писать, чтобы отправлять ему команды
      out = new PrintStream(telnet.getOutputStream());

    } catch (IOException e) {
      e.printStackTrace();
    }
	//чтение и запись производится при помощи методов readUntil() и write()
	//по сути описывается взаимодействие тот текст который пишет нам сервер, и тот текст , который мы ему отправляемся
	
	
	
    //It doesn't allow login at the first attempt
	//дождаться когда на консоли напишется что-то
    readUntil("Loggin id:");
	//написать туда что то 
    write("");
    readUntil("Password:");
    write("");

    //Second login attempt, must be successful
    readUntil("Loggin id:");
    write(login);
    readUntil("Password:");
    write(password);

    //Read welcome message
    readUntil("Welcome " + login + " . HELP for a list of commands");

  }
	
	
  }

	
Далее посмотрим как происходит чтение
Чтение это достаточно сложная функция
Посимвольно читаются данные из входного потока, то есть то что выводит на консоль сервер, и сравнивается с заданным шалоном.
Как только прочитан флагмент, который соответствует этому шаблону, ожидание завершается. Считается что нужные данные прочитаны. 



  private String readUntil(String pattern) {
    try {
      char lastChar = pattern.charAt(pattern.length());
      StringBuffer sb = new StringBuffer();
      char ch = (char) in.read();
      while (true) {
        System.out.println(ch);
        sb.append(ch);
        if (ch == lastChar) {
          if (sb.toString().endsWith(pattern)) {
            return sb.toString();
          }
        }
        ch = (char) in.read();
      }
      } catch(IOException e){
        e.printStackTrace();
      }
    return null;
    }
	
	Метод write() проще
	
private void write(String value) {
    out.println(value);
    out.flush();
    System.out.println(value);
  }
	
	
		//отправка команды выход
 private void closeTelnetSession() {
    write("quit");
  }	
	
Выглядит достаточно сложно, такой низкоуровневый код потому что протокол telnet сам по себе достаточно низкоуровневый.


Дополнительные методы, которые в тестах не используется. 

Метод для проверки существования пользователя

 public boolean doesUserExist(String name) {
    initTelnetSession();
    write("verify " + name);
    String result = readUntil("exist");
    closeTelnetSession();
    return result.trim().equals("User " + name + "exist");
  }
  
Метод для удаления пользователя	
	
	
	 public void deleteUser(String name){
    initTelnetSession();
    write("deluser " + name);
    String result = readUntil("User " + name + " deleted");
    closeTelnetSession();
    }
	
	
Вторая часть - как тест читает почту

В самом начале, в конструкторе 	создается почтовая сессия. Для этого используется класс session, находящийся в пакете javax.mail.Session;
	
	
 public JamesHelper(ApplicationManager app) {
    this.app = app;
    telnet = new TelnetClient();
    mailSession = Session.getDefaultInstance(System.getProperties()); 
  }	
	
	
Реализация метода waitForMail()

Так как в этом методе нам нужно ждать в течение некторого времени, поступаем как раньше


public List<MailMessage> waitForMail(String username, String password, long timeout) throws MessagingException {
	//запоминаем момент начала ожидания 
    long now = System.currentTimeMillis(); 
	//цикл, в котором проверяется что текущее время не превышает момента страрта + заданный тайм аут 
    while (System.currentTimeMillis() < now + timeout) {
		//пытаемся получить всю почту 
      List<MailMessage> allMail = getAllMail(username, password);
	  //если есть хотя бы одно письмо, возвращаем список писем
      if (allMail.size() > 0) {
        return allMail;
      }
	  //если почты нет, тогда ждем 1 секунду и идем на второй заход - снова проверяем содержимое почтового ящика 
      try {
        Thread.sleep(1000);
      }catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
	//если время истекло, значит выходим из цикла и выбрасывается исключение 
    throw  new Error ("No mail :(");
  }	
	
Рассмотрим метод getAllMail(), который извлекает сообщения из почтового ящика и превращает их в модельные объекты типа MailMessage (наш собственный класс)

  private List<MailMessage> getAllMail(String username, String password) throws MessagingException {
	  //нужно в начале открывать почтовый ящик - залогиниться
    Folder inbox = openInbox(username, password);
	//Берем список писем, превращаем в поток, применяем функцию, которая превращается их в модельные объекты, собираем объекты обратно в список и возвращаем этот список
    List<MailMessage> messages = Arrays.asList(inbox.getMessages()).stream().map((m) -> toModelMail(m)).collect(Collectors.toList());
    //в конце закрывать почтовый ящик , закрыть сессию 
	closeFolder(inbox);
	//полученная почта, в конечном итоге возвращается в тесты 
    return messages;
  }
  
Потому что правила работы с почтовым протоколом, POP3 который используется для получения почты требует выполнения этих действий.   

Рассмотрим метод toMailModel(), который преобразовывает реальные письма в наши модельные 


  private MailMessage toModelMail(Message m) {
    try {
		//получаем список адресов, берем первый адрес, получаем содержимое письма, преобразуем в строку 
		//по полученным данным строим модельный объект 
      return new MailMessage(m.getAllRecipients()[0].toString(), (String) m.getContent());
    } catch (MessagingException e) {
      e.printStackTrace();
      return null;
    } catch (IOException e) {
      e.printStackTrace();
      return null;
    }
  }

Рассмотрим метод openInbox()


  private Folder openInbox(String username, String password) throws MessagingException {
    //берем почтовую сессию , которая была создана еще в конструкторе при создании этого помощника 
	//сообщаем что хотим использовать протокло pop3 для доступа к хранилищу почты
	store = mailSession.getStore("pop3");
	//устанавливаем соединение
    store.connect(mailserver, username, password);
	//получаем доступ к папке входящих писем. по протоколу pop3 можно получить доступ только к ней
    Folder folder = store.getDefaultFolder().getFolder("INBOX");
	//открываем папку на чтение
    folder.open(Folder.READ_WRITE);
	//открытая папка возвращается в метод getAllMail() для того чтобы в конце ее закрыть 
    return folder;
  }



Рассмотри метод closeFolder()

  private void closeFolder(Folder folder) throws MessagingException {
	  //параметр true означает что нужно удалить все письма , помеченные к удалению DELETED
	  //мы этого не делали, но какой то параметр туда передать надо, можно true 
    folder.close(true);
    store.close();
  }

Есть еще полезный метод, который не используется в наших тестах, потому что всегда создается уникальный пользователь 
Этот метод позволяет удалить все письма которые получены каким что пользователем, очистить его почтовый ящик 
Если вы хотиле многократно использовать один и тотже почтовый ящик

  public void drainEmail(String username, String password) throws MessagingException {
    Folder inbox = openInbox(username, password);
    for (Message message : inbox.getMessages()) {
		//каждое сообщение помечается специальным флагом
      message.setFlag(Flags.Flag.DELETED, true);
    }
	//при закрытии папки, благодаря тому что в методе closeFolder() указывался параметр .close(true), все помещеченные письма будут удалены
    closeFolder(inbox);
  }

Запускаем тест
На консоль выводятся сообщения 

Это сеанс взаимодействия с почтовым сервером по протоколу telnet, там все сообщения выподятся на консоль

-сообщение что пользователь добавлен
-запускается бразуер
-уходит письмо 
-тесты ждут, пока письмо будет доставлено на почтовый сервер 
-письмо приходит, регистрация завершается 
-тест зеленый	
	
	
	
}
Занятие 9.Сетевое программирование - удалённые программные интерфейсы
Урок 83. Немного теории про Remote API {
	
API - механизм взаимодействия программ друг с другом или компонентов в рамках одной программы друг с другую

Программный компонент предоставляет другим программным компонентам функции. В эти функции можно передавать какие то данные. Эти данные должны иметь определененую структуру.
Вот это описание типов, форматов, структуры данных, описания набора функций представляет собой программный интерфейс т.е. внешний интерфейс какого то программного компонента.

В нашем проекте SandBox есть класс Square, который содержит описание структуры данных: 
во первых этот класс имеет один атрибут 	

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ 
        return this.l * this.l;
    }
}

во вторых описание функций -  можно вычислять площадь квадрата, обратившись к функции area()

И например, другой программый компонент, например test, может обращаться к этому классу и создавать объекты такого типа, вызывать в них методы

public class SquareTests {

  @Test
  public void testArea(){
    Square s = new Square(5);
    Assert.assertEquals(s.area(),25.0) ;
  }
}

То есть тест взаимодействует с тестируемой системой через программный интерфейс.
И никакого другого способа взаимодействия программных компонентов друг с другом не существует.

Однако, на прошлом занятии мы говорили про сетевые протоколы. 
Да, с технической точки зрения там все гораздо сложнее. Это не просто подлючили какую то бибилиотеку и она тут же загрузилась в память и можно пользоваться ее функциями. 
Происходит взаимодействие по сети. Части с короторыми происходит взаимодействие могут находиться на другой машине. Но если посмотреть на это с точки зрения клиента. Как мы отправляем данные по сети?

Подключаем библиотеку, при помощи этой бибилиотеки формируем запросы, отправляем запросы, и они куда то уходят по сети
Но при этом мы все равно работаем с программным интерфейсом, есть какая то библиотека, которая предоставляет программный интерфейс к этому сетевому протоколу. 
Другая библиотека предоставляет программный интерфейс по протоколу ftp, и тд

Взаимодействие с браузером, с технической точки зрения, тоже осуществляется по сети. Но мы об этом ничего не знаем, не знаем как работает браузер внутри , не знаем как конкретно библиотека selenium взаимодействует с браузером. Потому что мы пользуемся программным интерфейсом. 
Библотека selenium предоставляет программный интерфейс для управления браузером. Драйвер базы данных предоставляет программный интерфейс для того чтобы выполнять запросы для базы данных. 
И всегда мы работаем с каким то программным интерфейсом, который внутри себя может скрывать достаточно сложные механизмы. ПОтому что никакого другого способа взаимодействия программ друг с другом не существует.

Программные интерфейсы бывают разные

Когда мы работаем в классе squaretest с квадратами, мы напрямую создаем объект типа квадрат. Т.е. мы работаем с логическими объектами -  объектами предметной области (оперируем квадратами, кругами и тп) Программный интерфейс описывает непосредственно геометрические фигуры. 

А что происходит когда мы работаем с браузером? В этом случае мы можем оперировать приметивными объектами, которые представлены в бразуере. То есть элементами веб страницы. Они с технической точки зрения все одинаковые и представляются объектом типа WebElement
Но нам это неудобно, потому что мы хотим в адресной книги работать с такими объектами как GroupData, ContactData. Т.е. с объектами, которые предствляют объекты логические. 
Поэтому мы делаем специальный помощник, который из простых объектов типа WebElement строят сложные объекты типа GroupData или ContactData. 
И далее уже оперируем этими сложными объектами.
То есть мы над простым программным интерфейсом, надстраиваем свой более сложный программный интерфейс. 
И можно говорить, что набор помощников который мы создаем. Это программный интерфейс для работы с приложением, который позволяет нам оперировать такими сущностями как группы и контакты. 
Это уже более высокоуровневый программный интерфейс. Веб элементы - это низкоуровневый, модельные объекты - высокоуровневый программный интерфейс	
	
Точно такая же ситуация возникает, если мы работаем не с браузером а с сетью. Мы отправляем запросы, например по протоколу http , и оперируем понятиями запрос , параметр запроса. это низкоуровневый интерфейс. 
Но для того, чтобы писать красивые понятные тесты - например для багтрекера мантис, в тестах было бы гораздо удобнее и проще оперировать модельными объектами, такими как проект, пользователь, багрепорт. 
И в этом случае помощник, который взаимодействует по сети с сервером использует для этого термины протокола http, должен был преобразовывать все это в модельные объекты или наоборот, из модельных объектов при отправке данных переводить все это на язык протокола http

И если мы делаем такой помощник. например для работы с проектами в багтрекере mantis, который позволяет нам опрерировать терминами создать изменить, удалить проект а сам внутри переводит все это на язык сетевого протокола, на какойто низкоуровневый программный интерфейс. 

Эти технические детали от нас скрываются, нам кажется что мы напрямую работаем с багтрекером, с объектами типа проект, багрепорт, пользователь. 
А на самом деле мы работаем лишь с их представителями. А реальное взаимодействие с тестируемой системой происходит по сети - по сетевому протоколу.  

В этом состоит сущность удаленого программного интерфейса. 
Система, с которой мы взаимодействуем находится где то далеко. Взаимодействовать с ней напрямую мы не можем, только по какому то сетевому протоколу, но мы не хотим работать с каким то низкоуровневым интерфейсом. Хотим работать с логическим объектами. 

Для этого мы создаем программный интерфейс высокоуровневый, который все эти технические детали скрывает внутри. Возникает удаленный программный интерфейс.

	
И самая главное - что многие системы сразу предоставляют такие удаленные программные интерфейсы. 
Т.е. нам самим не надо реализовывать. Не нужно заниматься созданием модельных объектов, преобразованием этих модальных объектов на уровень сетевого протокола, отправки запросов. Все это уже есть либо может быть легко сгенерировано из описания.


Два наиболее широко распостраненных типа удаленных программных интерфейсов это SOAP и REST 
	
SOAP в первую очередь ориентирован на язык XML

Мы работаем с каким то модельным объектом, который является представителем сущности физически находящийся где то на удаленной машине. И для того, чтобы вызвать какую то функцию, мы обращаемся к этому модельному объекту.
И в тот момент, когда функция вызывается, этот представитель (он сам ничего сделать не может, потому что все реальные данные хранятся где то на удаленной машине) формирует запрос в формате XML, например 

<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:m="http://www.example.org">
  <soap:Header>
  </soap:Header>
  <soap:Body>
    <m:GetStockPrice>
      <m:StockName>GOOG</m:StockName> //запрос предназначен чтобы отправить одну строку GOOG на удаленную машину
    </m:GetStockPrice>
  </soap:Body>
</soap:Envelope>


И по сети, по протоколу http отправляет это на удаленную машиную. Затем получает от туда ответ в формате XML, распаковывает его, преобразовывает его в какой то новый модельный объект и возвращает.

Нам кажется, что мы работаем с функциями, с объектами. А реально, где то внутри происходит взаимодействие по протоколу http с удаленной машиной.  

Но часто язык XML подвергается критики, из-за того что он сложный.   
	
Поэтому был придуман альтернативный подход (стиль, способ, тип) - REST 

//программы предоставляли удаленный доступ, удаленный программный интерфейс. 	
	
Стандарные операции с объектами
CREATE
READ
UPDATE
DELETE
	
Этип операциям в протоколе http соответствуют запросы типа	
	
GET - используются для того, чтобы прочитать / посмотреть значение какого то объекта
POST - используются для модификации, изменения объекта. При этом передаются новые данные, которые должны быть записаны в этот объект.
PUT - используются для создание объектов
DELETE - используются для удаления 

При этом идентификатор того объекта, с которым мы работаем (который хотим прочитать / изменить / удалить) передается непосредственно в адресе запроса, в отличии от SOAP, где он запрятан внутри запроса.

Мы говорим, что каждный объект имеет уникальный адрес - конечно только с логической точки зрения. Никакого физического адреса у удаленного объекта нет. 

Важно отметить, что когда мы выполняем запрос, позволяющий получить информацию объекте, эта информация должна быть представлена в каком то структурированном виде. И здесь тоже может использоваться язык XML, но вместе с тем, в отличии от SOAP, формат представления данных может быть другим.
Поэтому часто используется более простой формат - JSON

Например, мы выполняем GET запрос, передаем в адресе идентификатор удаленного объекта и в ответ получаем текст, в формате JSON, который содержит информацию об этом объекте. 


	
}
Урок 84. SOAP - простой пример {

Программные компоненты, которые предосталяют удаленный программный интерфейс, называют сервисами или удаленными сервисами.

Взаимодейсвие с таким удаленным сервисом по технологии SOAP рассмотрим на простом примере.

Создадим новый модуль soap-sample 

Поместим туда

build
gradle
build.gradle
gradlew
gradlew.bat

Теперь можно импортировать модуль

Project Structure > Import module > Use auto import

Через некоторое время модуль подключен

Редактируем build.gradle

apply plugin: 'java'


repositories {
    mavenCentral()
}


dependencies {
    implementation 'org.testng:testng:6.14.3'
    
}

Откроем тестируемое приложение
http://webservicex.net

http://www.webservicex.net/geoipservice.asmx?WDSL

На нем собрано некоторое количество сервисов, предоставляющих удаленный программный интерфейс по технологии SOAP 

С точки зрения сетевого протокла отправляется запрос

POST /ipservice.asmx HTTP/1.1
Host: wsgeoip.lavasoft.com
Content-Type: text/xml; charset=utf-8
Content-Length: length
SOAPAction: "http://lavasoft.com/GetIpLocation"

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetIpLocation xmlns="http://lavasoft.com/">
      <sIp>string</sIp>
    </GetIpLocation>
  </soap:Body>
</soap:Envelope>


и приходит ответ

<Geo Ip>
<ReturnCode>
<IP>
<ReturnCodeDetails>
<CountryName>
<ContryCode>


Но мы такие запрос отправлять не будем. Наша цель научится пользоваться удаленным программным интерфейсом, а не работать на уровне сетевого протокола.

Как из описания сервиса в формате wsdl автоматически сгенерировать код на java, который предоставляет удаленный програмный интерфейс к этому сервису.  

Сейчас нас будет интересовать адрес


http://www.webservice.net/geoipservice.asmx?WSDL

Он содержит описани программного интерфейса в специальном формате WSDL ()
Сохраняем файл внутрь нашего проекта resouses
Называем файл geoservice.wsdl тип web page xml only

Теперь по этому описанию можно сгенерировать код на языке java, который будет использоваться для удаленого взаимодействия с этим сервисом

Для этого открываем конф файл и подключаем плагин

Копируем фрагмент из 

https://github.com/nilsmagnus/wsdl2java

buildscript{
    repositories{
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath 'no.nils:wsdl2java:0.10'
    }
}
apply plugin: 'no.nils.wsdl2java'


Копируем пример 

wsdl2java {
    generatedWsdlDir = file("my-generated-sources")  // target directory for generated source coude
    wsdlDir = file("src/main/resources/myWsdlFiles") // define to support incremental build
    wsdlsToGenerate = [   //  2d-array of wsdls and cxf-parameters
                ['src/main/resources/wsdl/firstwsdl.wsdl'],
                ['-xjc','-b','bindingfile.xml','src/main/resources/wsdl/secondwsdl.wsdl']
        ]
    locale = Locale.GERMANY
}

Меняем под свой собвстенный проект 


wsdl2java {
    generatedWsdlDir = file("src/main/java")  // куда именно будут помещены файлы java, которые генерируются из описания*** 
    wsdlDir = file("src/main/resources") // вспомогательная директория где генератор может хранить какие то файлы
    wsdlsToGenerate = [   //  2d-array of wsdls and cxf-parameters
                ['src/main/resources/wsdl/geoipservice.wsdl'],
        ]

}
 
***а тесты которые будут использовать этот программный интерфейс поместим в src /test/java


теперь запускаем консоль в подкаталоге 
c:\Users\kobzev\Documents\GitHub\java_test\soap-sample\

выполняем команду

gradlew wsdl2java

должен сгененироваться код, состоящий из множества классов


Теперь этим кодом можно пользоваться, делаем тест 


package ru.stqa.pft.soap;

import org.testng.annotations.Test;

public class GeoIpServiceTests {

  @Test
  public void testMyIp() {
	//создаем объект типа GeoIpService()
	//в нем выбираем тип реализации 
	//вызываем функцию, вместо параметра передаем свой ip 
	//результат сохраняем в переменную типа GeoIP
	GeoIP geoIP = new GeoIpService().getGeoIPServiceSoap12().getGeoIP("194.28.29.152"); 
	//выполняем сравнения полученного значения и ожидаемого 
	assertEquals(geoIP.getConuntryCode(), "RUS"); 
  }
}

Тест зеленый, значит мы смогли вызвать функцию, обратиться через удаленный программный интерфейс к удаленного сервису и получили правильный ответ.


}

Урок 85. SOAP - взаимодействие с MantisBT {

Не всегда просто сгенерировать код на java из файла wdsl

Во первых, бывает генератору нужно указать какие то параметры отличных от дефолтных
Во вторых, иногда бывает нужно использовать устаревшую версию генератора 

Для того чтобы избавить пользователей от генерации разработчики системы, которая предоставляет удаленный программный интерфейс часто сами генерируют уже готовую библиотеку. Тогда нужно ее только подключить к своему проекту и использовать.  

Рассмотрим на примере Mantis, который предоставляет удаленный программный интерфейс, работающий по технологии SOAP и для него уже есть такая готовая библиотека.

Для того, чтобы использовать удаленный программный интерфейс багтреккера Mantis нужно обращаться по адресу  
http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php?wsdl //файл описания, из которого с дефолтными параметрами не получается сгенерировать программный код - это описание написано в устаревшем формате, поэтому нужно использовать старую версию генератора.

Чтобы не мучится с генератором, нужно найти уже готовый компонент

https://search.maven.org/artifact/biz.futureware.mantis/mantis-axis-soap-client/1.2.19/jar

Добавляем в список зависимостей mantis-tests
implementation 'biz.futureware.mantis:mantis-axis-soap-client:1.2.19'

Пишем новый тест


package ru.stqa.pft.mantis.tests;

import org.testng.annotations.Test;

public class SoapTests {

  @Test
  public void testGetProjects() {
    //получение списка проектов

    

  }

}



Посмотрим на подлюченные библиотеки

C:\Users\kobzev\.gradle\caches\modules-2\files-2.1\biz.futureware.mantis\mantis-axis-soap-client\1.2.19\1b4a9cd7104f320c4a1d716f94975dc33e6fd2b9\mantis-axis-soap-client-1.2.19.jar!\biz\futureware\mantis\rpc\soap\client\MantisConnectLocator.class


  @Test
  public void testGetProjects() throws MalformedURLException, ServiceException {
    //получение списка проектов
	//устанавливаем соединение
    new MantisConnectLocator().getMantisConnectPort(new URL("http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php?wsdl"));


  }

присваиваем получившееся значение в переменную

  MantisConnectPortType mc = new MantisConnectLocator().getMantisConnectPort(new URL("http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php?wsdl"));

//получаем массив проектов, к которым указанный пользователь имеет доступ
    ProjectData[] projects = mc.mc_projects_get_user_accessible("administrator", "root"); //обращаемся к объекту, вызываем метод, присваиваем полученное значение в переменную. тип переменной указывается автоматически
	
Смотрим через веб интерфес какие есть проекты, создаем при необходимости

http://localhost/mantisbt-1.2.19/manage_proj_page.php


Попробуем вывести информацию на консоль

- количество проектов
- названия проектов 

Получаем
1
test


/*Если возникает ошибка 
Error Type: SYSTEM NOTICE, Error Description: Array to string conversion

то нужно исправить файл nusoap.php

The problem seems to be on the debug statement when it tries to convert an array to a string around line 6139 in serializeType in nusoap.php. The debug statement is in comments in the note, because is the one causing the error problems. Most likely it should be resolved with an application of implode on the right variable type. But being that I do not need to run debug, a comment on the statement will do it for me.

Code included:

$rows = sizeof($value);
$contents = '';
foreach($value as $k => $v) {
// PROBLEM STATEMENT
//$this->debug("serializing array element: $k, $v of type: $typeDef[arrayType]");
// PROBLEM STATEMENT

//if (strpos($typeDef['arrayType'], ':') ) {

if (!in_array($typeDef['arrayType'],$this->typemap['http://www.w3.org/2001/XMLSchema'])) {
$contents .= $this->serializeType('item', $typeDef['arrayType'], $v, $use);
} else {
$contents .= $this->serialize_val($v, 'item', $typeDef['arrayType'], null, $this->XMLSchemaVersion, false, $use);
}

*/

Смогли обратиться к баг трекеру через удаленный програмнный интерфейс и получить от него какую то информацию

Конечно, работать с этими данными, которые предоставляет библитека не очень удобно. Нам хотелось бы иметь свои собственные модельные объекты.

В частност, модельные объекты для представления проектов. 

Сделаем модельные объекты

Добавим новый класс Project в пакет model

package ru.stqa.pft.mantis.model;

public class Project {
  private int id;
  private String name;
  



}


Гененируем getter и setter

Setter меняем на такие, какие можно использоватль путем вытягивания в цепочки т.е. делаем fluent interface

public int getId() {
    return id;
  }

  public Project withtId(int id) {
    this.id = id;
    return this;
  }

  public String getName() {
    return name;
  }

  public Project withtName(String name) {
    this.name = name;
    return this;
  }



Делаем помощник SoapHelper

Инициализируем помощник в АМ

  public SoapHelper soap() {
    if (soapHelper == null) {
      soapHelper = new SoapHelper(this);
    }
    return soapHelper;
  }



Делаем конструктор

public class SoapHelper {
  private ApplicationManager app;

public SoapHelper(ApplicationManager app) //принимает в качестве параметра АМ 
//делаем для него поле, которое так и называется (при помощи среды разработки)
//конструктор достраивается автоматически



public class SoapHelper {

  private ApplicationManager app;

  public SoapHelper(ApplicationManager app) {
    this.app = app;
  }
  
}


Переносим в SoapHelper фрагмент кода для извлечения проекта


  public void testGetProjects() throws MalformedURLException, ServiceException, RemoteException {
    MantisConnectPortType mc = new MantisConnectLocator()
            .getMantisConnectPort(new URL("http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php"));
    ProjectData[] projects = mc.mc_projects_get_user_accessible("administrator", "root");

	}
  }


Делаем новый метод 

public Set<Project> getProjects() {
//у каждого объекта будет свой идентификатор, поэтому делаем множество. Нет необходимости говорить о порядке проектов. 
//вставляем сюда скопированный код 
//добавляем все исключения



public class SoapHelper {

  private ApplicationManager app;

  public SoapHelper(ApplicationManager app) {
    this.app = app;
  }

  public Set<Project> getProjects() throws RemoteException, MalformedURLException, ServiceException {
    MantisConnectPortType mc = new MantisConnectLocator()
            .getMantisConnectPort(new URL("http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php"));
    ProjectData[] projects = mc.mc_projects_get_user_accessible("administrator", "root");
    //преобразуем полученные данные в модельные объекты
	//ко всем элементам потока применяем функцию map, которая будет из объекта типа ProjectData строить объект типа Project
	//с таким же идентификатором и именем
	//поток, из новых объектов, собираем в множество 
	//возвращаем полуичвшееся множество
	
	return Arrays.asList(projects).stream().map((p) -> new Project().withtId(p.getId()).withtName(p.getName()))
            .collect(Collectors.toSet()); //не сходится тип идентификатора - возвращается Big Int а нужен Int
			//вызываем метод intValue() чтобы преобразовать 

  }

Теперь метод возвращает объет типа Project и в тестах удобнее использовать именно его

Теперь переделываем SoapTests

было
  @Test
  public void testGetProjects() throws MalformedURLException, ServiceException, RemoteException {
    //получение списка проектов
    MantisConnectPortType mc = new MantisConnectLocator()
            .getMantisConnectPort(new URL("http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php"));
    //получаем массив проектов, к которым указанный пользователь имеет доступ
    ProjectData[] projects = mc.mc_projects_get_user_accessible("administrator", "root");
    //вывод на консоль количество проектов
    System.out.println(projects.length);
    //названия проектов
    for (ProjectData project : projects){
      System.out.println(project.getName());
    }
  }

стало

public class SoapTests extends TestBase {

  @Test
  public void testGetProjects() throws MalformedURLException, ServiceException, RemoteException {
    Set<Project> projects = app.soap().getProjects();
    System.out.println(projects.size());
    for (Project project : projects){
      System.out.println(project.getName());
    }
  }

Запускаем тест, получаем тот же результат 

1
test

  
Теперь попробуем что-нибудь создать
Научимся создавать баг репорты


Добавим новый тест в класс SoapTests

@Test
  public void testCreateIssue() {
    
  }  
 
Придется создать новый объект 
  
  
  
 public class Issue {

  private int id;
  private String summary;
  private String discription;
  private Project project;
} 
  
  
 Создаем геттеры и сеттеры


package ru.stqa.pft.mantis.model;

public class Issue {

  private int id;
  private String summary;
  private String discription;
  private Project project;

  public int getId() {
    return id;
  }

  public Issue withId(int id) {
    this.id = id;
    return this;

  }

  public String getSummary() {
    return summary;
  }

  public Issue withSummary(String summary) {
    this.summary = summary;
    return this;
  }

  public String getDiscription() {
    return discription;
  }

  public Issue withDiscription(String discription) {
    this.discription = discription;
    return this;
  }

  public Project getProject() {
    return project;
  }

  public Issue withProject(Project project) {
    this.project = project;
    return this;
  }
}
 
  
Возвращаемся в тест 

  @Test
  public void testCreateIssue() {
    Issue issue = new Issue().withSummary("Test Issue").withDescription("Test issue description")
            .getProject(project); //откуда взять проект? в начале получим списпок проектов

  }

  
    @Test
  public void testCreateIssue() throws MalformedURLException, ServiceException, RemoteException {
    Set<Project> projects = app.soap().getProjects();
    Issue issue = new Issue().withSummary("Test Issue").withDescription("Test issue description")
            .withProject(projects.iterator().next());

Создаем функцию 
app.soap().addIsuue(issue);
  
результатом которой будет новый объект типа Issue, который мы можем сравнивать с существующим

Например , сравним у них Summary

assertEquals(issue.getSummary(), created.getSummary());

Создадим недостающий метод addIssue() 

public Issue addIsuue(Issue issue) {}
  
  
Сначала нужно снова создать соединени ms connect

вынесем во вспомогаетльный метод 

  MantisConnectPortType mc = new MantisConnectLocator()
            .getMantisConnectPort(new URL("http://localhost/mantisbt-1.2.19/api/soap/mantisconnect.php"));
    
  
  
  MantisConnectPortType mc = getMantisConnect();
  mc.mc_issue_add("administrator", "root", issueData); //должен указываться объект типа IssueData
  
  Мы должны из нашего модульного объекта типа Issue сформировать такой, который имеет нужную структуру. Для передачи его в метод удаленного интерфейса. 
  
  
public Issue addIsuue(Issue issue) throws MalformedURLException, ServiceException, RemoteException {
    //нужно снова создать соединение
    MantisConnectPortType mc = getMantisConnect();
    IssueData issueData = new IssueData();
    mc.mc_issue_add("administrator", "root", issueData);
  
  
  Получаем
  
  public Issue addIsuue(Issue issue) throws MalformedURLException, ServiceException, RemoteException {
    MantisConnectPortType mc = getMantisConnect();
    IssueData issueData = new IssueData();
    //заполняем объект
    issueData.setSummary(issue.getSummary());
    issueData.setDescription(issue.getDescription());
    issueData.setProject(new ObjectRef(BigInteger.valueOf(issue.getProject().getId()),
            issue.getProject().getName()));//ObjectRef - это ссылка на проект
    //несовпадение типов, здесь нужен объект типа BigInt. преобразовываем
    mc.mc_issue_add("administrator", "root", issueData);
	//теперь нужно обратно преобразовать
	//присваиваем идентификатор созданного багрепорта в новую переменную - alt+enter на параметре issueData
  }

  
	BigInteger issueId = mc.mc_issue_add("administrator", "root", issueData);

    //преобразовываем обратно в модульный объект
    //снова выполняем запрос
    //в ответ получаем объект типа IssueData
    IssueData createdIssueData = mc.mc_issue_get("administrator", "root", issueId);
    //снова преобразуем в модельный объект
    return new Issue().withId(createdIssueData.getId().intValue())
                      .withDescription(createdIssueData.getDescription())
                      .withSummary(createdIssueData.getSummary())
                      .withProject(new Project().withtId(createdIssueData.getProject().getId().intValue())
                                                .withtName(createdIssueData.getProject().getName()));
    
  }
  
Но при создании баг репорта есть обязательное поле - Category и там нужно указать как минимум дефолтную категорию

Поэтому добавим

issueData.setCategory(); //но откуда ее взять? . 

Выбирем случайную. Для этого запросим у багтреккера тотже самый программный интерфейс


mc.mc_project_get_categories("administrator", "root",
            BigInteger.valueOf(issue.getProject().getId()));
			
Поместим результат в локальную переменную 

String[] categories = mc.mc_project_get_categories("administrator", "root",
            BigInteger.valueOf(issue.getProject().getId()));
			
Выбирим первую 

issueData.setCategory(categories[0]);			

В итоге получим

  public Issue addIsuue(Issue issue) throws MalformedURLException, ServiceException, RemoteException {
    MantisConnectPortType mc = getMantisConnect();
    String[] categories = mc.mc_project_get_categories("administrator", "root",
            BigInteger.valueOf(issue.getProject().getId()));
    IssueData issueData = new IssueData();
    issueData.setSummary(issue.getSummary());
    issueData.setDescription(issue.getDescription());
    issueData.setProject(new ObjectRef(BigInteger.valueOf(issue.getProject().getId()),
            issue.getProject().getName()));
    issueData.setCategory(categories[0]);
    BigInteger issueId = mc.mc_issue_add("administrator", "root", issueData);
    IssueData createdIssueData = mc.mc_issue_get("administrator", "root", issueId);
    return new Issue().withId(createdIssueData.getId().intValue())
                      .withDescription(createdIssueData.getDescription())
                      .withSummary(createdIssueData.getSummary())
                      .withProject(new Project().withtId(createdIssueData.getProject().getId().intValue())
                                                .withtName(createdIssueData.getProject().getName()));

  }
  
Запускаем тест 

Все действия по созданию объектов мы выполняем через удаленный программный интерфейс, работающий по технологии soap .
Но на понятности тестов, это никак не отразилось. Мы по прежнему здесь работаем с модельными объектами, своими собственными, а все технические детали, в том числе взаимодействие с этой технологией soap и преобразование своих собственных модельных объектов в те которые нужны для отправки данных в виде soap запроса - все это спрятанно в виде специального класса помощника. 



}
Урок 86. REST - взаимодействие с Bugify {
	
На очереди другая разновидность удаленных программных интерфейсов - REST

Рассмотрим на примере багтрекера	
http://demo.bugify.com

который предоставляет удаленный программный интерфейс в стиле REST
https://bugify.com/api

REST как правило используется для того чтобы получить доступ к ресурсам, удаленным объектам и работать с этими объектами: создавать,просматривать, модифицировать, удалять эти объекты.

Т.е. удаленный программный интерфейс багтрекера должен содержать команды для управления багрепортами.


Для того чтобы выполнить какую то команду, получить доступ к какому то объекту, либо модифицировать его нужно отправить запрос по протоколу http на адрес 
http://demo.bugify.com/api + команда (GET/issues.json )

в этом запросе могут передаваться параметры

Доступ к этому интерфейсу разрешен только авторизованным пользователям, поэтому нужно передавать 
API key
e2307a869459460d31fe91e544054d72
	

Для реализации тестов нужно уметь:
- отправлять запросы по протоколу http (при помощи httpclient)
- анализировать полученный ответ в формате json (преобразовывать эти данные в объект языка программирования)

Созадем новый модуль resp-sample

Ипортируем в среду разработки (аналогично прошлым урокам)

Правим конф файл build.gradle

Подключаем библиотеки

dependencies {
    compile 'org.testng:testng:7.0.0-beta3'
    compile 'com.google.code.gson:gson:2.8.5'
    compile 'org.apache.httpcomponents:httpclient:4.5.7'

}


Пишем тест по созданию багрепорта в Bugify

public class RestTests {


  @Test
  public void testCreateIssue(){
	  
  }

}

Не будем делать полноценную двух уровневую архитектуру. Выносим все во вспомогательные методы, кроме логики самого теста


  @Test
  public void testCreateIssue() throws IOException {
	//Получим старый список
    Set<Issue> oldIssues = getIssues();
	//Создадим новый бегрепор
    Issue newIssue = new Issue().withSubject("Test sub").withDescription("Test desc");
    int issueId = createIssue(newIssue); //возвращает идентификатор созданного багрепорта
	//Получим новый список 
    Set<Issue> newIssues = getIssues();
	//Добавим багрепорт в старый список
	//пропишем идентификатор в объект, который мы создали
    oldIssues.add(newIssue.withId(issueId));
	//Сравним списки
    assertEquals(newIssues, oldIssues);
  }

Создаем класс Issue
Создаем в нем набор атрибутов


public class Issue {
  private int id;
  private String subject;
  private String description;
  
}

Генненируем getter и setter, редактируя setter для флуент стиля

public Issue withSubject(String subject) {//меняем возвращаемое значение на объект
    this.subject = subject;
    return this;//возвращается тот же самый объект, в котором вызван этот метод 
	//т.е. методы модифицируют объект, в котором они вызываются и позволяют дальше работать с этим объектом
  }

Возвращаемся в тест 
Создаем вспомогательные методы getIssues() и createIssue() при помощи другого способа работы с http клиентом, который тоже использует флуент стиль 


Смотрим документацию	
https://hc.apache.org/httpcomponents-client-ga/tutorial/html/fluent.html

Подлючаем библиотеку

compile 'org.apache.httpcomponents:fluent-hc:4.5.7'

Пишем код


private Set<Issue> getIssues() {
	//получаем список всех багрепортов в формате json.
	String json = Request.Get("http://demo.bugify.com/api/issues.json").execute().returnContent().asString(); 
	return null; //ставим точку остановы
}	

Пробуем посмотреть в отладчике, удастся ли получить ответ

Доступ к указанному адресу запрещен. Нужно авторизоваться, т.е. указать логин и пароль


Смотрим в документацию

Нужно использовать executor в который передается запрос

  private Executor getExecutor() {
    return Executor.newInstance().auth("e2307a869459460d31fe91e544054d72", ""); //username (key) + password
  }
	

private Set<Issue> getIssues() throws IOException {
    String json = getExecutor().execute(Request.Get("http://demo.bugify.com/api/issues.json")).returnContent().asString();
    return null; //точка остановы
  }

 
Запускаем в отладчике. Получаем ответ, в котором нас интересует часть где указывается список "issues":[]

Этот список будем преобразовывать в Set<Issue>

Сначала нужно проанализировать ответ и взять от туда кусочек, который соответствуют ключу issues

  private Set<Issue> getIssues() throws IOException {
    String json = getExecutor().execute(Request.Get("http://demo.bugify.com/api/issues.json")).returnContent().asString();
	//при помощи методе parse() получаем объект типа JsonElement
    JsonElement parsed = new JsonParser().parse(json);
	//извлекаем из него по ключу нужную часть и получаем нужный список 
    JsonElement issues = parsed.getAsJsonObject().get("issues");
	//теперь его нужно преобразовываем в Set<Issue> 
    return new Gson().fromJson(issues, new TypeToken<Set<Issue>>(){}.getType());//ставим точку остановы
	//второй параметр описывает сложный тип данных, который должен получится в конце 
	//потому что в java есть ограничение - нельзя написать Set<Issue>.class (для тех которые содержат уточняющий тип в <>)
  }

Пробуем запустить в отладчике
  
Прочиталось старое множество багрепортов

Переходим к методу создания post запроса. В ответе нас интересует часть "issue_id"
  
  private int createIssue(Issue newIssue) throws IOException {
    String json = getExecutor().execute(Request.Post("http://demo.bugify.com/api/issues.json")
			//передаем параметры, в формате пары (имя, значение)
			.bodyForm(new BasicNameValuePair("subject", newIssue.getSubject()),
                      new BasicNameValuePair("description", newIssue.getDescription())))
            .returnContent().asString();
	//анализируем ответ 
    JsonElement parsed = new JsonParser().parse(json);
	//возвращаем идентификатор созданного баг репорта
    return parsed.getAsJsonObject().get("issue_id").getAsInt();
  }



}	

Урок 87. RestAssured {
	
	
RestAssured библиотека для работы с REST сервисами

https://github.com/rest-assured/rest-assured


Пример запроса

get("/lotto").then().assertThat().body("lotto.lottoId", equalTo(5));

Выполяется запрос и сразу выполняются проверки, в которых указан путь внутри полученного json или xml ответа ,по этому пути находится какое то значение и сравнивается с ожидаемым

В действительности оказывается что тесты становятся низкоуровневыми. Потому что они работают непосредственно с json ответами, вместо того чтобы работать с модельными объектами. 
Получаем информацию от тестируемого приложения, преобразовываем в модельные объекты и проверки выполняем уже на уровне модельных объектов.

А эта библеотека предлагает выполнять проверки непосредственно на уровне json файлов, это делать не рекомендуется.

Но для первой части, то есть для выполнения запросов и получения ответов в формате json эту библеотеку можно использовать.

Подключаем к проекту
implementation 'com.jayway.restassured:rest-assured-parent:2.9.0'

Скопируем и перепишем тест RestTests

private Set<Issue> getIssues() {
    String json = RestAssured.get("http://demo.bugify.com/api/issues.json").asString();
    JsonElement parsed = new JsonParser().parse(json);
    JsonElement issues = parsed.getAsJsonObject().get("issues");
    return new Gson().fromJson(issues, new TypeToken<Set<Issue>>(){}.getType());
  }


  private int createIssue(Issue newIssue) {
    String json = RestAssured.given().parameter("subject", newIssue.getSubject())
                                     .parameter("description", newIssue.getDescription())
                                     .post("http://demo.bugify.com/api/issues.json").asString();
    JsonElement parsed = new JsonParser().parse(json);
    return parsed.getAsJsonObject().get("issue_id").getAsInt();
  }


Для авторизации нужно добавить

 @BeforeClass
  public void init(){
    RestAssured.authentication = RestAssured.basic("e2307a869459460d31fe91e544054d72", "");
  }


Теперь при каждом обращении к RestAssured будут использоваться эти параметры аутентификации


}	

Урок 88. REST - взаимодействие с GitHub {
	
Технология REST по сравнению с технологией SOAP имеет один серьезный недостаток, она вообще не предусматривает какого то описания сервиса в стандартном формате с которого можно было бы автоматически сгенерировать код который реализует удаленный программный интерфейс к этому сервесу.

Поэтому приходится все преобразователи писать вручную. Но иногда, это делают разработчики сервиса.

Они предоставляют библиотеки для разных языков программирования, которые можно подключить к проекту и использовать.

Пример jcabi от github

https://developer.github.com/v3/libraries/

https://github.jcabi.com/	
	

Создадим новый модуль github-sample

Импортируем аналогично

Редактируем зависимости

удаляем все кроме testng

добавляем 

implementation 'com.jcabi:jcabi-github:1.0'
	
	
	
Создаем новый класс

package ru.stqa.pft.github;

import org.testng.annotations.Test;

public class GithubTests {


  @Test
  public void testCommits() {
    
  }
}	
	
	
Получим из github информацию о коммитах. Прочитаем и выведем на консоль историю репозитория.

Как это происходит? Идем на страницу библиотеки

Github github = new RtGithub(".. your OAuth token .."); //установка соединение с github через удаленный программный интерфейс
 	
Нужно указать токен, его необходимо предварительно сгенерировать

В настройках	https://github.com/settings/tokens

Token description=REST
Repo=all //доступ к репозиторию - списку коммитов
Gist=all //доступ к заметкам

  @Test
  public void testCommits() {
    Github github = new RtGithub("630e7e729a7c7a871cf2806583e080a6f75b72dd");
    github. //список методов, которые позволяют получить доступ к определенной части сервиса
  }



  @Test
  public void testCommits() {
    Github github = new RtGithub("630e7e729a7c7a871cf2806583e080a6f75b72dd");
    RepoCommits commits = github.repos().get(new Coordinates.Simple("stag152766", "java_test")).commits();
    for(RepoCommit commit : commits.iterate()){ //нужно передать набор пар которые описывают фильтр
      System.out.println(commit);

    }
  }

В метод iterate() нужно передать набор пар, которые описывают некоторые условия отбора коммитов (фильтр)

Мы хотим получить полный список коммитов, поэтому нужно туда передать какое то пустое значение (null передавать нельзя)

Построем пустой набор пар
new ImmutableMap.Builder<String, String>().build()
  
В java помимо списков и множеств есть мэпы (ассоциативные массивы, карты) - это наборы пар	

Запускаем тест, получаем результат в виде списка ссылок

Но хотелось бы получить результат в виде понятных текстовых сообщений

преобразуем объект в другой RepoCommit.Smart(commit)

у него есть методы, позволяющие получить более детальную информацию о коммите, например комментарий к коммиту


  @Test
  public void testCommits() throws IOException {
    Github github = new RtGithub("630e7e729a7c7a871cf2806583e080a6f75b72dd");
    RepoCommits commits = github.repos().get(new Coordinates.Simple("stag152766", "java_test")).commits();
    for(RepoCommit commit : commits.iterate(new ImmutableMap.Builder<String, String>().build())){ //нужно передать набор пар которые описывают фильтр
      System.out.println(new RepoCommit.Smart(commit).message());

    }
  }

Это так все удобно происходит, благодаря тому что уже есть готовые библиотеки для работы с этим удаленным программным интерфейсом.
Если система предоставляет удаленный программный интерфейс, то иммет смысл сделать подобные библиоотеки. Чтобы не надо было думать об конкретных адресах, чтобы можно было работать с объектами, которые описывают некоторые логические сущности.

  
}
	

Занятие 10.Тестовые фреймворки и инфраструктура
Урок 89. Сервер непрерывной интеграции {
	
иметь обязательно!

После написания первых тестов, которые успешно отладили на локальной машине , нужно их поместить на сервер непрерывной интеграции

Сервер может выполнять любые задачи
- сборка тестируемого приложения
- установка на тестовый стенд
- автовыполнения тестов

В первую очередь предназначен для сборки продукта. Каждый разработчик пишет свой кусок кода, выполняют модульные тесты , проверяет что в его части когда все хорошо. После этого он выкладывает все свои изменения в репозиторий. И за дело берется сервер непрерывной интеграции.

Он из репозитория извлекает изменения, которые сделали все разработчики. Выполняет полую сборку продукта и проверят что все эти изменения не конфликтуют, все части продукта успешно интегрируются друг с другом.

Если компиляция успешно выполнена, продукт собран нужно убедится что он устанавливается. 

После успешной установки, можно запускать автотесты

В результате выполнения тестов получаем отчет, уведомления (помогает разобраться если есть проблемы)

Можно посмотреть историю и статистику

Как настроить запуск тестов на сервере непрерывной интеграции jenkins

war файл не требует установки, запуск осуществляется из консоли

Можно установить в windows как системный сервис

Загруженный war файл помещаем в папку c:/tools/

Стартуем консоль 
java -jar  jenkins.war

war представляет собой jar/zip архив, с дополнительной информацией, которая помогает java догадаться что именно его нужно запускать

Все распаковывается в .jenkins

При первом запуске будет подготовлена структура директорий, в которой будут размещаться задачи, которые мы создадим , там же все будет запускаться. 


Jenkins is fully up and running 


Открываем в веб интерфейсе
http://localhost:8080


Открываем настройки
Manage Jenkins > manage plugins > update 

Обновляем плагины
Select all 

Нажимаем
download now and install after restart //лучше делать после рестарта

Устанавливаем 

Gradle plugin

Git plugin

Останавливаем jenkins ctrl + C

Запускаем снова
java -jar  jenkins.war

Идем на главную страницу и с нее снова в настройки
Global Tool Configuration

Настроим пути к различным используемым программам

JDK install > add jdk //он будет использоваться для компиляции java программ

убираем галочку install auto

указываем где находится java
c:\Program Files\Java\jdk-11.0.1\

следующий git

мы используем github desktop, в нем есть exe он лучше указать консольную версию git.exe 

Скачиваем и устанавливаем
https://git-scm.com/

В настройках jenkins указывам путь до исполняемого файла
c:\Program Files\Git\bin\git.exe

Добавляем инфо где находится Gradle

Те модули, которые мы устанавливали могут использовать wrapper

Локальная установка не требуется. Каждый модуль самостоятельно установит gradle внутрь себя. 

Но чтобы съэкономить время можно указать локальную версию Gradle , тогда ничего скачиваться дополнительно не будет

убираем галочку install auto

MANAGE_DOMAINS
35d70a7fcd0a4c3a8439af7a28b5c81f

c:\Tools\gradle-5.2.1\

Теперь можно переходить к настройкам задачи


create new jobs > Freestyle project

name=sandbox

Настройка задачи состоит из 4 основных частей
1. Source Code Management // где взять исходный код 
Git
указываем адрес
Repository URL=https://github.com/stag152766/java_test

2. Build Triggers //когда запускать  //пока пропустим

3. Build //что именно нужно делать
Invoke Gradle script
Gradle Version=то что настроили
Tasks=clean test //потому что gradle повторно тесты запускать не любит, поэтому нужно выполнять очистку чтобы тесты запустились заново
Root Build script //указываем название подкатологов где находится файл build.gradle
Root Build script=sandbox //т.е. относительно корня проектов, они находятся в этойм подкатологе 

Build File // у нас называется build.gradle это значение которое испльзуется по умолчанию, поэтому можно оставить пустым

4. Post-build Actions //- те действия которые нужно выполнить в конце
=Publish JUnit test result report//хотим сгенерировать отчет из файлов в формате JUnit они будут находится Test report XMLs 

Несмотря на то что мы используем тестовый фреймворк TestNG, сборщик Gradle сгенирировать отчет в виде xml файлов в универсальном формате JUnit

Test report XMLs=sandBox/build/test-results/test/*.xml *//где отчеты будут находиться, во время выполнения тестов будут созданы необходимые подкатологи 

Т.к. мы используем TestNG поэтому в build.gradle должна быть такая инструкция 

test {
    useTestNG()
}

иначе Gradle не найдет тесты, по умолчанию он использует фреймворк JUnit. JUnit ни одного тесты не запустит и xml файл не сгенерируется

Сохраняем настройки и запускаем

Нажимаем Build Now


В Test Result видно отчет и сбои 

Чтобы увидеть сбои 

Изменим код в тесте testArea(){
Assert.assertEquals(s.area(),20.0) //укажем 20 вместо 25

Можно закоммитить, уложить в репозиторий и снова вручную запустить тесты

Но сделаем по другому, 

Вернемся к настройкам задачи Build Triggers


Build after other projects are built *
Как правило, это задача в рамках которой тестируемое приложение устанавливается на серверный стенд. 
Т.е. сдесь же, на сервере непрерывной интеграции происходит сборка, отдельной задачей.  
После успешного запуска сборки, активируется задача которая выполняет установку, 
после нее, если стоит галочка * и указана завимимость от какой то задачи, автоматически запускаются тесты
 
 
Build periodically

Poll SCM 
Проверить наличие изменений в репозитории где хранится исходный код 
Появляется поле ввода и в нем нужно указать, переодичность проверки наличия изменений

Каждую минуту
*/1**** 

Заходим в GitHub 

Ждем commit и pull

Через некоторое время запускается задача в Jenkins 


В отчете видно причину падения
Error Message
java.lang.AssertionError: expected [20.0] but found [25.0]


}
Урок 90. Удалённый запуск браузера (Selenium Server) {
	
	
Настроим тестовый стенд так, чтобы на нем можно было выполнять тесты требующие запуска браузера.

Рассмотрим на примере теста GroupModificationTests

То есть в конф файле testng-groups.xml оставим только его  

И на сервере НИ будем запускать задачу task testGroups(type: Test) из файла build.gradle
 
 
Изменения укладываем в репозиторий

 














}	

Урок 91. Конфигурационное тестирование (Selenium Grid) 00:20:00

Урок 92. Генерация отчётов при помощи Allure 00:25:35

Урок 93. Keyword Driven Testing и инструмент Robot Framework 00:20:52

Урок 94. Behaviour Driven Testing и инструмент Cucumber-JVM 00:22:15	
	
	

	
	
	