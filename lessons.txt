Занятие 1. 
Урок 1. Основы {

Написать программу 
Загрузить в память 
Хранить пока не запустится
ЦП начинает ее исполнять
Результат

Программа - набор инструкций и данных для обработки. На выходе получаем результат.

Уровни языков 
высокий (исходный код)
низкий (машинный код) 

Трансляция - перевод языка с высого на низкий уровень
Машинный код - код, исполняемый непосредственно процессором


Языки условно разделяются на: 
Компилируемый 
Интерпритируемый 

Способ 1
Исходный код программы пишется на каком-то языке программирования, инструмент который транслирует исходный код в машинный, называется компилятор. На выход он принимает программу на высокоуровневом языке, на выходе получается файл, сожержащий исполняемый код, который может исполняться ЦП. Компилятор порождает файл, который может самостоятельно исполняться. После создания файла компилятор не нужен. Компилятор нужен только разработчику. Пользователю нужен только скомпилированный исполняемый файл. Программа распостраняется в виде исполняемого файла. 

Способ 2
Интерпретатор читает исходный код, написанный на языке высокого уровня. Интерпретатор выполняет команды этого языка. На процессоре исполняется интерпретатор, а не какая-то программа, которая им порождается. Интерпретатор ничего не порождает, он сам работает и сам во время работ интерпретирует исходный код программы. Пользователю нужно установить интерпретатор. Программа распостряняется в виде исходных кодов. 

Способ 3
Одновременное наличие компилятора и интерпретатора. 
Исходный код программы с помощью компилятора преобразуется в байт-код. Байт код - промежуточное представление. Это низкоуровневый код, но еще не машинный код. Для исполнения байт кода нужен интерпретатор, который читает программу в байт коде и исполняет ее. В отличии от классического интерпритатора, низкоуровневый байт код легче и быстрее интерпретировать. 

Преимущества способа 3   
1. Простой и быстрый интерпретатор
2. Переносимость (кроссплатформенность). Исполняемый код для разных процессоров и ОС нужен разный. Если разработчики не ходят открыть свой код, и при этом они не сделали исполняемый код для вашей платформы, то сами сделать вы не сможете. 
А байт код, в отличии от обычного машинного кода, является универсальным. Компилятор универсальный, а интерпретатор под каждую платформу отдельный. В результате, программа распостраняется в одном единственном формате, возможность запуска определяется исключительно наличием интерпретатора для этой платформы.    
	
Java распостраняется в виде двух дистрибутивов. 
Java SDK (compiler + JRE ) для разработчиков.
Java Runtime Environment (JRE) для пользователей.


}
Урок 2. Установка Java SDK. Настройка окружения. {

Путь инсталяции
C:\Program Files\Java\jdk-11.0.1\

Настройка окружение

Путь к исполняемому файл 
C:\ProgramData\Oracle\Java\javapath\

Путь к JRE 
‪C:\Program Files\Java\jre1.8.0_181\bin\java.exe

Инсталятор настраивает окружение на JRE, так как это удобно пользователям для запуска java программ. Нам нужно перенастроить окружение так, чтобы вместо этого использовались исполняемые файлы JSK.

Для этого модифицируем переменную окружения path 
Control Panel\All Control Panel Items\System > Advanced system settings > System Properties > Environment Variables > Path

c:\Program Files\Java\jdk-11.0.1\

	

Создали путь для JSK

Путь к исполняемому файлу where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe

Путь к компилятору where javac
c:\Program Files\Java\jdk-11.0.1\bin\javac.exe


Поднимаем переменную JAVA_HOME вверх, чтобы в командной строке получилось
C:\Users\kobzev\Documents\temp>where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe
C:\ProgramData\Oracle\Java\javapath\java.exe






C:\Program Files\Java\jdk-11.0.1\}
Урок 3. {

Расширение .java указывает на то, что внутри хранится исходный код.


Пишем программу myFirstProject.java
public class myFirstProject {

	public static void main(String[] args) {
		System.out.println("Hello, world!");
	}
}


C:\Users\kobzev\Documents\temp>javac myFirstProject.java //компилируем

C:\Users\kobzev\Documents\temp>java myFirstProject //запускаем байт код
Hello, world!

}
Урок 4. Система хранение кода {

Зачем?
Резервная копия исходного кода
Ослеживание изменений (история)
Синхронизация, совместный доступ



Add .gitignore - параметр определяет чего не нужно сохранять в репозитории (файлы компиляций/отчеты о выполнении тестов)


Поэтому создаем файл .gitignore описывающий что сохранять не нужно

Выбираем Gradle / Apache License 2.0

Клонирование - программа для локальной копии
}
Урок 5. Сборщики {

В больших проектах много файлов, дополнительных библиотек. При компиляции нужно указывать пути к файлам с исходным кодом, библиотекам, опции. 
Решение
Написать один конфигурационный файл, Gradle, который берет конфигурационный файл и компилирует с описанием.

Конфигурационный файл может описывать настройки запуска, тестов. 

Популярные сборщики для Java
Аpache Аnt
Apache Maven
Gradle

Подготовка проекта
sandBox

Создание конфигурационного файла sandBox.gradle

Сборщики являются универсальными инструментами, умеют работать с разными языками программирования.
Необходимо подлючить плагин 
apply plugin: 'java'
Этот плагин требует создание определенной структуры директорий. Он будет искать файлы с исходным кодом на языке java в определенном месте (будем использовать настройки по умолчанию).

Создаем структуру директорий
src > main | test

main > java //сюда кладем файлы с исходными кодами, кроме тестов
test > java //сюда кладем тесты

Перемещаем myFirstProject.java в директорию main
Переходим в корневую папку sandBox
Запускаем консоль и компилируем файл с помощью gradle
c:\Tools\gradle-4.10.3\bin\gradle build

В проекте sandBox появляется два подкаталога
первый содержит вспомогательные файлы, которые нужны gradle для работы
c:\Users\Admin\Documents\temp\sandBox\.gradle\

второй сожержит результат компиляции
c:\Users\Admin\Documents\temp\sandBox\build\classes\java\main\

Для того, чтобы запустить скомпилированный файл class используется плагин
apply plugin: 'application'

Для того, чтобы данный плагин знал, что запускать указываем настройку
mainClassMain = "myFirstProject"


c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle run
 
запускается перекомпиляция и на консоль выводится наш текст "Hello, world!"

Уложить все в репозиторий


gradle можно интегрировать в проект, так чтобы все необходимое для его запуска хранилось в самом проекте. Для создания такого запускателя, gradle все таки понадобится. После того как запускатель создан, отдельно стоящий gradle уже использоваться не будет. 

В консоли выполняем команду запускателя
c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle wrapper  

Внутри проекта sandBox появляются новые файлы, которые представляют собой запускатель.
Укладываем их в репозиторий.



c:\Users\Admin\Documents\GitHub\java_test\sandBox\gradlew build

Скачивается и устанавливается внутрь проекта отдельный сборщик gradle. В результате отдельный gradle уже не будет использоваться.

После того, как дистрибутив загружен он распаковывается внутрь проекта и используется для сборки и запуска.
c:\Users\Admin\Documents\GitHub\java_test\sandBox>gradlew run
}
Урок 6. Среда разработки {

Основные
NetBeans
Eclipse
IJ


IJ позволяет оперировать двумя разными сущностями
проект - это группа модулей
модуль 

Выбираем New Project > Empty Project
Project Location: java_test //корневую директорию

Изменяем
Project Structure > SDKs + // указать где находится java
C:\Program Files\Java\jdk-11.0.1

Gradle Project 
Use auto-import enabled
Позволяет автоматически сихронизировать модуль, который мы создаем в среде разработки, с конфигурационным файлом build.gradle (когда изменения вносятся в конфигурационный файл, автоматически обновляется модуль).

Create durectories for empty content roots automatically
Используется когда есть пустой модуль с конфигурационным файлом

Create separate module содержит три типа модулей
для подкатолога src main
для подкатолога src test
общий

Открваем myFirstProject.class 
Запускаем в среде разработки IJ
Комитим в гитхаб

В GitHub видим последнии изменения, сохранять их нужно не все потому что они быстро меняются
workspace.xml // содержит информацию о том, какие файлы открыты в среде IJ
misc.xml 

помещение (push) 
получение (pull)

Скачать все ветки с origin, но не мержить их в локальный репозиторий:
fetch orgin 

}
Урок 7. Рассматриваем высокуровневую структуру {

В Java есть соответствие между файлами и классами. 
Если есть файл myFirstProject.java, то он должен содержать класс с таким же именем myFirstProject без расширения (не допускается несоответствие имен)

В одном файле может несколько классов, но только один public класс.

IJ автоматически сохраняет исходный код, компилирует его, и выводит сообщение об ошибке (при наличии)


Пакеты - с физической точки зрения соответствуют наборам директорий. Предназначены для того, чтобы избегать конфликты имен файлов и разрешить создавать файлы с одинаковыми именами. Рекомендуется классы помещать в индивидуальные пакеты.

Refactor > Move > Create New Package // ru.testjava.sandBox

Помещаем в папку src main, в которой создается иерархическая структура директорий. Таким образом, исключаются все конфликты между именами файлов. 


---
Урок 8. Рассматриваем содержимое файла исходного кода

Класс - основная структурная единица кода. Любой исполняемый код должен находится внутри какого-то класса. 

public class myFirstProject {}- открывая файл исходного кода обнаруживаете декларация одноименного класса. Внутри фигурный скобок находится описание класса (ограничитель для блока кода). 

Все конструкции заканчиваются ;

Метод = функция = блок кода (параметры) {конструкции, выражения}

метод main принимает на себя массив строке


Форматирование 
Code > Reformat Code  

Правила именования
классы всегда с большой буквы
все остальное с маленькой буквы

СamelCase

}
Урок 9. {

В java есть определенные правила вычислений. Если в выражении есть целые числа, то результат должен является тоже целым числом.
В ПК целые и дробные числа хранятся по разному. Для хранения дробных чисел используется представление чисел с плавающей точкой (2*10^3)

System.out.println("2" + 2) > 22 //число преобразуется в строку, и две строки склеиваются

}
Урок 10. Переменные и значения {

Значения - это выражение которое нельзя упростить. Часть даных, которая хранится в памяти компьютера. 

System.out.println("2" + 2)

("2" + 2) - выражение, получаемое путем склеивания двух значений
Когда выражение выполняется, то результатом склейки является новое значение.

Литеральные значения - явно описанные в коде программы.
Вычисляемые значения - получаемые в результате вычисления каких-то значений.

Переменная - именнованная ячейка памяти, в которой можно хранить присваемое значение. 
Переменная - ссылка / адрес где хранится объект(ссылка на объект).
Переменная - идентификатор / имя ссылающееся на какое-то значение.

В java все значения участвующие в вычислении должны быть известны.

}
Урок 11. Типы переменных и значений {

Java язык со строгим контролем типов / со строгой типизацией

int В = 8

int указание на тип переменной, в нее можно поместить только тип целых числел

Типы значений
целые числа 
числа с плавающей точкой
строки, заключенные в кавычки


Для них опеределены разные операции , и даже одинаковые операции выполняются по разному


Java для каждого значения значет значение, оно по разному представляется внутри компьютера.

Тип значения не совместим с типом переменной
int B = 8.0 или
int B = "Hello"


Переменная типа int может ссылаться только на значение с целым числом.


double - число двойной точности (с плавающей точкой)

Языки со строгой типизацией - это языки, которые отслеживают несоответствие типов на этапе компиляции, а не на этапе выполнения когда выражение будет реально вычисляться.
}
Урок 12. Среда разработки {

Отладчик (Debug) - позволяет выполнять программу последовательно, строчку за строчкой. И во время отладки смотреть какие значения преобретают переменные. Пользуются чтобы понять что происходит во время выполнения программы.

Точка останова

Нажать Step Over чтобы выполнить одну строку. 
Выполнилась та строка, в которой определяется переменная somebody. И эта переменная теперь видна в отладчике. Мы можем посмотреть ее значение. 


}
Урок 13. Функции именованные куски кода {

Создадим функцию, которая выполняет строку System.out.println("Hello, world!");  

Чтобы создать функцию, выводящую на экран приветствие по имени, нужно
Объявим переменную 
String somebody = "world";

Переменная somebody определена внутри функции, и значение ей присвается внутри функции.

public static void hello() {
		String somebody = "world";
		System.out.println("Hello, " + somebody + "!");
	}

Для того, чтобы значение можно было менять из вне, нужно ее объявить по другому:
 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world"); 					//место где функкия вызывается, передаем конкретное значение этого параметра 
	}

	public static void hello(String somebody) { //где somebody - параметр, аргумент функции
		System.out.println("Hello, " + somebody + "!");
	}

}

Теперь функция main обращается к функции hello, и передает туда строчку world. Эта строчка присвается, в качестве значения, параметру somebody. Далее это значение используется в коде функции. 

Void - нично, пустота. Функция не возвращает никакого значения. 

public static double area(double b){
		return b * b;
	}

Тип возвращаемого результата, указывается перед именем функции area.



package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world");
		hello("user");
		hello("Max");

		double l = 5; // переменная#1 - l (за пределами функ main она не существует)
		System.out.println("Площадь квадрата со стороной " + l + " = " + area(l));
	}

	public static void hello(String somebody) {
		System.out.println("Hello, " + somebody + "!");
	}

	public static double area(double l){ //переменная#2 - l (за пределами функ area она не существует) 
		return l * l; 
	}
}

Область видимости для переменной ограничевается телом функции (фигурными скобками, внутри которых она определена).
Переменная#1 и переменная#2 между собой никак не связаны.
Те переменные, которые указаны как параметры функции, тоже считаются относящиеся к ней.

Следующий шаг.

Создаем функцию, которая вычисляет площадь прямоугольника.

public static double area(double len){
		return len * len;
	}

	public static double area(double a, double b) {
		return a * b;
	}
	
Имеется две функции с одниковыми именами. Java их отличает, потому что у них разные параметры. 

Обратимся ко второй area

double a = 	b


}
Урок 14. Классы, объекты, конструкторы {

Объект - сложная структура хранения информации (дата), состоит из значений - полей / атрибутов (дд / мм / гггг). Объекты принадлежат  определенному типу.

Объекты могут хранить разные типы данных, поэтому у них может быть разная структура.

Для описания структуры однотипных объектов используется конструкция - класс.

Класс - это описание структуры однотипных объектов. Объекты - экземпляры, представители класса.

Создадим классы, описывающие объекты, площадь для которых мы вычисляем.

Создадим класс типа Квадрат

public class Square { //класс, который описывает структуру объектов, хранящих информацию о квадратах
    public double l; //внутри класса описываем атрибуты, которыми обладает объект этого типа. Квадрат описывается длиной его стороны.
}

Создадим класс типа Прямоугольник

public class Rectangle {
    public double a; //прямоугольник описывается двумя сторонами
    public double b; 
}

После описания классов, можно создавать объекты, которые являются представителями или экземплярами этих классов.

Square s = new Square(); // создаем объект типа Square
s.l = 5; // обращаемся к первой area, устанавливает значение атрибута l равное 5  
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

public static double area(Square s){ //функция area принимает не сторону, а объект типа Квадрат
		return s.l * s.l; //для того чтобы обеспечить доступ к атрибуту этого объекта указываем объект.атрибут 
}

	
	
Когда идет речь об объектах сложной структуры, то передавать в качестве параметра в вызываемую функцию один объект, лучше чем 10-20 параметров, которые описывают атрибуты этого объекта.   

В дальнейщем будем работать с объектами, которые имеют много атрибутов.


Rectangle r = new Rectangle(); // сначала создается объект класса 
	r.a = 4; // потом указываются (заполняются) значения атрибутов**
	r.b = 6;

	
Следующим шагом оптимизируем те части когда, где создаются объекты.
Square s = new Square(); 
	s.l = 5;

Rectangle r = new Rectangle();
	r.a = 4;
	r.b = 6;

	
**Можно сделать другим способом
Внутри класса объявим псевдофункцию - конструктор. 
Конструктор предназначен для того, чтобы заполнить атрибуты нового создаваемого объекта некоторыми значениями, которые передаются в качестве параметра в этот контсруктор. 

Было

public class Square(){
	public double l;
}

Стало

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


Конструктор - это специальная функция, которая имеет имя класса и не имеет возвращаемого значения. Тип возвращаемого значения не указывается. Конструктор может принимать параметры. 
Внутри фигурных скобок необходимо написать код, который инициализирует новый объект. То есть заполняет его атрибуты какими-то значеняими.

Теперь нельзя создать Square s = new Square(); потому что конструктор объектов этого типа требует, чтобы ему были переданы значения параметров.

Было
Square s = new Square(); 
	s.l = 5;
	
 
Стало
Square s = new Square(5); //атрибуты заполняются в конструкторе

 
Ключевое слово this 
это тот объект, который инициализируется в конструкторе
это ссылка на переменную, объявленную для всего класса

было

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


стало

public class Square(){
	public double l;
	
	public Square(double len){
	this.l = len;	
	}
}
 
Когда у нас есть какая то переменная s, которая ссылается на объект, то обращаться к атрибуту мы можем через эту переменную s.l
Square s = new Square(5);
s.l

Но в конструкторе в качестве специальной переменной, которая ссылается на конструируемый объект, выступает ключевое слово this.   

было
public class Square(){
	public double l;
	
	public Square(double len){ //len параметр контсруктора
	this.l = len;	
	}
}



стало 
 public class Square(){
	public double l;
	
	public Square(double l){
	this.l = l;	//так выглядит присваемое значение в атрибут. название аргумента конструктора совпадает с названием атрибута   
	}
}

В первом случае l атрибут, во втором l - переменная, которая объявлена как аргумент функции (переменная, являющаяся аргументом функции). 
Написать l=l нельзя тогда в обоих случах будет использоваться переменная  (double l)
Для того, чтобы присвоить переданное значение именно в атрибут объекта, нужно сослаться на этот объект this.l 
Значение атрибута создаваемого объекта, равно значению параметра переданного в конструктор.


В итоге, получаем
	
package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
	Square s = new Square(5);
	System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

	Rectangle r = new Rectangle(4,6); //длины сторон прямоугольника передаются в качестве параметра в конструктор 
	System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + area(r));
	}


	public static double area(Square s){ // функция принимает не сторону квадрата, а объект типа Квадрат
	return s.l * s.l; // для того чтобы получить доступ к атрибуту объекта, необходимо написать объект.атрибут
	}

	public static double area(Rectangle r) {
	return r.a * r.b;
	}
}


public Square(double l) { 
    this.l = l;
}
	
public Rectangle(double a, double b) {
	this.a = a;
	this.b = b;
	
}


}	
Урок 15. Методы. Функции объектов. {
 	
Функция - именнованный фрагмент кода.
Метод - это функция, связанная (ассоциированная) с каким-то объектом.

Для того, чтобы превратить обычные функции в методы необходимо
1) перенести функцию во внутрь класса, которая описывает соответствующие объекты
2) модификацировать функцию


Переносим функцию в конец класса
Переделка: убираем слово static и параметр функции, добавляем ссылку (this)


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/
 
    }
}


После переделки нужно научится использовать этот метод, вместо той функции из которой он был сделан 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		
		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); /* s.area())(параметр объекта.название метода) - место где вызывается функция (код вызова).  Обращаемся к методу , который ассоциирован с объектом.
		
		*/
		
		
	}

}

Вместо того, чтобы передавать s в качестве параметра area(s), мы его указываем перед названием s.area(). Вместо обращениния к атрибуту объекта, мы обращаемся к методу, который ассоциирован с этим объектом. 

Когда Java видит конструкцию s.area() она находит функцию area(), которая находится в классе Square, соответствущему этому объекту, и вызывает эту функцию public double area(){return this.l * this.l;}
А тот объект, в котором эта функция (метод) вызывалась, становится доступен через специальный идентификатор this.

Ключевое слово static исчезло, потому что оно используется чтобы помечать фукнции, которые не ассоциированы не с каким объектом. К которым можно обращаться напрямую.  

К методам можно обращаться только указав перед ними объект, в котором этот метод вызывается s.area(). 


package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {

		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); // обращаемся к методу, который ассоциирован с объектом

		Rectangle r = new Rectangle(4, 6); // чать когда, где функция вызывается
		System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + r.area());
	}
}


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/

    }
}


package ru.testjava.sandBox;

public class Rectangle {

    public double a;
    public double b;

    public Rectangle(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double area() {
        return this.a * this.b; //ссылка на объект доступно через ключевое слово this. ссылка на тот объект, в котором этот метод вызван
    }
}

В двух классах Square и Rectangle находятся функции с одинаковыми именами и без параметров area(). Эти функции между собой не конфликтуют, потому что они находятся в разных классах и Java легко определяет какую из этих функций следует вызывать. 

Если вызывается метод в объекте s.area(), который является экземляром класса Square, значит будет выполняться функция с именем area(), которая находится в классе Square.
Если обращаемся к методу объекта, который имеет тип (является представилем класса) Rectangle, значит будет выполняться функция находящаяся в классе Rectangle.

}


Занятие 2.
Урок 16. Что такое автотесты? {

Стек автотестирования - общий набор инструментов, которые задействованы при создании автотестов.
//стек - структура данных, организаванных по принципу "последний поступил -  первым обслужен"

Стек автотестирования состоит:

6. Сервер непрерывной интеграции - для автозапуска тестов из хранилища

	6.1 Хранилище - для хранения и распостранения 
	6.2 Среда разработки - для написания, отлаживания, запуска тестов по отдельности 


5. Сборщик - может использоваться для компиляции и запуска тестов. Удобно когда нужно запустить все тесты сразу.

4. Фреймворк - для запуска тестов. Его задача найти, запустить тесты и сгенерировать отчет. 

3. Тесты - написаны на языке програмирования, должны взаимодействовать с ТС. 

2. Драйверы тестируемой системы - инструменты, которые помогают взаимодействовать с ТС по сети или через пользовательский интерфейс (написанной на другом языке?)

1. Тестируемая система (ТС)


Взаимодействие на прямую означает через программый интерфейс.

Программа, в рамках которой запускаются и работают тесты состоит из фреймворка, тестов, драйвера.
При выполнении тестов, основной запускаемой программой является фреймворк.


}
Урок 17. Gradle подключаем зависимости {

Доработаем проект для использования автотестов функций area()
Подлючаем доп зависимость от тестового фреймворка TestNG


Готовый к употреблению, скомпилированный код для языка Java распостраняется в виде библиотек.
Физически они представляют собой архивы, в формате .jar
Технически это обычный zip архив который имеет специфическую структуру, использует расширение .jar

Сайт для поиска библиотек в репозитории сборщика
https://search.maven.org

Находим TestNG
Копируем текст в конфигурационный файл сборщика
Указываем зависимость в специальном блоке "декларация зависимости"


dependencies {
    implementation 'org.testng:testng:7.0.0-beta1'

}

Перед декларацией указываем какой репозиторий следует использовать
repositories {
    mavenCentral()
}

Через некоторое время библиотеки подключатся.

После установки библеотек, рекомендуется их проиндексировать
File > Settings > Build, Executiosn > Build tools > Maven > Repositories

Указывается репозитории, которые используются сборком
локальный 
удаленный

При отсутствии библиотеки в локальном репозитории, среда разработки обращается к удаленному репозиторию. Чтобы было быстрее искать, IJ загружает список всех имеющихся библиотек и индексируюет его.

Загрузка библиотек из удаленого репозитория в локальный.
Эта автоматическая сихронизация модуля в среде разработки с конфигурационным файлом build.gradle происходит благодаря тому, что во время импорта модуля была поставлена галочка Auto Import. 
Но автосинхронизация работает не всегда. Список зависимостей обновляется не всегда , несмотря на внесение изменений в конфигурационный файл. 

Выполнение синхронизации в ручную 
View > Tool Windows > Gradle > Refresh  

Документация сборщика для того, чтобы копировать фрагменты конфигурационного файла  
https://docs.gradle.org/current/userguide/building_java_projects.html


}
Урок 18. Фреймворк для запуска тестов TestNG {


Поместить первый тест в поддиректорию test > java 
Создать пакет ru.testjava.sandBox
В нем создать класс SquareTests. В Java любой код оформляется в виде классов.

Метод main делать не нужно, потому что запускается тестовый фрейворк. Он находит все тесты, выполняет и генерирует отчет.
В тестовом классе нужно написать методы, которые буду являться тестами.
Каждый метод в отчете будет представлен как отдельный тест.

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class SquareTests {

  @Test
  public void testArea(){
    Square s = new Square(5);
  }
}

В тестовом методе нет параметров и возвращаемого результата. О результатах своей работы, он сообщает тестовому фреймворку особым образом.

Создаем новый квадрат
Square s = new Square(5);
Проверяем площадь
assert s.area() == 25; // ключевое слово assert - логическое выражение "утверждение". Знак == для сравнения величин, а = для присваивания

Нужно пометить метод, чтобы фреймворк понял что это тест.
Перед методом нужно написать аннотацию  
Аннотация - это особый класс, которые используются как псевдо комментарии 
Не создаем объекты этого типа, просто указываем название этого класса перед чем нибудь  
Фреймворк по аннатациям находит нужный метод, это для него сигнал что это тест и его нужно запустить


Можно писать короткие имена классов
@Test //Enter - автопродолжения

Появляется конструкция, чтобы их импортировать 
import org.testng.annotations.Test; //полное название класса

или писать название классов полностью
@org.testng.annotations.Test //тогда конструкция import не нужная

После запуска теста появляется отчет 
Default Suite
Total tests run: 1, Failures: 0, Skips: 0

Но в случае упавшего теста AssertionError, не видно результата выполнения метода area().


Для отображения подробного сообщение об ошибке (expected, actual result) используется вспомогательный класс Assert

import org.testng.Assert;

Assert.assertEquals(s.area(),25.0); //начинаем писать Asserе. и включается механизм автопродолжения + Enter

Сравниваем значение площади, которое вычислено и ожидаемое значение


К функции assertEquals() можно обращаться на прямую, так как в ее описании есть ключевое слово static (подсказка ЛКП + Ctrl)
То есть чтобы воспользоваться этой функцией, не нужно создавать какой-то объект. 

Так как функция находится в классе Assert, а не в текущем классе SquareTests, значит перед ней нужно указать в качестве префикса имя класса Assert.assertEquals() Имякласса.функция




package ru.testjava.sandBox;

import org.testng.Assert; //класс Assert импорт добавляется автоматически 
import org.testng.annotations.Test; //класс Test

public class SquareTests { 

  @Test
  public void testArea(){
    Square s = new Square(5);
    Assert.assertEquals(s.area(),25) ;


  }
}


Результат упавшего теста
java.lang.AssertionError: expected [25] but found [25.0]
Expected :25
Actual   :25.0


Тестовый фремворк контролирует совпадение типов данных
Если Expected 25, а Actual 25.0, то тест считается упавшим.


}
Урок 19. Среда разработки {

Показать варианты исправления ошибки Alt + Enter

Список продолжения Ctrl + Space


}
Урок 20. Selenium драйвер для браузеров {

Скачать пакет
https://www.apachefriends.org/ru/download_success.html

Инструкция по установки
https://selenium2.ru/articles/136-installing-xampp.html


Установка приложения addressbook на сервер XAMPP

Распаковать addressbook в папку
c:\xampp\htdocs\  

Подготовка базы данных
MySQL > Admin (http://localhost/phpmyadmin/)

Create New database > addressbook

Создать структуру базы данных (импортировать)
Import > addressbook.sql

http://localhost/addressbook/
admin / secret

Если вход выполнился успешно, значит логин / пароль прочитались из базы данных. Приложение базу данных видит.


Начнем с подготовки нового модуля
Создаем подкаталог (модуль) java_test > addressbook-web-tests
Помещаем туда самое главное -  конфигурационный файл сборщика, потом сможем импортировать его в среду разработки



Перекладываем конфиг файл
build.gradle
и запускатель 
подкаталог gradle 
и запускаемые файлы для платформ win и linux
gradlew
gradlew.bat


Удаляем 
apply plugin: 'application'
mainClassName = "ru.testjava.sandBox.MyFirstProject"
	
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.testng:testng:6.14.3'
}

Скачиваем chromedriver.exe 
https://sites.google.com/a/chromium.org/chromedriver/downloads

Сохраняем в папку
c:\Tools\chromedriver_win32\



Устанавливаем Katalon Recorder
Записываем процесс создания группы http://localhost/addressbook/group.php
Сохраняем запись в формате java-testng.class и помещаем ее в каталог с нашим тестом

Открываем сгенерированный код в среде разработки
Добавляем строку, указываем путь с ChromeDriver и 
    System.setProperty("webdriver.chrome.driver", "c:\Tools\chromedriver_win32\chromedriver.exe");
    driver = new ChromeDriver();

Добавляем в конфиг файл две зависимости
    implementation 'com.katalon:com.katalon.platform.parent:1.0.1'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'

}
Урок 21. Фикстуры инициализация и зачистка {

Исправим ошибку в сгенерированном коде тестового метода @Test (аннотация Тест)

имя должно быть отличное от имени класса, и начинаться с маленькой буквы

Кроме тестового метода @Test сгенерировались два вспомогательных (пометки/подсказки для тестового фрейворка)
BeforeClass //метод инициализации фикстура, единственное место для указания используемого драйвера - браузера
AfterClass //метод завершения фикстура


Зачистка
Если код дублируется, то его нужно постараться выделить в отдельную функцию. Его можно использовать повторно, обращаясь к этому методу. В случае с тестовым фрейворком, он автоматически вызывает методы BeforClass / AfterClass перед каждым запуском тестового метода.

Фикструр - тестовая ситуация, тест зажимается между двумя методами Before - After. 


Модифицируем код 
Действия для авторизации не являются частью теста создания группы, поэтому вырезаем и переносим кусок кода в метод инициализации фикстура @Before.


}
Урок 22. Рефакторинг {

Правила безопасного преобразования кода. Структура кода меняется, но функциональность остается неизменной.

С помощью механизма рефакторинга научимся выделять вспомогательные методы.

Рекодер записывает сценарий, который трудно читается.
Для удобства пользования мы дадим имя фрагменту кода, сделаем именнованный фрагмент кода. Для этого нужно превратить его в функцию и в нужное время к этой функции обращаться.

Выделяем фрагмент кода для превращения в именнованную функцию
Refactor > Extract > Method (Ctrl + Alt + M)

Фрагмент кода получил собственное имя - там выволняется логин

@BeforeClass
...
login(); // вызов созданного метода (место, в котором к этому фрагменту нужно обратиться)

Почему метода, а не обычной функции?
Внутри метода используется переменная driver, которая является атрибутом объекта типа GroupCreationTests.  

private void login() {
    driver.findElement(By.name(user)).click();
    driver.findElement(By.name(user)).clear();
	
	...
}

Тестовый фрейворк сначала создает объект класса 
Потом выполняет метод 
setUp(){
	инициалируется атрибут объекта driver = new ChromeDriver();
}
Когда вызывается другой метод login() в том же самом объекте, он может этим атрибутом пользоваться.
Также нужно поступить с тестовым методом, выделить из него вспомогательные фукнции.

Первый механизм рефакторинга - это выделение вспомогательных методов.

Следующий шаг

Делаем метод login() параметрализованным, чтобы имя пользователя и пароль передовались внутрь метода в качестве параметров. 

Выделяем значение, которое необходимо превратить в передаваемый параметр
Refactor > Extract > Parameter (Ctrl + Alt + P)
Даем имя username
   

login("admin"); //В точке вызова передается конкретное значение, которое подставляется в эту переменную параметр и используется в методе login
private void login(String username){
	driver.findElement(By.name(user)).sendKeys(username);
}


Тестовый метод создает группу с какими-то свойствами name, header, footer
Значение этих свойств явно прописаны в коде метода
private void fillGroupForm() {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys("test1");
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys("test2");
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys("test3");
}

Было бы более логично передавать их в качестве параметров, чтобы функция fillGroupForm стала универсальной. Ее можно было бы использовать для создания групп с разными параметрами, то есть заполнять форму разными данными. Конкретные значения передавались бы из @Test.

private void fillGroupForm(String name, String header, String footer) {
    driver.findElement(By.name("group_name")).sendKeys(name);
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys(header);
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys(footer);
  }


Создаем новый контакт
У формы контакта много параметров
Как превратить много параметров в мало?

Вместо того, чтобы передавать много отдельных значений, их можно объединить в один объект, который будет иметь много атрибутов. То есть создать вспомогательный класс, который описывает объект типа Group. Объекты этого типа имеют набор атрибутов.

!В метод будет передаваться один объект
ПКМ на fillGroupForm
Refactor > Extract > Parameter Object 

Указываем имя классу, который будет описывать совокупность значений GroupData
Отмечаем те значения, которые должны быть объеденены
Default valuse for parameter -  Leave blank
Рефакторинг закончен

Теперь метод принимает один объект типа GroupData
public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

Это объект 

public class GroupData {
  private final String name; //имеет три атрибута
  private final String header;
  private final String footer;

  //конструктор, который позволяет проинициализировать объект какими то значениями
  public GroupData(String name, String header, String footer) { 
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  //методы, которые возвращают эти атрибуты
  public String getName() { //геттер не имеет параметров и возвращает значение одной переменной (одного поля)
    return name;
  }

  public String getHeader() {
    return header;
  }

  public String getFooter() {
    return footer;
  }
}  
 


А в @Test при вызове fillGroupForm создается новый объект, атрибуты которого заполняются конкретными значениями


@Test
public void testGroupCreation() throws Exception {
returnToGroupPage("groups");
initGroupCreation("new");
fillGroupForm(new GroupData("test1", "test2", "test3")); //данные для передачи во вспомогательные методы
...
}


Эти значения потом используются в методе fillGroupForm()



private void fillGroupForm(GroupData groupData) {
driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
driver.findElement(By.name("group_header")).sendKeys(groupData.getHeader());
driver.findElement(By.name("group_footer")).sendKeys(groupData.getFooter());
...	
}



}
Урок 23. Наследование общий базовый класс {

Поместим тесты в разные классы
- создание группы
- удаление группы
Куда поместить вспомогательные функции, чтобы они были доступны в нескольких классах?

Начнем с создания теста для удаления групп. Запишем его рекодером.
Запись теста экспортируем в язык программирования java+testng
Помещаем сгенерированный код в наш пакет
Исправляем имя пакету

Когда создается объект типа GroupDeletionTests, то в этом объекте нельзя вызывать функции, находящиеся в другом классе. Они с этим объектом никак не ассоциированы. 

Наследование - механизм, позволяющий сделать общее пространство для нескольких классов. Туда можно поместить методы и атрибуты. Класс наследник - это тот класс, который расширяет базовый.

Наследование - это процесс, в ходе которого один объект преобретает свойства другого объекта. 

Чтобы воспользоваться механизмом наследования, нужно создать дополнительный класс в который будут помещены общие методы. Класс GroupCreationTests будет расширять этот новый класс. 

public class GroupDeletionTests extends TestBase {}
 
Создадим общий (базовый) класс TestBase 
Поместим туда методы, которые хотим сделать общими
GroupDeletionTests > Refactor > Pull Members Up 
Отмечаем все, кроме test

public class GroupCreationTests extends TestBase { //тестовый класс расширяет (является наследником) базовый класс TestBase 
}
С технической точки зрения это означает, что все методы, которые описаны в базовом классе, становятся членами класса наследника. 
Когда создается объект GroupCreationTests, то с ним ассоциируются все атрибуты и методы, которые находятся и в базовом классе. 

Переходим ко второму тесту GroupDeletionTests.
Для того, чтобы воспользоваться теми методами, которые помещены в класс TestBase нужно написать, что класс GroupDeletionTests расширяет базовый класс TestBase.
Удаляем лишнее, то что уже есть в базовом классе.

Чистим тестовый метод testGroupDeletion()
-удаляем строки, где выполняется вход в систему. Потому что эти действия в методе, с аннотацией @BeforeMethod
К моменту начала выполнения тестового метода все будет уже готово.
-заменяем строки на уже существующие методы
-новые методы преобразуем во вспомогательные функции Ctrl+Alt+M // покабез параметров?


Созданные вспомогательные функции можно перенести в базовый класс. Меняем модификатор прав доступа.
GroupDeletionTests > Refactor > Pull Members Up 


Модификаторы видимости 
public - класс/атрибут/метод доступны откуда угодно
private - доступно из методов, которые находятся в том же самом классе
protected - доступно из методов того же самого класса и из классов наследников

protected void deleteSelectedGroups(String delete) {}

К ним можно обращаться не только из методов, находящихся в том же самом классе, но и из тех методов, которые находятся в классе наследников. 


Code > Reformat Code 
Code > Optimize Inports


Класс наследник содержит то, что описано в нем, а также то что содержится в базовом классе.
Если создается объет, то с ним ассоциированы не только не методы/атрибуты, которые описаны в нем самом, но и те методы/атрибуты, которые описаны в базовом классе.


}
Урок 24. Делегирование вместо наследования {

В разных классах могут возникать одинаковые вспомогательные фукнции. Для того, чтобы избежать дублирования кода мы используем
общий базовый класс, в который помещены вспомогательные функции. Они могут использоваться в разных тестовых классах. Но это ведет к новой проблеме. По мере того, как количество тестов увеличивается - количество вспомогательных методов тоже растет. Общий базовый класс становится слишком громоздким.       

1. Большой класс трудно читать и понимать 
2. Потенциальные конфликты при использовании вспомогательных методов несколькими пользователями

Предлагается решение, раскидать вспомогательные функции по дополнительным узкоспециализированным классам. 

1 этап
Из класса TestBase перенесем все вспомогательные фукнции в новый вспомогательный класс ApplicationManager
Вместо наследования будет работать механизм делегирования

2 этап
Новый класс ApplicationManager раздробим на более мелкие узко специализированные классы.


1 этап 
1 шаг
Временно сделаем еще один базовый класс и перенесем функции вверх. А потом передвинем сверху в бок.
После всех преобразований в классе TestBase должно остаться две функции setUp() и tearDown(). 
В этих функциях выполняется много действий, сначала надо вынести эти действия во вспомогательные фукции, которые потом вместе с остальными переедут в новый вспомогательный класс. Тем самым TestBase разгрузится практически полностью.
 

Выделяем содержимое метода setUp() {то что в скобках} Ctrl+Alt+M делаем вспомогательный метод init()
Тоже с tearDown(), новый вспомогательный метод называем stop()

Временно создаем базовый класс ApplicationManager
TestBase expects ApplicationManager

Перемещаем в новый класс все кроме setUp() и tearDown()

И применяем еще один рефактор 
Refactor > Replace Inheritance with Delegations

Заменяем наследование на делегирование. При этом будет создано новое поле (атрибут) назовем его app. Никакие галочки ставить не нужно.

Делегирование - механизм, при котором объекту вспомогательного класса делегируются определенные действия, которые он должен выполнить.


package ru.testjava.addressbook;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
public class TestBase { //исчезла ссылка на расширение класса ApplicationManager, вместо этого
  protected final ApplicationManager app = new ApplicationManager(); // создается ссылка на новый объект типа ApplicationManager
  @BeforeClass(alwaysRun = true)
  public void setUp()  {
    app.init(); /* те вызовы , которые выполнялись в текущем классе (как бы this.init())
    теперь вместо этого вызываются методы, находящиеся в объекте типа ApplicationManager */
  }
  @AfterClass(alwaysRun = true)
  public void tearDown() {
    app.stop();
  }
}

Также произошли изменения в тестах 

package ru.testjava.addressbook;
import org.testng.annotations.Test;
public class GroupCreationTests extends TestBase {
  @Test
  public void testGroupCreation() {
    app.gotoGroupPage("groups"); //просим объект типа ApplicationManager, чтобы он выполнил какое-то действие (обращаемся к нему)
    app.initGroupCreation("new");
    app.fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.submitGroupCreation("submit");
    app.returnToGroupPage("group page");
  }
}

Все вспомогательные фукнции теперь находятся в классе ApplicationManager

Фактически мы разделили код на два слоя
Первый слой - логика тестов. Включает в себя тесты (тестовые классы), которые содержат тестовые методы, сценарии короткие и понятные. Класс Test Base перед каждым тестовым методом инициализирует объект типа ApplicationManager, а после того как метод отработал останавливает его, разрушает.
Второй слой - логика (код) взаимодействия с тестируемой системой.  

Разделим свои физически, разнесем из по разным пакетам

protected - пометка, которая разрешает использовать этот метод не только в классах наслениках, но и в классах находящихся в том же самом пакете.   

Если мы собираемся перенести метод в другой пакет, нужно сделать методы public

ApplicationManager > appmanager
..Tests > tests
GroupData > model

Класс GroupData используется везде. Для того, чтобы обозначить его предназначение поместим его в model.  
Он представляет собой модель какого-то объекта предметной области. 


}
Урок 25. Расщепление и специализация {

Раздробим класс ApplicationManager (АМ) на несколько более простых классов и раскидаем по ним вспомогательные функции. 

Для этого используем механизм делегирования. Класс ApplicationManager будет делегировать какие-то действия своим помощникам. 
Создавать помощников мы будем как в предыдущем уроке. Создается временный базовый класс, в который переносятся какие то методы. Потом наследование заменяется на делегирование.

Самое сложное это определить какие вспомогательные классы нам нужны, и какие методы куда переносить. 
Проще всего перенести те методы, которые используются при работе с группами initGroupCreation, initGroupForm, returnToGroupPage 

public class ApplicationManager extends GroupHelper //создаем новый базовый класс
 
Переносим в новый класс методы, связанные с группами 
Заменяем наследование делегированием 
ПКМ ApplicationManager
Refactor > Replace Inheritance With Delegations

Среда сообщает, что после этого действия в тестах возникнут проблемы. Они не смогут получить доступ к перенесенным методам. 
Нужно поставить галочку Generate getter for delegated component**

**для него генерируется вспомогательный метод, дающий доступ к этому полю

Тестовые класса изменились, например GroupCreationTests


  @Test
  public void testGroupCreation() {
	app.gotoGroupPage(); // если АМ может выполнять действие сам
    app.getGroupHelper().gotoGroupPage("groups"); /* для других действий происходит делегирование в два этапа 
	Сначала происходит обращение к АМ, чтобы он дал доступ к помошнику по работе с группами GroupHelper, и уже этому помощнику делегируется выполнение настоящего действия , где происходит взаимодействие с тестируемой системой gotoGroupPage("groups") 
	*/
	}


Есть одно нежелательное изменение в АМ

Ссылка на драйвер переехала в groupHelper 
groupHelper.driver = new WebDriver();

Это неправильно, нужно вернуть ее обратно в ApplicationManager. Потому что она должна быть общей, ей хочет пользоваться  ApplicationManager и другие помощники тоже хотят работать с этой ссылкой.
Вернуть ее обратно средствами рефакторинга не получится. Нужно перенести в ручную.

Отправляемся в GroupHelper 
Копируем от туда ссылку 
WebDriver driver;
Вставляем в АМ, в начало выражения
Метод инициализации init() будет инициализировать именно эту ссылку. Атрибут который находится в классе AM
удаляем префикс groupHelper.
Но тогда возникает вопрос. Как GroupHepler получит эту ссылку на драйвер?
Нужно ее передать в конструктор, но не в private final GroupHelper = new GroupHelper(); а после того как выполнена инициализация (после  строк с атрибутом driver.)
То естьGroupHeldep должен конструироваться внутри метода init()
Ссылка на драйвер должна передаваться в качества параметра в контструктор
groupHelper = new GroupHelper(driver);
И этот конструктор необходимо создать Alt+Enter

  public GroupHelper(WebDriver driver) { //то значение, которое передано в качестве параметра конструктора
    this.driver = driver; //необходимо присвоить в атрибут (поле) класса GroupHelper
  }
Тем самым класс GroupHelper получит доступ к драйверу, который инициализирован в AM и передан помощнику. 
  
Но остались проблемы в АМ


private final GroupHelper groupHelper = new GroupHelder(); //не нужна инициализация = new GroupHelder()
private final GroupHelper groupHelper; //его нужно только декларировать

final - пометка означает, что в это можно присвоить значение только один раз. Нас это не устраивает потому что метод init() может вызываться многократно. Убираем пометку. 

private GroupHelper groupHelper;

Остались проблемы в других вспомогательных методах. Там тоже используется ссылка, которая находится внутри groupHelper. Нужно от этого избавиться. Чтобы определить где именно есть эта нежелательная ссылка, нужно в GroupHelper объявить атрибут, в котором он хранит свою личную ссылку на драйвер, private

> GroupHelper.java

private WebDriver driver;

В АМ будут выделены те кто хочет получить доступ к атрибуту, находящимуся внутри GroupHelper. Удаляем ссылки.
Пусть они пользуются ссылкой, которая находится внтури AM.


Для закрепления проделаем тоже самое с методом gotoGroupPage

Вынесем его во вспомогательный класс - NavigationHelper

public class ApplicationManager extends NavigationHelper; // создаем базовый класс  Alt+Enter

переносим в него нужную функцию gotoGroupPage + driver

Заменяем наследование на делегирование


Обратно переносим ссылку на драйвер

чтобы NavigationHelper получил доступ к этой ссылке передаем ее в качестве параметра в конструктор

navigationHelper = new navigationHelper(driver);

просим среду разработки чтобы она создала этот конструктор 

присваемваем переданное значение 

public class NavigationHelper {
  private WebDriver driver; //для того чтобы к нему никто не мог получить доступ  

public NavigationHelper(WebDriver driver) {
    this.driver = driver; //присваеваем переданное значение в поле 
  }
}
возвращаемся в сломавшийся и подкрашенный АМ

удаляем все неправильные использования драйвера

удаляем модификатор final и инициализацию = new navigationHelper(); //потому что эта инициализация выполняется в методе init() после создания драйвера 

navigationHelper = new NavigationHelper(driver); 



Переносим метод login() во вспомогательный класс другим способом, без рефакторирга


appmanager > Create New Class > SessionHelper


сделаем в АМ ссылку на SessionHelper


private sessionHelper sessionHelper;


инициализируем его в методе init()

sessionHelper = new SessionHelper(driver); //поскольку такого конструктора нет, сделаем его

public class SessionHelper {
  private WebDriver driver;
}

public SessionHelper(WebDriver driver) { //driver Alt+Enter > присвоить значение параметра конструктора в какое-то поле 
  this.driver = driver; //поле создается автоматически 
}

Вырезаем метод login() и вставляем в класс SessionHelper

Добавить все необходимые импорты, поменять методы на public 

Внутри AM обращаться к нему через помощникам

sessionHelper.login("admin", "secret") //вызывается метод в помощнике, ему делиируются какие-то действия


}
Урок 26 Наследование общий базовый класс {

Для того чтобы новые тесты было проще добавлять, и без использования рекодера, нужно доработать код классов помощников

Код заполнения поля ввода 

driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());

Alt+Ctrl+M

public void fillGroupForm(GroupData groupData) {
    type(groupData); 
}
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

В результате рефакторинга параметр у этого метода получился не очень удачный. Логичнее в этот метод передавать 2 других параметра: локатор элемента, текст который нужноввести в поля ввода. 

было
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

стало
 private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }
  
  
При этом среда разработки сама догадалась, что параметр GroupData больше не используется и автоматически его удалила. Кроме того, она заметила такие места, где повторяется фрагмент кода и предложила там тоже сделать замену на вызов нового созданного метода. 



  public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

  private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }

В результате всех преобразований дублирование кода сократилось.

Тоже с методом клик

 public void submitGroupCreation() {
    driver.findElement(By.name("submit")).click();
  }
  
Выделяем кусок кода, который хотим выделить во вспомогательный метод
Alt+Ctrl+M

  public void submitGroupCreation() {
    click();
  }
 

  
Делаем его параметрализованным 

public void submitGroupCreation() {
	click(By.name("submit"));
}
private void click(By locator) {
	driver.findElement(locator).click();
}

Среда замечает, что есть 5 похожим фрагментов и их тоже стоит заменить

Тоже самое нужно проделать в другом классе помощнике - SessionHelper
Но мы уже сделали подходящие методы, необходимо только предоставить возможность использовать их.

Здесь нам поможет механизм наследования, который даст возможность предоставить общее пространство обобществить какие то методы между двумя классами. Возвращаемся в GroupHelper, делаем базовый класс и помещаем в него методы click и type + ссылка на драйвер

GroupHelper extends HelperBase; //базовый класс для всех помощников 

Раньше в контсрукторе просто присваивалось значение в поле класса, а сейчас появился вызов странного метода 
  public GroupHelper(WebDriver driver) {
    super(driver); //это обращение к конструктору базового класса
  }
В базовом классе создан конструктор, который принимает параметр в качестве ссылке на драйвер
  public HelperBase(WebDriver driver) {
    this.driver = driver;
  }



public void login(String username, String password) {
    driver.findElement(By.name("user")).click();
    driver.findElement(By.name("user")).clear();
    driver.findElement(By.name("user")).sendKeys(username);
    driver.findElement(By.name("pass")).clear();
    driver.findElement(By.name("pass")).sendKeys(password);
    driver.findElement(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]")).click();
  }


  public void login(String username, String password) {
    type(By.name("user"), username);
    type(By.name("pass"), password);
    click(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]"));
  }


Метод может пользоваться теми данными, которые храняться в объекте этого класса.


}
Урок 27. Новый тест без использования рекодера {

Добавим тест в котором проверяется возможность модификации какой то существующей группы


package ru.testjava.addressbook.tests;

import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupModificationTests extends TestBase{

  GroupModificationTests() {

  }

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    app.getGroupHelper().selectGroup();
    app.getGroupHelper().initGroupModification(); //новый
    app.getGroupHelper().fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.getGroupHelper().submitGroupModification();//новый
    app.getGroupHelper().returnToGroupPage();
  }
}

Новые методы создаем в классе GroupHelper

}


Занятие 3 Управление потоком выполнения кода, ветвление
Урок 28. Блок if / else {

Решение квадратного уравнения
D = b^2 - 4ac

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения


double d = b*b - 4*a*c; 
	
Используя условный оператор if, можно выборочно выполнять отдельные части программы.
Ниже представлена простейшая форма оператора if:
if (условие) оператор;
Условие обозначает логическое выражение.

Будем анализировать дескреминант, чтобы присвоить значение в атрибут n


if (d > 0) { //если условие в скобках справедливо, то выполняется блок в фигурных скобках
  n = 2;
} else { //если условие в скобках не справедливо
  if (d == 0) { //вложенная конструкция if
	n = 1;
  } else {
	n = 0;
  }
}


---
Урок 29. Проверки различные формы
Конструкция if, служащая для проверки условий может принимать три формы

Полная форма с блоком else
Сокращеная форма без блока else
Свернутая форма - альтернативное представление для нескольких вложенных конструкций if

Если в конструкции if внутри фигурных скобок находится одно действие, то фигурные скобки можно не ставить.

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения

Тройных развилок нет, поэтому это реализуется через вложенные конструкции 


Визульно равноправные, а не вложенные. Это свернутая форма которая по сути эквивалентна вложенной форме.
if (d > 0) { 
  n = 2;
} else if (d == 0) { 
n = 1;
} else {
n = 0;
}

Если условия взаимоисключающие, то можно записать по другому. Но тогда будут выполняться все проверки, то есть будут лишнии проверки. При наличии блока else лишних проверок нет.

if (d > 0) { 
  n = 2;
} 
  
if (d == 0) { 
n = 1;
} 

if {d < 0) {
n = 0;
}
}

Внутри блока else находится одна единственная конструкция if
else { 
  if (b == 0) {
	if (c == 0) {
	  n = -1;
	} else {
	  n = 0;
	}
  } else {
	n = 1;
  }

}

стало
 if (a != 0) { //алгоритм решения квадратного уравнения
      if (d > 0) { //используется конструкция типа свертка* 
        n = 2;
      } else if (d == 0) {
        n = 1;
      } else {
        n = 0;
      }

    } else if (b != 0) { //алгоритм решения линейного, вырожденного уравнения //используется конструкция типа свертка
      n = 1;

    } else if (c != 0) {
      n = 0;

    } else {
      n = -1;
    }

С логической точки зрения это разные свертки 
в первой конструкции равноправные, взаимоисключающие варианты развития событий D < 0 или D = 0 или D > 0. Это три разные ветки.
во второй конструкции остается каскад проверок - они по смыслу вложенные, но написаны в свернутой форме.

При написании кода пробуйте эксперементируйте, меняйте проверяемые условия, переставляйте блоки местами, стараясь добиться максимальной понятности того, что проверяется и когда что должно выполняться.


}
Урок 30. Браузер на выбор {

public class ApplicationManager {
  private WebDriver driver; //тип переменной интерфейс WebDriver - это проявление механизма наследования
 
public void init() {
    System.setProperty("webdriver.chrome.driver", "c:\\Tools\\chromedriver.exe");
    driver = new ChromeDriver(); //создается экземпляр класса ChromeDriver

	}	
	
В интерфейсе методы только декларируются, объявляются имена и типы параметров возвращаемого значения. А конкретная реализация этих методов должна быть написана в классе наследнике.	
Разные классы могут реализовывать один и тот же интерфейс, но по разному 	
	
Выбор типа браузера нужно указать при инициализации в TestBase. Поэтому тип браузера нужно следать параметром.

Способ 1
Можно сделать параметром метода init()	
	
Тогда в TestBase при вызове этого метода нужно указать тип браузера
@BeforeMethod
public void setUp()
app.init(CHROME)

Способ 2
Можно сделать тип бразузера параметром конструктора AM

public class TestBase {
protected final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);
...
}

Создаем конструктор
public ApplicationManager(String browser) {

    this.browser = browser; //значение параметра сохраняем в поле
  }
	
Убираем локальную переменную String browser = BrowserType.CHROME; вместо нее будет использоваться атрибут объекта АМ, тот который был установлен при конструировании этого объекта.
public void init() {
    String browser = BrowserType.CHROME;
    if (browser == BrowserType.CHROME) {	
	}	

public void init() {
    if (browser == BrowserType.CHROME) {
      driver = new ChromeDriver(); 
    } else if (browser == BrowserType.FIREFOX) {
      driver = new FirefoxDriver();
    } else if (browser == BrowserType.IE) {
      driver = new InternetExplorerDriver();
    }
}

Драйверы помещены в папку c:\Tools\
В переменную окружения PATH добавлен путь c:\Tools\ 
	
http://software-testing.ru/forum/index.php?/topic/33657-udaetsia-podkliuchit-chromedriver-tolko-cherez-systemsetproperty/?p=154278

1) Можно положить исполняемый файл chromedriver в одну из директорий, которые упоминаются в переменной окружения PATH. Если Вы попытались это сделать, но не работает -- вероятно, неправильно настроили переменную, либо не перезапустили приложение, которое должно увидеть изменённое значение переменной. В операционной системе Windows можно просто положить исполняемый файл в c:\windows\system32, эта директория по умолчанию включена в PATH (если только вы её оттуда сами не удалили)

 

2) Можно положить исполняемый файл chromedriver в текущую директорию. То есть в ту директорию, которая будет текущей, когда вы будете запускать тесты. Скорее всего это корневая директория проекта.



---
Урок 31. Сравнение Equals	
	
Знак сравнения == нужно использовать только для чисел (двойной знак равенства)
Во всех остальных случаях, для объектов нужно использовать метод Equals	
	
Переменная - ссылка на объект
Когда вы объявляете переменную ссылочного типа, на самом деле вы создаете ссылку на объект данного типа. Рассмотрим следующий код для объявления переменной типа int:
int x;
x = 10;
В этом примере переменная x имеет тип int и Java инициализирует её как 0. Когда вы присвоите переменной значение 10 (вторая строка), это значение сохранится в ячейке памяти, на которую ссылается x.


Когда мы присваивали во вторую переменную значение, которое хранится в первой переменной, новый объект не создавался. 
Скопировалась ссылка на уже существующий объект
String s1 = "firefox";
String s2 = s1; //есть 2 переменных ссылающееся на один и тот же объект


public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = s1; 

System.out.println(s1 == s2); //true сравнение ссылок, проверяется идентичность объектов 
System.out.println(s1.equals(s2)); //true сравнение содержимого объектов
}
}
	
	
public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = new String(s1);  // в памяти возник другой объект

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}	
	
В памяти возник другой объект, который логически содержит такой же текст, но физически это другой объект. Он хранится в другом месте в памяти, имеет другой адрес.

Когда сравниваются две ссылки s1 == s2 результат отрицательный.
Метод equals() сравнивает не ссылки, а содержимое объектов. Это логические сравнение, а не физическое. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = "firefox"; // не происходит копирование ссылки. В переменную s2 присвается значение, совершенно не зависимо от того что было раньше присвоено в переменную s1  

System.out.println(s1 == s2); //true java считает что переменные ссылаются на один и тот же объект 
System.out.println(s1.equals(s2)); //true
}}

Компилятор оптимизирует код. Все переменные, которые ссылаются на одну и туже литеральную строку, будут ссылаться на один и тотже физический объект. 
String s2 = "fire"+"fox";
System.out.println(s1 == s2); //true

Компилятор догадывается, что это один и тотже объект. На этапе компиляции склеет эти части, увидит что получился тотже самый объект, который ранее использовался.

Но на этапе компиляции вычисляются не любые выражения. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox" + "2.0";
String s2 = "firefox" + Math.sqrt(4.0); //на этапе выполнения будут созданы два независимых объекта

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}


---
Урок 32. Дефолтные значения в полях

Рассмотрим пример использования конструкции if для оптимизации ввода данных в текстовые поля.

Задание
Создать группу, с именем test1, а остальные поля пусть будут заполнены значениями по умолчанию. Не указывать в тесте явно. 

Можно использовать значение null. Когда в переменную присвается значение null , это означает, что она ни на какой объект не ссылается.


protected void type(By locator, String text) {
	click(locator);
	driver.findElement(locator).clear(); 
	driver.findElement(locator).sendKeys(text); //падает, предварительно очистив поле ввода 
}

Задание 
Если в качестве текста передано значение null, то это поле ввода вообще не нужно трогать.

было  	
  protected void type(By locator, String text) {
    click(locator);
    if (text == null) { // нужно проверить храниться ли в переменной ссылка на какой то объект (физ сравнение)

    } else {
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }	
}	
	
стало
if (text != null) { 
  driver.findElement(locator).clear();
  driver.findElement(locator).sendKeys(text);
}	
}
}

}
Урок 33. Ленивое заполнение полей {

Для того чтобы оставить поле неизменным, можно передать в качестве значение null. Это будет означать, что мы хотим оставить в поле то значение, которое в поле уже введено.


Если то значение, которое мы передали совпадает с тем, которое уже введено в поле ввода. Есть смысл провести проверку. 

Задание
Если в поле уже введено значение, то с этим полем делать ничего не нужно



По правилам web приложений тот текст которым видим в поле ввода, является значением атрибута value

А обычный метод getText() для полей ввода всегда возвращает пустую строчку. Метод getText() используется для всех остальных элементов, кроме полей ввода. 


protected void type(By locator, String text) {
click(locator);
if (text != null) {
  String existingText = driver.findElement(locator).getAttribute("value"); //извлекаем из поля то значение, которое храниться
  if (! text.equals(existingText)) { //если неверно что текст совпадает с уже существующим текстом
	driver.findElement(locator).clear();
	driver.findElement(locator).sendKeys(text);}
  }
} 

Если нужно чтобы тесты работали быстро, есть большие поля ввода куда вводится длинный текст, тогда сделать такую доп проверку не помешает. 
Selenium вводит текст по символьно. 


}
Урок 34. Исключения. Перехват и обработка {

Исключение - это информация выводящаяся на консоль при падении программы. Информация о том, где произошел сбой, в каком файле, строчке.

Конструкция if часто используется чтобы предотвратить возникновение исключения.

В нормальном состоянии выполнение метода завершается либо от дошел до самого конца "}", которая ограничивает тело метода. Либо если в коде встретилось слово return.

Стек вызовов - цепочка методов, которые вызывают друг друга

Читать удобно снизу вверх. 

main главная функция, которая запускается когда мы стартуем какую нибудб программу.
В последнем методе, который упоминается в стеке вызовов произошла ошибка. 
Причем ошибка настолько серьезная, что дальнейшая работа программы стала невозможной. 
Несмотря на то, что в последнем методе нет слово return, java должная прекратить выполнение этого метода. 
Java прекращает выполнение этого метода аварийно. То есть вышестоящий метод получает сообщение о том, что вызванный метод завершился аварийно. 
И вместе с этим сообщением получает специальный объект, который содержит информацию о возникшей проблеме. Этот объект называется исключением.
А преждевременный возврат из функции называется выбросом исключением. 

Последняя функция выбросила исключение и при этом ее работа прервалась.
Предпоследняя функция, которая обращалась к проблемной , тоже не может продолжать, поэтому она пробрасывает исключение дальше. 
В свою очередь предшествующий метод тоже аварийно прерывается, и пробрасывает ислючение еще выше 
И так ислючение постепенно летит вверх пока не долетает до места где оно будет перехвачено.

В тестовом фрейфорке есть механизм, который позволяет эту цепочку аварийных прерываний остановить, исключение перехватить, проанализировать и обработать.
Тестовый фреймворк ловит исключение, записывает в отчет, выводит на консоль, и продолжает выполнять следующие тесты. 
 
Синие функции - те что в нашем проекте	
Серые - какие то библиотеки	(selenium)

Код серых библиотек нам не доступен, мы ее исправить не можем
Поэтому если внутри этой библиотеки возникает ислючение, мы можем:
- попытаться это предотвратить, написав какие то проверки и не допустить обращение к методу sendKeys() с плохими данными;
- обратиться к фукнкции sendKeys и попытаться перехватить те исключения, которые могут быть выброшены во время ее работы (устранить последствия).

Метод isAlertPresent() позволяет проверить наличие диалогового окна, которое иногда возникает на странице web приложений.
Библиотека selenium не предлагает способа проверить наличие / отсутствие этого диалогового окна
	
	
public boolean isAlertPresent() {
  try { //пытаемся выполнить блок кода
	driver.switchTo().alert(); //если окно есть, то успешно переключимся. все Ок
	return true; //а если не получилось и возникло исключение
  } catch (NoAlertPresentException e) { // если окна нет, то возникает исключения типа NoAlertPresentException. Перехватываем его и тоже все Ок. другого типа не перехватим.
	return false; 
  }
}	

Предотвратить появление ислючения нельзя. Вынуждены устранять последствия. 	
Это аварийное прерывание не будет распостраняться дальше. 
Те функции которые обращаются к isAlertPresent(), вместо прерывания и исключения получат нормальное возвращаемое значение true / false
	
Типы исключений бывают разные:	
- при выполнении недопустимых арифметических действий, поделить на 0
- преобразование строки в число, если при этом строка не может быть преобразована в число
- использование переменной, которая не проинициализирована NullPointerException
- при поиске несуществующего элемента 

}
Урок 35. Почти одикановые формы {

Имеется две почти одинаковые формы. В форме для редактирования контакта отсутствует поле выбора группы с выподающим списком.

В обоих тестах CreateContact и ContactModification используется метод fillContactForm()
Добавим в него функционал для работы с группами

Во первых нужно добавить поле String group в класс ContactData, который хранит информацию о контакте

Добавляем параметр в конструктор, сохраняем его значение в какое то поле 

Делаем для этого поля метод getter, которое позволяет получить значение поля. 

//“get” — “получать” (т.е. “метод для получения значения поля”) и set — “устанавливать” (т.е. “метод для установки значения поля”).
//метод getName() возвращает значение поля name у того объекта, для которого он был вызван

public class ContactData {
	...
    private String group;

  public ContactData(...String group) {
	...
    this.group = group;
  }

  ...
  public String getGroup() {
    return group;
  }
}

Указываем существущее значение параметра group в тестах 
На странице приложения Edit Group нет поля group, поэтому в тесте ContactModification указываем null

На этом доработка тестов завершена, теперь доработаем метод который заполняет форму.

Как выбрать элемент из выпадающего списка?

Используем вспомогательный класс 
new Select(driver.findElement(By.name("new_group"))) //в качестве параметра указан элемент, который найден на странице приложения - листбокс со списком групп

Теперь в этом объекте типа select надо вызвать один из методов
new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());

Но при попытке запустить тест ContactModification в этой строчке возникнет исключение, потому что драйвер не сможет найти элемент с таким локатором.

Для того, чтобы предотвратить это исключение, можно сделать проверку

if (isElementPresent(By.name("new_group"))) { //задаем локатор в качестве параметра
    new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup()); //выбор пункта из выпадающего списка
    } 
//в противном случае, если такого элемента нет, то делать ничего не нужно - блока else не будет

Создаем метод isElementPresent()

private boolean isElementPresent(By locator) { //параметру даем общее имя, для проверки произвольного локатора
	return  ; //тут нельзя предотвратить возникновение исключения 
}
  
Драйвер селениум не предоставляет возможности узнать заранее есть ли на странице элемент или нет.
Единственное что можно сделать это его поискать

private boolean isElementPresent(By locator) {
	driver.findElement(locator); //поиск элемента
}

Если элемент есть, то он успешно найдется. 
Если элемента нет, то будет выбрашено исключение.
Поэтому нужно обернуть попытку поиска элементра в блок try

 protected boolean isElementPresent(By locator) {
    try {
    driver.findElement(locator);
    return true;
    } catch (NoSuchElementException ex) {
    return false;
    }

 }

Рассмотрим ситуацию, когда на форме создания контакта разработчики потеряли это поле. 

if (isElementPresent(By.name("new_group"))) { //селениум должен заполнить это поле, если его нет то выпадет исключение
    new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());


Чтобы эту проблему устранить, для метода fillContactForm() сделаем доп параметр, в который будет передаваться информация о том, что мы сейчас делаем - создаем или модифицируем контакт.
Это "булевский" параметр , где true - означает форма создания, там должен быть элемент для выбора группы, false - означает что контакт модифицируется, элемента не должно быть.

public void fillContactForm(ContactData contactData, boolean creation) { 
	type(By.name("firstname"), contactData.getFirstname());
	...
	
}

Тесты тоже придется поменять 

public void testContactCreation() {
...
app.getContactHelper().fillContactForm(new ContactData(...), true);
}

public void testContactModification() {
...
app.getContactHelper().fillContactForm(new ContactData(...), false);
}

А теперь поменяем метод fillContactForm() в ContactHelper //самое важное **

Вместо того, чтобы анализировать есть элемент на странице или его нет и в зависимости от этого принимать какие то решения, используем следующую конструкцию  

if (creation) { //если это форма создания, значит элемент должен быть, поэтому нужно выбирать элемент из выпадающего списка
	new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());
} //если вдруг этого элемента нет, то тест упадет - и так должно быть
else { //а иначе , это форма модификации, в этом случае элемента быть не должно
  Assert.assertFalse(isElementPresent(By.name("new_group"))); //проверка того что элемента быть не должно 
}
} 

Если вдруг на форме модицикации контакта этот элемент появился то это баг, тест должен упасть

Запускаем оба теста
В одном случае выбирается группа из выпадающего списка
В другом - проверяется отсутствие этого выпадающего списка


В тесте модификации контакта происходит задержка
driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS); //после инициализации браузера устанавливается значение тайм аута 

Когда селениум пытается найти какой то элемент, он думает что из за медленной загрузки страницы элемент не успел появится. 
При проверки отсутствия элементов тайм аут мешает. Да, он помогает уменьшить нестабильность тестов. Драйвер автоматически ждем пока страница загрузится, элементы появятся. 
Когда нужно убедится, что опредленнные элементы отсутствуют, можно тай аут отключить =0. 

Теперь проверка отсутствия элементов выполняется мнгновенно. Если где то есть элементы, которые появятся не сразу, то могут возникнуть проблемы - нестабильность при выполнении тестов. Когда возникнут проблемы, тогда будем их решать. Перед поиском конкретного элемента можно увелить тайм аут, а после того как он найден сбросить обратно в 0.

** самое важное - мы сделали метод, который позволяет выполнять проверку наличия или отсутствия элементов. И пользуем этот методом для того чтобы заполнять форму, которая то содержит, то не содержит элемент.
При этом мы не просто ориентируемя на наличие отсутствие элемента. 
Тесты предсказывают должен быть этот элемент или нет.
При создании контакта список должен быть, поэтому мы пытаемся из него выбрать. 
А при модификации контакта такого списка не должно быть вообще, поэтому мы явно контролируем его отсутствие. А если он вдруг появится, то тесты упадут - будет обнаружен баг

}
Урок 36. Ленивые действия {

Оптимизированы переходы между страницами. Полезно когда веб приложение работает медленно, если проверка занимает меньше времени чем действие.  

Перед тем как перейти на страницу или кликнуть меню, имеет смысл сделать проверку. А может быть уже находимся на нужной странице и не надо никуда переходить. 

Эта оптимизация будет реализована в классе navigationHelper

Добавим проверки перед каждым кликом / переходом . Какой критерий выбрать? 

Можно проверять наличие каких то характерных элементов. Например, использовать комбинированный критерий - наличие заголовка с текстом Groups и кнопки для создания новой группы New groups. Такой критерий будет уникальным для конкретной страницы.

Cначала проверяем наличие заголовка
После того как убедились в наличии элемента, можно проверять текст
Для написания составного условия используем логические операции && (И / двойной амперсанд) || (или)


public void gotoGroupPage() {
if (isElementPresent(By.tagName("h1"))
		&& driver.findElement(By.tagName("h1")).getText().equals("Groups")
		&& isElementPresent(By.tagName("new"))) { 
		//ничего делать не надо, мы уже находимся на нужно странице

} else {
  click(By.linkText("groups"));
}
}

Но так писать не принято, чтобы основной блок if был пустым. Можно это условие развернуть, превратить в противоположное

public void gotoGroupPage() {
if (! isElementPresent(By.tagName("h1"))
		|| ! driver.findElement(By.tagName("h1")).getText().equals("Groups")
		|| ! isElementPresent(By.tagName("new"))) { 
		click(By.linkText("groups"));

}
} 


public void gotoGroupPage() {
if (isElementPresent(By.tagName("h1"))
		&& driver.findElement(By.tagName("h1")).getText().equals("Groups")
		&& isElementPresent(By.tagName("new"))) { 
		return; //сразу же выполнить выход из этого метода, не нужно дальше двигаться

} 
  click(By.linkText("groups")); //а иначе мы проскакиваем блок if и выполняем клик 
  
}


Таким образом выполняется нужная функциональность, и требования стиля тоже соблюдены.


}
Урок 37. Предусловия. Проверка и обеспечение. {

Использование контструкции if для проверки предусловий перед выполнением теста.

Вопрос функциональности: могут ли тесты вообще выполнить свою задачу?

Рассмотрим тест модификации группы. Если групп для модификации нет, то тест упадет

Чтобы исправить проблему, нужно добавить в тест проверку предусловия.
Перед модификацией группы, нужно убедится что она есть.
Кроме того, нужно отреагировать на ее отсутствие.

1 способ
Тест можно пропустить 

2 способ
Можно сделать попытку исправить ситуацию
Сначала создать группу, а потом продолжить выполнение теста, как будто она существовала с самого начала

Предусловие можно не только проверять, но и обеспечивать их выполнение.

Добавляем проверку предусловия  
@Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {     //помещаем новый метод в GroupHelper, чтобы сохранить имеющуюся архитектуру
    //копировать фрагмент кода не будем, создадим вспомогательный метод 
    }
    ...
  } 

Вставлять большой фрагмент кода из метода GroupCreationTests не будем, потому что возникает дублирование.
Как только копируем большой фрагмент кода из одного места в другое, значит должно возникнуть подозрение что то идет не так. Нужно создать вспомогательный метод, который поместим в GroupHelper

if (! app.getGroupHelper().isThereAGroup()) {     //помещаем новый метод в GroupHelper, чтобы сохранить имеющуюся архитектуру
      app.getGroupHelper().createGroup(new GroupData("test1", null, null)); //параметр - группа со всеми ее атрибутами
    }


public class GroupHelper extends HelperBase {
  public void createGroup(GroupData group) { //параметру дали любое имя, значение задается в тесте
    initGroupCreation(); //маленькие вспомогательные методы
    fillGroupForm(group);
    submitGroupCreation();
    returnToGroupPage();
  }
}

Возникает вопрос: а нужно ли оставлять маленькие вспомогательные методы?

Во первых наличие этих вспомогательных методов позволяет писать метод CreateGroup, так что он легко читается  - понятно из каких шагов состоит метод создания группы

Во вторых, может существовать такой тест, в котором этот сценарий до конца не доходит. Например, при проверки отмены создания группы. Тогда, сценарий можно легко изменить.

Реализуем метод isThereAGroup()

  public boolean isThereAGroup() { //будет проверяться наличие элемента, который пытаемся выбирать в методе SelectGroup (соответствует включенному чекбоксу)
    return isElementPresent(By.name("selected[]"));
  }


Теперь тест testGroupDeletion выполняется правильно, вне зависимости от того есть ли группа в начале выполнения теста или нет. 

}


Занятие 4. Коллекции и циклы  
Урок 38. Циклы. Многократные повторения похожих действий {

Циклы - конструкции, предназначенные для повторения похожих действий
Коллекции - наборы однотипных элементов

Циклы используются, чтобы сформировать или перебрать коллекцию. То есть выполнить однинаковые действия со всеми элементами некоторого набора. 

Конструкция, позволяющая описать два типа циклов 
выполнить действие определенное количество раз
выполнять действия пока не удовлетворится какое то условие окончания

Задача об определении простоты целого числа
Простое число делится только на себя и 1 
(2, 3, 5, 7, 11, ...)
Для проверки простоты числа нужно попытаться поделить его на все числа, которые меньше него. Если среди них найдется делитель, значит число не простое. Если делетелей нет, значит простое. 

Нужно число n делить последовательно на разные числа. Выполнять это действие многократно. Сколько раз? 
В данном случае нам известно сколько чисел нужно попробовать.
Нужно проверить все числа от 2 до n-1   

Для описания таких циклов используется конструкция for ()
Цикл for () обычно использует переменную счетчик, которая описывается внутри круглых скобок. Она не только декларируется, но и описывает все что с этим счетчиком происходит.
Ниже приведена простейшая форма цикла for:

for (инициализация; условие; итерация) оператор;

for (инициализация; место остановки; то что происходит с переменной счетчика на кажной итерации цикла) {действия которые должны происходить на каждой итерации; }



  
i = i + 1
i += 1 		сокращенная запись, увеличение переменной на заданное значение
i++ 		операция инкремент, увеличение переменной на 1 
% операция получения остатка от деления двух чисел  
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4*5 = 2)


	
public class Primes {

  public static boolean isPrime(int n) { 
    for (int i = 2; i < n ; i++) { // i = 2 потому что ищем делитель отличный от 1 и n
      if (n % i == 0) { //число делится без остатка
      return false; //не простое
      }
    }
    return true; //простое
  }
}

Напишим тест

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class PrimeTests {

  @Test
  public void testPrimes() {
    Assert.assertTrue(Primes.isPrime(Integer.MAX_VALUE)); //Integer.MAX_VALUE простое число
  }

  @Test
  public void testNonPrimes() {
    Assert.assertFalse(Primes.isPrime(Integer.MAX_VALUE-2)); //Integer.MAX_VALUE - 2 не простое число
  }
}




//цикл for может быть переписан в другой вид (эквивалентная форма)

public static boolean isPrimeWhile(int n) {
int i = 2;
while (i < n) { //while (до тех пор пока) условие окончания цикла 
  if (n % i == 0) { //можно избавится от констукции if, ту проверку которая выполняется включить в условие окончания цикла
	return false;
  }
  i++; //на каждой итерации цикла увеличиваем переменную на 1, выполнять эти действия будем пока i = n
}
return true; //если дошли до конца цикла i = n, значит делителя не найдено и возвращаем true
}

 
public static boolean isPrimeWhile(int n) {
int i = 2;
while (i < n && n % i != 0) { //тогда продолжаем искать делитель дальше
  i++; 
}
return i == n; //**

} 

**
Цикл завершится когда i = n, либо будет найдет какой то делитель. Значит после окончания цикла нужно проверить чему равно i
Если i == n, то ниодного делителя не найдено, n простое число. 
Если i != n, значит цикл закончился раньше, чем достигнуто максимальное значение и делитель найден. n не простое число. 	


Рассмотрим разные модификации фукнкции Prime()

int используется для представления 32бит чисел
long это 64бит числа

Две функции имеют одинаковые имена isPrime(), но разные типы переменных int и long. Конфликта не возникает, потому что java разбирается в типах данных.

Напишем тест 

@Test(enabled = false) //отключение теста
public void testPrimesLong() {
  long n = Integer.MAX_VALUE; //значение переменной будет преобразовано в тип long
Assert.assertTrue(Primes.isPrime(n));
}

В результате, время выполнения теста увеличилось в 3 раза

Теперь сократим количество итераций в 2 раза, время выполнения теста isPrime уменьшилось в 2 раза

public static boolean isPrimeFast(int n) {
for (int i = 2; i < n / 2; i++) { // делителя больше чем n / 2 не может быть. На что нужно умножить делитель, чтобы получилось n? Любой делитель числа меньше чем его половина (n / 2).
  if (n % i == 0) { 
	return false;
  }
}
return true;
}


@Test
public void testPrimesFast() {
Assert.assertTrue(Primes.isPrimeFast(Integer.MAX_VALUE));
}

Предположим что число n имеет делитель, это означает что у него есть второй делитель. То есть n представляется как произведение двух чисел. 
n = a * b 
(а || b) <= sqrt(n) //не могут быть оба делителя > чем корень из n, иначе их произведение > n

Поэтому проверять можно до Math.sqrt(n)   

Простой, но медленный метод проверки простоты заданного числа n известен как перебор делителей. Он состоит из проверки того, является ли n кратным целому числу от 2 до квадратного корня из n.

public static boolean isPrime2Fast(int n) {
    int m = (int) Math.sqrt(n); // значение корня явно приведем к целому числу, посколько корень может быть не целым
    for (int i = 2; i < m / 2; i++) {
      if (n % i == 0) {
        return false;
      }
    }
    return true;
  }

Когда используются циклы, нужно следить чтобы 
- количество повторений было неслишким большим 
- если итераций много, то нужно стремится выполнять действия на каждой итерации как можно быстрее

}
Урок 39. Коллекции наборы элементов {

В уроке пойдет речь о коллекциях и специальных разновидностей циклов, которые предназначены для перебора всех элементов коллекций

Коллекциями/контейнерами в Java принято называть классы, основная цель которых – хранить набор других элементов. 

Создадим новый класс Collections

Массив -  специальная конструкция на уровне языка, которая описывает коллекции 
Например, массивом является параметр функции main (String[] args). 
В нем передается какой то набор строк, те самые строчки которые указаны как параметры запуска в командной строке 

Сделаем массив 

public class Collections {

  public static void main(String[] args) {
    String[] langs = new String[4]; //объявлена переменная типа массив строк
  }
}

На то что переменная является массивом указывают первые [] в декларации (средство для работы с массивами)
Перед [] указывается тип элементов, которые могут хранится в этом массиве
При конструировании массива в квадратных скобках указывается его размер
new String[4] - созданный массив может хранить 4 элемента


public class Collections {

  public static void main(String[] args) {
    String[] langs = new String[4];
	//ниже происходит обращение к элементам массива в формате [порядковый_номер(индекс)]=значение 
    langs[0] = "Java"; //задегларировали и заполнили массив какими то значениями 
    langs[1] = "C#"; 
    langs[2] = "Python";
    langs[3] = "PHP";
  
  
  }
}

Эквивалетная запись элементов массива в одну строчку

public class Collections {

  public static void main(String[] args) {
    String[] langs = {"Java", "C#", "Python", "PHP"}; //Cоздается массив, который состоит из 4 элементов и заполняется какими то значениями
  
  }
} 

Устроим итерацию по элементам этого массива
 
public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 

  for (int i = 0; i <langs.length; i++){//у массива атрибут length 
	System.out.println("Я хочу выучить " + langs[i]); //выбираем из массива элемент с заданным индексом
  }
}
}

Специально для коллекций есть конструкция цикла, которая предназначена для перебора элементов коллекции 


public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 

  for (String l : langs){//теперь переменная l уже не индекс, это ссылка на элемент массива
	System.out.println("Я хочу выучить " + l); 
  }
}
}

Переменная l последовательно указывает на все элементы этой коллекции
Искусственная переменная счетчик не создается, она не нужна. Удобно иметь указатель на элемент массива.
Для каждого элемента l, входящего в коллекцию (массив) langs, выполнить какое то действие. 


Массив - это конструкция, которая поддерживается на уровне языка ([] особый синтаксис для описания массивов)
В Java есть другой способ работы с коллекциями, при помощи спец классов. Классы находятся в пакете java util	
	
https://docs.oracle.com/javase/7/docs/api/index.html?java/utl/Collections.html
	
В основании иерархии находится интерфейс Collection, который описывает произвольные коллекции.
Пример типов коллекций, которые расширяют интерфейс Collection

Интерфейс List (список)
Список предназначен для представления упорядоченных коллекций, то есть он похож на массив. 
В нем точно также как из массива можно взять элемент по индексу (порядковому номеру). В списке могут находится повторяющиеся или равные элементы. 
 
Интерфейс Set (множество)
Множество предназначено для представления неупорядоченных коллекций. У множества можно посчитать количество элементов, перебрать все элементы. Но нельзя взять элемент по индексу, потому что порядок элементов в множестве не определен. В множестве все элементы уникальны. Если попытаться добавить в множество элемент, который в нем уже содержится, то множество не изменится. 

У кажного интерфейса есть конкретные классы, которые эти интерфейсы реализуют. 

/*
Создаем переменную типа WebDriver и присваеваем в нее значение разных типов: firefoxdriver, chromedriver, iedriver
Там тоже существовали разные реализации для одного интерфейса */

Для интерфейса List существует несколько реализаций, самая популярная - класс ArrayList 
 

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 


  List<String> languages = new ArrayList<String>(); //название_интерфейса<тип_элемента>  = new имя_класса<>, который реализует этот интерфейс
  for (String l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

Теперь нужно этот список заполнить значениями 

В отличии от массива, размер которого заранее известен (он указан при инициализации и меняться не может), размер списка при создании равен 0 и его можно менять: добавлять, удалять элементы. При этом его размер будет меняться динамически. 

Итерация по элементам списка устроена также. 
Тот же цикл for у которого указывается переменная, пробегающая все значения какого то списка (коллекции) 

Вернемся к моменту инициализации массива и заполнения его значениями


Как записать элементы списка в одну строку 

Нельзя указать массив в качестве параментра конструктора
List<String> languages = new ArrayList<String>({"Java", "C#", "Python", "PHP"}); // ошибка


Как преобразовать массив в список

С помощью метода asList(), в который можно передать какое то количество строк в качестве параментра. Результатом метода будет список. Аналог инициализации массива с помощью {}. 

import java.util.Arrays;
import java.util.List;

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"};

  List<String> languages = Arrays.asList("Java", "C#", "Python", "PHP");

  for (String l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

По элементам списка можно устраивать итерации при помощи вспомогательной переменной счетчика. 

Список - это обычный объект. Поэтому при работе с объектом всегда обращаемся к нему, вызывая какой то метод // имя_объекта.название_метода

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"};


  List<String> languages = Arrays.asList("Java", "C#", "Python", "PHP");

  for (int i = 0; i < languages.size(); i++){ //атрибут size для списка
	System.out.println("Я хочу выучить " + languages.get(i)); // + обращается к элементу с помощью метода get (индекс)
  }

}
}

Можно создать список элементов произвольного типа //но так лучше не делать 

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 


  List languages = new ArrayList<String>();  
  for (Object l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

}
Урок 40. Количество элементов в коллекции {

C помощью коллекций мы научимся получать список элементов со страницы веб приложения и определять их количество.

Начнем с теста для создания групп

Создадим метод позволяющий узнать количество групп и добавим его проверку 


package ru.testjava.addressbook.tests;

import org.testng.Assert;
import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
	int before = app.getGroupHelper().getGroupCount(); //количество групп до добавления
    app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    int after = app.getGroupHelper().getGroupCount(); //количество групп после добавления
    Assert.assertEquals(after, before + 1); //проверка количества элементов 
  }
}


Для реализации новых методов getGroupCount() воспользуемся методом драйвера (с локатором в качестве параметра)

public int getGroupCount() {
    return driver.findElements(By.name("selected[]")).size(); //метод findElements возвращает список элементов т.е. объект типа лист. У этого списка нужно получить размер и затем вернуть его. Это количество и будет результатом работы метода.

  }

Если элемент не найден, то метод findElements() возвращает пустой список, в отличии от метода findElement(), который падает и выбрасывает исключение NoSuchElementException.


}
Урок 41. Выбор элемента списка по порядковому номеру {


Сейчас в тестах для удаления и модификации групп неявно предполагается, что выбирается первая группа
Эта логика спрятана внутри метода selectGroup()

Реализуем возможность передавать туда параметр - индекс или номер группы, которую нужно изменить / удалить.
0 // первый элемент 
before - 1 //последний = колличество - 1 (т.к. нумерация начинается с 0)


Теперь метод selectGroup() будет принимать в качестве параметра индекс элемента

public void selectGroup(int index) { 
    click(By.name("selected[]"));
  }
Нужно как то использовать этот индекс

1) Можно построить локатор, который сразу найдет нужный элемент. В самом локаторе использовать этот индекс.
2) Лучше работать со списком элементов


  public void selectGroup(int index) {
    driver.findElements(By.name("selected[]")).get(index).click(); //находим все элементы по локатору, затем среди этих элементов выбираем нужный по индексу, и именно по этому элементу выполняем клик
  }

}
Урок 42. Формирование коллекции {

Со страницы веб приложения получим список элементов, который содержит информацию о группах. В цикле последовательно перебирем эти элементы, извлечем из каждого элемента текст и другую информацию. 
На основании полученной информации построим собственные объекты типа GroupData (модельные объекты) и сформируем из этих объектов список.  Список будет использоваться в тестах сравнения. В этом уроке для проверки корректности изменения количества групп, в следующем - для сравнения содержимого групп.


Начнем с теста создания группы 

//Как будет выглядеть тест после того как нужный метод будет реализован?

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList(); //переменная before раньше содержала количество элементов, теперь будет содержать список элементов (объектов) типа GroupData
    app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    List<GroupData> after = app.getGroupHelper().getGroupList(); //переменная after содержит список элементов, после того как будет создана новая группа
    Assert.assertEquals(after.size(), before.size() + 1);
  }



Выполним реализацию метода getGroupList()

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();//создадим список, который будем заполнять
    return groups; //в конце метода этот список будет возвращаться
  }

ArrayList<> потому что мы должны указать конкретный класс, который реализует интерфейс List


Далее нужно заполнить список объектами. Данные для создания этих объектов будут извлекаться со страницы веб приложения.
Для этого нужно понять откуда, из какого элемента со страницы можно извлечь нужную информацию.

<span class="group">
	<input type="checkbox" name="selected[]" value="1" title="Select (test1)">
	"test1"
	<br>
</span> 

Возьмем элемент span, который имеет класс group и получим его текст. Тем самым мы сразу получаем название группы.

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group")); //найти все элементы, которые имеют тег span и класс group
    return groups;
  }

Теперь нужно по этим элементам пройти в цикле и для каждого из них выполнить какие то дейсвия

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();	//создадим список, который будем заполнять названиями групп
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group")); //ищем все элементы с тегом span и классом group и создаем новый список
    for (WebElement element: elements) {	//переменная element пробегает по списку
      String name = element.getText(); 	//из каждого элемента получаем текст, это будет имя группы. При работе с элементом всегда обращаемся к нему, вызывая какой то метод (имя_элемента.название_метода)
      GroupData group = new GroupData(name, null, null); 	//создаем объект типа GroupData, в котором header & footer нам неизвестны
      groups.add(group);	//добавляем созданный объект в список
    }
      return groups;
  }

/* Теперь сравниваем размеры списков, которые получены с помощью метода getGroupList(). Фактически проверяется тоже самое (количество групп)
Следующий шаг - сравнение списка целиком */

Перепишем тесты для удаления и модификации групп, чтобы в них использовался новый метод, возвращающий список групп.

}
Урок 43. Сравнение коллекций {

Реализуем проверку, которая контролирует что действительно удалилась нужная группа.
Для этого мы будем сравнивать списки целиком до и после удаления. 

Начнем с теста для удаления групп

Имеем два списка after и before, где размер after больше размера before на 1 элемент.

Поэтому перед тем как сравнивать сами списки, удалим лишний элемент. 

 @Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() - 1);
    app.getGroupHelper().deleteSelectedGroups();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size() - 1);

    before.remove(before.size() -1); //из списка удаляем элемент с тем же индексом, который выбирали 
  }

Теперь имеем два одинаковых списка before и after. Переменная before ссылается не на оригинальный старый список, а на старый список, в котором удален лишний элемент.
Старый список должен содержать теже элементы, что и новый.
Проверить совпадение элементов можно с помощью цикла.

for (int i = 0; i < after.size(); i++){
  Assert.assertEquals(before.get(i), after.get(i));
}

Запускаем тест, получаем сообщение об ошибке 

Expected :ru.testjava.addressbook.modul.GroupData@fd0e5b6
Actual   :ru.testjava.addressbook.modul.GroupData@4eed46ee

Из описания не понятно какие именно элементы списка сравнивались // тип@идентификатор (адрес объекта в памяти)


Чтобы увидеть текстовое представление элемента, нужно в классе GroupData сгенирировать специальный метод toString(). Он используется для преобразования в строку.

Code > Generate > toString()   

Далее нужно указать какие именно атрибуты объекта должны влючаться в строковое предствление. Указываем только name, так как header и footer неизвестны.

  @Override
  public String toString() {
    return "GroupData{" +
            "name='" + name + '\'' +
            '}';
  }

Теперь сообщение об ошибке имеет вид

Expected :GroupData{name = 'test1'}
Actual   :GroupData{name = 'test1'}

Java не знает как сравнивать объекты типа GroupData. Никаких правил для сравнения этого типа данных нет.
Нужно определить собственные правила сравнения, с помощью метода Equals. Он будет сравнивать атрибуты объекта по смыслу. 

Code > Generate > equals() and hashCode()

Указываем какие атрибуты будут участвовать в сравнении (указываем только name) 
Оставляем пустыми Select all-null fields  // указать какие поля не могут принимать значения null 

Тест успешно завершился. Теперь списки логически равные, потому что они состоят из равных объектов по смыслу. 
Списки построены отдельно, независимо друг от друга. Объекты физически разные, они хранятся в памяти в разных местах.  

Тестовый фрейворк умеет сам сравнивать списки без указания цикла.
Можно вызвать метод Assert.assertequals(befor, after) и передать туда два списка. 

  @Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().deleteSelectedGroups();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size() -1);

    before.remove(before.size() -1); 
    Assert.assertEquals(before, after);

  } 

}
Урок 44. Множества. Неупорядоченные коллекции {


Реализуем аналогичную проверку для теста модификации групп. Необходимо учесть, что при модификации группы меняется ее имя. Группа может перепрыгнуть на другое место в списке, потому что в тестируемом приложении группы сортируются по именам. Поэтому нужно сравнивать без учета порядка.  

Нужно преобразовать эти списки в множества и сравнить их.


public class GroupModificationTests extends TestBase{

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData("test1", "test2", "test3"); //4- добавили локальную переменную
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    //3 - ниже модифицируем старый спискок, чтобы предсказать ожидаемый результат

    before.remove(before.size() -1); //удаляли последний элемент
    before.add(group); //вместо него добавим тот, который должен появится после модификации


    //1 - добавим сравнение множеств

    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); // 2 - преобразуем списки в множества
  }
} 


Можно было модифицировать объект, который находится в этом списке, не удаляя его от туда и не добавляя вместо него другой. Но с логической точки зрения никакой разницы нет. Проще удалить не нужный и вместо него добавить тот, который нам требуется. А уже после того как это сделано, можно преобразовать полученнные списки в множества и сравнивать их друг с другом.        

Запускаем тест, он зеленый. Но не все так хорошо на самом деле. 

Модифицируем состояние тестируемой системы, создадим список из трех групп test1, test2, test3

Что сделает тест? 
Он меняет последнюю группу test3, давая ей имя test1
Теперь у нас две группы с именем test1 и одна с test2

Поставим точку остановы в строке и выполним тест в отладчике 
Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));


У нас есть before и after, в каждом из них находится по 3 элемента.
  
Провалимся во внутрь метода assertEquals()
и поставим точку остановки внутри него 

public static void assertEquals(Set<?> actual, Set<?> expected) { //сравниваются два множества, построенных из разных списков
    assertEquals(actual, expected, null);
  }
  
Продолжаем выполнение и видим, что здесь сравниваются 2 множества, имеющих размер 2.

Куда пропал третий элемент?
Проблема в том что множества не позволяют дублирование элементов, а мы сравниваем объекты (группы) по именам. Следовательно, все группы с одинаковыми именами схлопываются.
 
Вывод: если группа test3 получила бы имя test2 вместо test1, то наш тест решил бы что множества равны. 

test1		test1
test1		test2
test2		test2

Это некорректная проверка.

Решение 
Если бы группы имели уникальные идентификаторы, тогда бы при преобразовании списка в множества схлопывания не происходило.
Нужен уникальный идентификатор для каждого объекта. 


<input type="checkbox" name="selected[]" value="1" title="Select (test1)"> //value="1" 


Извлечем эти идентификаторы и будем их использовать при сравнении объектов

1 часть
 
public class GroupData {
  private final String id; //добавим атрибут 
  private final String name;
  private final String header;
  private final String footer;

  }
  public GroupData(String id, String name, String header, String footer) { //добавим параметр в конструктор
    this.id = id; //присваивать значение параментра в атрибут - в поле объекта
    this.name = name;
    this.header = header;
    this.footer = footer;
  }


2 часть
Делаем для этого поля метод getter, которое позволяет получить значение поля 
Code > Generate > Getter

public class GroupData {
  public String getId() {
    return id;
  }
}

Перегенерируем методы toString() / equals() 

Code > Generate > toString //указываем для id и name и заменяем для всех
Code > Generate > equals and hashCode //заменить существующие, default, указываем для id и name

3 часть

Модификация GroupHelder

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));// 3 - получили элемент, который является частью списка
    for (WebElement element: elements) {
      String name = element.getText();
	  String id = element.findElement(By.tagName("input")).getAttribute("value");  //2 - откуда взять id?  4 - Ищем внутри одного элемента другой и берем из него атрибут value
      GroupData group = new GroupData(id ,name, null,null); //1 - GroupHelper должен откуда то id извлекать, и передавать его в качестве параметра в конструктор, он используется при сравнении
      groups.add(group);
    }
      return groups;
  }

//**но это не чек-бокс - это элемент внутри которого, находится чек-бокс
<span class="group">
	<input type="checkbox" name="selected[]" value="5" title="Select (test2)">
	"test2"
	<br>
</span>


После модификации, появились ошибки компиляции
- можно их исправлять, везде передавать вкачестве идентификатора null 
- можно добавить конструктор в классе GroupDate

//группа с неизвестным идентификатором, она не прочитана из веб интерфейса, а создана искусственно 	
  public GroupData(String name, String header, String footer) { //не принимает идентификатор (String id) в качестве параметра 
    this.id = null; //если вызывается этот конструктор, то присваивается null в качестве идентификатора
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  public GroupData(String id, String name, String header, String footer) {
    this.id = id;
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

Повторяем запуск отладчика с выставленными ранее точками остановы

В методе assertEquals() видим что сравниваются два множества, которые имеют размер 3
Схлопывания нет, потому что все элементы различные. У них разные идентификаторы. Но с логической точки зрения, они должны быть равны. 

Тест падает. Проблема в том, что множества оказываются разными. Во втором множестве, есть элемент, у которого id = null. Этот тот самый, который модифицировали.  
 
Нужно ему установить правильный идентификатор. 
А откуда его узнать? Из уже существующего объекта, это будет последний элемент списка before

GroupData group = new GroupData(before.get(before.size() -1).getId(),"test1", "test2", "test3"); //используем идентификатор той группы, который был до модификации

При модификации группы мы указываем новые name, header, footer, а идентификатор остается старым.


}
Урок 45. Поиск максимального элемента в коллекции {

Добавим аналогичную проверку в тест для создания групп.

Проблема: новая созданная группа добавляется не в конец, а в какое то произвольное место
Решение: сравнивать старый список с новым нужно без учета порядка

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null); //2 - выделим переменную
    app.getGroupHelper().createGroup(group); //3 - используем выделенную переменную
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    //предсказываем ожидаемый результат
    before.add(group); //1 - добавляем в список ту группу, которую создали в тестируемом приложении
	
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); //4 - преобразуем списки в множества и сравниваем их
  }

Проблема: Что насчет идентификатора новой добавленной группы? Как узнать какой идентификатор присвоен новой группе?
Решение: Мы может опираться на предположение, что в новом списке это добавленная группа имеет максимальный идентификатор. //В тестируемом приложении новому индентификатору присваивается максимальное значение для того, чтобы они были уникальными.
Среди всех элементов, которые входят в новый список after, нужно найти тот, который имеет максимальный идентификатор. Это будет предсказанным ожидаемым идентификатором новой группы. Группа с таким идентификатором должна имеить те свойства, с которыми мы пытались ее создать.


Как узнать максимальный идентификатор?

Для начала меняем ему тип String на int
private final String id; // тип Строка не подходит для сравнения 

Испортились методы, в которых этот атрибут используется. Перегенерируем equals() и hashCode().


Исправим метод getGroupList(), который этот идентификатор вычисляет. Теперь он должен быть не строкой, а числом.

Было 
public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      String id = element.findElement(By.tagName("input")).getAttribute("value");
      GroupData group = new GroupData(id, name, null,null); 
      groups.add(group);
    }
      return groups;
  }

Стало
public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
	  int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value")); // преобразуем значение атрибута из строки в число с помощью метода Integer.parseInt()
      GroupData group = new GroupData(id, name, null,null);
      groups.add(group);
    }
      return groups;
  }

Теперь можно перейти к сравнению и определению максимального идентификатора


public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group); 
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);


    before.add(group);
    //устраиваем цикл по всем элементам
    int max = 0;  
    for (GroupData g : after) {
      if (g.getId() > max) {
        max = g.getId();
      } 
    group.setId(max); //в конце найдется самый большой, присвоим его в качестве идентификатора новой группы; сгенерируем метод setter 
    }
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }

}


Для начала присваиваем переменной max значение 0, потом постепенно сравниваем уже найденный максимум с идентификатором каждого элемента, если идентификатор окажится больше, то значение переменной max меняем на новый найденный максимум.  


Сгенерируем метод setter 

//сеттер всегда имеет модификатор void и только один параметр, для изменения значения одного поля

private final int id; //модификатор final означает что менять атрибут нельзя. То значение, которое присвоено в конструкторе оно и остается навсегда. 

Мы хотим менять индентификатор, final убирем
private int id;


Запускаем тест. Тест зеленый. 
  
}
Урок 46. Лямбда-выражения (анонимные функции) и элементы функционального программирования {

До версии Java 8 можно было функции только вызывать, обращаться к ним по имени. 

Основаная идея функционального програмирования заключается в том, что с функцией можно работать как с объектом. Ее можно присвоить в переменную, передать в качестве параметра при вызове другой функции. То есть функция такая самостоятельная сущность.

//поиск элемента с максимальным идентификатором 
//старый способ сравнения
int max = 0;
for (GroupData g : after) {
  if (g.getId() > max) {
	max = g.getId(); 
  }
}

Как сделать функцию , которая вычисляет максимальный элемент для списка, который содержит произвольные объекты (не только числа)?
Нужно передать в такую функцию в качестве параметра описание того, как сравниваются элементы. То есть передать функцию, которая умеет сравнивать объекты. 


1 способ
Использовать встроенную возможность, которая появилась в стандратной библиотеке Java 8

Список можно превратить в поток Stream.

Превращаем список в поток, у него есть метод max(), который позволяет вычислять максимальный элемент. В метод max() передадим в качестве параметра компаратор (сравниватель).

after.stream().max(byId) //Если предположить что метод отработал, то есть нашел максимальный элемент, то мы можем при помощи метода get() этот элемент получить и взять у него идентификатор  

int max = after.stream().max(byId).get().getId(); //чтобы это заработало, реализуем сравниватель 

Alt + Enter > Create local variable //создается переменная правильного типа 


Comparator<? super GroupData> byId; //компаратор, который умеет сравнивать объекты типа GroupDate
int max = after.stream().max(byId).get().getId();


Инициализируем переменную, присвоим в нее конкретное значение //добавим = new Comparator<GroupData>()

Comparator<? super GroupData> byId = new Comparator<GroupData>() {
      @Override
      public int compare(GroupData o1, GroupData o2) {
        return 0;
      }

}

Компаратор - это интерфейс, который не имеет реализации он только декларирует, объявляет какие методы должны быть. Но реализации этих методов не содержит. 
Можно создать класс, который наследуется от / реализует этот интерфейс. Но это делать не обязательно. Когда создаются такие одноразовые объекты, можно использовать аннонимные классы для которых реализация пишется здесь и сейчас.    


//новый способ сравнения
//1 - сравниватель для двух объектов типа GroupData
Comparator<? super GroupData> byId = new Comparator<GroupData>() { //должен быть реализован один единственный метод compare(), при помощи которого должны сравниваться два объекта типа GroupData
  @Override
  public int compare(GroupData o1, GroupData o2) {
	return Integer.compare(o1.getId(),o2.getId()); //используем метод compare(), который умеет сравнивать числа
  }
};
//2 - вычисление максимального объекта 
int max1 = after.stream().max(byId).get().getId(); //max(byId) сравниваются объекты при помощи компаратора 
group.setId(max1);


Лямбда-выражения - анонимные функции 


Переделаем анонимный класс в анонимную функцию //установив режим совместимости Project Structure > Modules > Language level - 8

Comparator<? super GroupData> byId = new Comparator<GroupData>() {} //класс new Comparator<GroupData>() является функциональным интерфейсом , поэтому его можно заменить на лямбда - выражение 
@FunctionalInterface - означает что внутри него имеется одна единственная функция, которая может быть представлена как самостоятельная сущность.   

Comparator<? super GroupData> byId = (Comparator<GroupData>) (o1, o2) -> Integer.compare(o1.getId(),o2.getId());
    int max1 = after.stream().max(byId).get().getId();
    group.setId(max1);



//названия параметров (o1, o2) -> тело функции Integer.compare(o1.getId(),o2.getId());
//от локальной переменной можно избавится, аннонимную функцию лямбда выражение можно передать в качестве параментра при вызове метода max() 
	
int max1 = after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId();	
	
/*список превращаем в поток
 по этому потоку пробегает функция сравниватель и находит максимальный элемент
 при этом сравниваются объекты типа GroupData путем сравнивания их индентификаторов
 get() на выходе этой функции будет максимальный объект, то есть группа с максимальным идентификатором
 getId() остается взять этот идентификатор
*/ 
	
	
	
  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    group.setId(after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId());
    before.add(group);
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }	
	

}
Урок 47. Сортировка списков {

В тесте для модификации групп реализуем другой способ решения проблемы сортировки.
Вместо того, чтобы игнорировать порядок, мы наведем свой собственный. Например, упорядочим группы по идентификаторам. 


  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData(before.get(before.size() -1).getId(),"test1", "test2", "test3");
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    before.remove(before.size() -1);
    before.add(group);
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }
/* 
Мы не знали в каком порядке находятся элементы. После модификации группы она могла находится в другом месте. 
Потому что сортировка в тестируемом приложении выполняется по неизвестному правилу. 
Мы решили полностью игнорировать порядок и сравнивать множества вместо списков.
*/

Как сортировать список?

// Старый способ Collections.sort()

В Java 8 у списка появился метод sort(), который в качестве параметра принимает компаратор т.е. описание правил сравнения объектов 

before.sort(byId); //сравниваем по идентификаторам

Просим среду разработки, чтобы она создала локальную переменную byId

Сразу пишем лямбда-выражение
 
Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId()); 
/*
= анонимная функция, которая на вход принимает два параметра(группа_1, группа_2) 
и выполняет сравнение идентификаторов Integer.compare(первый_идентификатор,второй_идентификатор) 
это и будет возвращаемый результат этой аннонимной функции
*/


  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() - 1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData(before.get(before.size() - 1).getId(),"test1", "test2", "test3"); 
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    before.remove(before.size() - 1);
    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }

Модифицируем тест для создания группы
Упорядочим группы и сравним получившиеся списки, в которых группы находятся в одинаковом порядке. При этом даже не нужно определять идентификатор новой добавленной группы, потому что она должна оказаться в конце.

было
  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    group.setId(after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId());
    before.add(group);
	
	 
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); 
  }

стало

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }

Как добится чтобы новая группа оказалась в самом конце?  

  public GroupData(String name, String header, String footer) {
    this.id = Integer.MAX_VALUE; //дефолтное значение для индентификатора  
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

Теперь достаточно сравнивать только name

Перегенерируем функцию equals()

Запустим тест. Тест зеленый.


}


Занятие 5. Улучшение кода тестов. Работа со строками
Урок 48. Как правильно запускать браузер {

Оптимизируем тесты 

Для каждого теста запускается отдельный экземляр браузера.
Можно попробовать сэконоить, использовать один и тот же браузер (одно и тоже окружение для выполнения нескольких тестов подряд).

//Надо стараться делать тесты независимыми, чтобы они могли для себя подготовить тестовую ситуацию. Где каждый тест проверяет предусловие и сам для себя создает все что ему необходимо.     


Ведущую роль играет класс TestBase, в котором вызывается метод init() в начале (в классе ApplicationManager, который в свою очередь запускает браузер) и метод stop() в конце. 
Это происходит перед каждым тестовым методом, потому что указана анатация @BeforeMethod  //дает указание тестовому фреймворку выполнять метод setUp() перед каждым тестовым методом  

Посмотрим какие есть варианты Ctrl+Space

@BeforeMethod //тот метод, который помечен этой анатацией, запускается перед каждым тестовым методом

@BeforeClass //запускается перед всеми тестовыми методами, которые выходят в какой-то класс 
 
@BeforeGroups //в TestNG можно указать, что тестовый метод принадлежит какой-то группе 

@BeforeSuite 

В TestNG Suite всегда один единственный, он соответствует одному запуску. Он может состоять из нескольких тестов.
Сделать Suite, который состоит из нескольких тестов, можно только с помощью специального конфигурационного файла. 
Если тесты запускаются из среды разработки (ПКМ на пакет / класс), то автоматически создается Suite, который состоит из одного единственного теста. То есть в данном случае, никакой разницы между Suite и тест нет. Она возникает, когда используется конфигурационный файл.
Suite всегда один единственный, а тестов может быть несколько. Тест это часть Suite. Тест включает в себя классы. Классы состоит из нескольких тестовых методов. Suite > Test > Class > Method


Если мы хотим запустить один единственный экземляр браузера, его нужно запустить в методе, который помечен анатацией @BeforeSuite, а останавливать @AfterSuite.

Тесты упали, потому что не получили доступ к браузеру. 

Тесты разложены по разным классам. И для того чтобы их запустить TestNG, создает экземляр тестового класса, этот тестовый класс наследуется от класса TestBase  //получает доступ к переменной app

Но когда создается другой экземляр, другого тестового класса, то это будет совсем другая переменная app. Каждая из них ассоциирована со своим объектом. Этих объектов много, по одному для каждого тестового класса. А метод @BeforeSuite выполняется один раз. 
В каком именно из этих многочисленных объектов он будет выполняться? Ни в каком.
 
TestNG сначала создаст экземляр класса TestBase, в котором будет ссылка на ApplicationManager и в этом объекте выполнит инициализацию, а потом создаст экземляр какого то тестового класса, в котором тоже будет ссылка на ApplicationManager. Но она не будет инициализирована.  
Единственная инициализированная, находится в том самом объекте типа TestBase, который вообще не используется для запуска тестов. Он играет чисто вспомогательную роль. 

Как эту проблему решить?
Нужно ссылку на ApplicationManager сделать общей для всех тестов. Объявим ее static

protected static final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);

Все функции находятся внутри какого-то класса. Несмотряна это, для вызова static функции не нужно создавать объект этого класса. К ней можно обращаться непосредственно / на прямую. Тоже относится к переменным. 


Если пометить переменную static, то она становится независимой. То есть не является частью какого-то объекта. Это самостоятельная глобальная переменная. К ней может получить доступ кто угодно по ее имени (TestBase.app)

**
TestNG в самом начале создает экземляр класса TestBase, в нем выполняется код инициализации app.init(), который инициализируем глобальную переменную. Далее создается экземляр класса например  GroupCreationTests, который тоже пользуется этой переменной. Потом создается другой экземляр, другого класса, и в самом конце TestNG выполняет tearDown(), обращается к глобальной переменной app.stop().   
}
Урок 49. Улучшение кода тестов - ещё немного реструктуризации кода {

Код тестовых сценариев - фасадная часть работы тестировщика автоматизатора 

В TestBase есть глобальная инициализация @BeforeSuite 

Для одного теста или группы тестов может существовать локальные инициализации, которые нужны чтобы подготовить состояние именно для конкретного теста.

//данный фрагмент кода будет общий для всех тестов проверки модификации групп 
    app.getNavigationHelper().gotoGroupPage();  
    if (!app.getGroupHelper().isThereAGroup()) { //проверка предусловия
      app.getGroupHelper().createGroup(new GroupData("test1", null, null)); //если предусловие не выполняется, то подготовка состояния
    } 

Поместим его в отдельный метод с анатацией @BeforeMethod


public class GroupModificationTests extends TestBase {

  @BeforeMethod //перед каждым тестовым методом должна выполняться проверка предусловия
  public void ensurePreconditions() {
    app.getNavigationHelper().gotoGroupPage();
    if (!app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
  }

  @Test
  public void testGroupModification() {
    List<GroupData> before = app.getGroupHelper().getGroupList();
    int index = before.size() - 1;
    GroupData group = new GroupData(index, "test1", "test2", "test3");
    app.getGroupHelper().modifyGroup(index, group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size());

    before.remove(index);
    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(), g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }


}

Самое главное требование, которое предъявляется к тестам - это легкость их восприятия / понятность. 

А когда инициализация находится в другом классе, это негативно складывается на восприятии. 


}
Урок 50. Улучшение названий методов {

 

Некотороые методы начинаются на get /set.
Наличие такого метода обычно означает, что у объекта есть атрибут. Но прямой доступ к этому атрибуту не разрешен. И к нему можно обратиться только с помощью вспомогательного метода - название которого обычно является производным от названия атрибута. 


В AM имеется атрибут, который называется NavigationHelper. Ему соответствует парный метод getNavigationHelper(). //традиционное соглашение об именах 

Называйте методы так, чтобы их было легко читать. 

}
Урок 51. Fluent-интерфейсы {

Fluent (плавный / гладкий) - интерфейсы, целью которых является увеличение понятности и легкости чтения кода.

Основной прием реализации интерфеса - вытягивание методов в цепочки / каскадный вызов методов //app.contact().create()



В классе GroupData удаляем отметку final

Генерируем Setters

Меняем завание getName на withName

добавляем возвращаемое значение

меняем тип void на GroupData


public GroupData withId(int id) {
    this.id = id;
    return this; //метод будет возвращать тот самый объект, в котором он вызван. Это позволяет строить каскады - вытягивать методы в цепочку
  }

Удаляем конструкрторы, добавив дефолтное значение атрибуту 


Фактически у нас остается один единственный конструктор, который не принимает никаких параметров. 
И при этом новый созданный объект инициализируется дефолными значениями

public class GroupData {
  private int id = Integer.MAX_VALUE; //макс значение перенесли из удаленного констуктор
  private String name; //три атрибута будут иметь значение null
  private String header;
  private String footer;   

}


Теперь сломались все места в которых сломался контсруктор. Исправляем

было
public void testGroupCreation() {
  ...  
    GroupData group = new GroupData("test2", null, null);
  ...	
	}



стало
public void testGroupCreation() {
  ...  
    GroupData group = new GroupData().withName("test2");
  ...	
	}

Теперь легко читается как обычный английский тест, в этом и состоит идея гладкости 

GroupData group = new GroupData().withId(before.get(index).getId()).withName("new1").withHeader("new2").withFooter("new3");
    

Аналогично меняем в других методах, где создается новый объект типа GroupData

public List<GroupData> list() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value")); 
      GroupData group = new GroupData().withId(id).withName(name); //со значением null не надо указывать 
      groups.add(group);
    }
}

Каждый вызываемый метод, возвращащает тот же самый объек, который мы модифицируем шаг за шагом. И в конце тоже возвращается тот же самый объект, который в конечном итоге присваивается в переменную.   	
	
	
Конструировать объекты стало приятнее, потому что мы явно указываем какой атрибут принимает какое значение.	
	
Шаблон билдер - интерфейс, который описывает способ использования плавных интерфейсов для конструирования объектов  	


}
Урок 52. Повсеместное использование уникальных идентификаторов объектов {


Нужно определить способ для того, чтобы найти нужный элемент, который нужно удалить /модифицировать. 

Можно искать элементы по уникальным идентификаторам, вместо порядковых номеров. 

Перейдем к тесту для создания групп

Как опредилить максимальный идентификатор (нового элемента)?

Переделаем GroupHelper

Создадим метод, который возвращает не список, а уже готовое множество 

  public Set<GroupData> all() {
    Set<GroupData> groups = new HashSet<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value"));
      groups.add(new GroupData().withId(id).withName(name));
    }
    return groups;
  }




public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.goTo().groupPage();
    Set<GroupData> before = app.group().all();
    GroupData group = new GroupData().withName("test2");
    app.group().create(group);
    Set<GroupData> after = app.group().all();
    Assert.assertEquals(after.size(), before.size() + 1);

    before.add(group);
    Assert.assertEquals(before, after);
  }

}

В классе GroupData указываем сравнение по id и name, чтобы элементы не схлопывались


В тесте новой добавленной группе нужно присвоить идентификатор

group.withId(вычисление максимального идентификатора)

group.withId(after.stream().mapToInt((g) -> g.getId()).max().getAsInt(); //поток типа GroupDate превращаем в поток идентификаторов (чисел)
before.add(group);
Assert.assertEquals(before, after);


Функция mapToInt() в качестве параметра принимает описание того, как объект преобразуется в число. 
То есть туда мы должны передать аннонимную функцию, которая будет последовательно применяться ко всем элементам потока и каждый из них будет последовательно преобразовать в число. 
В результате, из потока объекта типа GroupData получаем поток целых чисел.   
 

(g) -> g.getId() //аннонимная функция, которая в качестве параметра принимает группу, а в качестве результата выдает идентификатор этой группы, то есть преобразует объект в число 

поток целых чисел. max() //функция не принимает никаких параметров, потому что Java сама умеет сравнивать числа 

getAsInt() //преобразуем в обычное целое число  

/*
before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);



*/



Модифицируем тест для удаления групп

заменяем вызов метода list() на all()

меняем тип переменной List на Set

оранжевый цвет намекает на то, что какие то проблемы есть: "Множество объектов типа GroupData не может содержать множество объектов типа Integer"

Фармально это ошибкой не является, потому что метод remove() на вход принимает произвольный объект (Object). Можно попытаться удалить из этого множесва все что угодно. Но с логической точки зрения, удалять нужно группу. А по индексу из множества удалить ничего нельзя, потому что порядок не определен. 
Следовательно, вместо index нужно использовать какой то конкретный объект. 


GroupData deletedGroup = before. //нужно извлечь любой элемент из множества (нам все равно какой удалять), но методов get нет. и нет методов чтобы возвращал объект типа GroupData	
before.remove(deletedGroup);

Сначала нужно получить iterator(), который позволяет последовательно перебирать элементы, а потом вызвать метод next(), он вернет первый попавшийся элемент множества. 

При этом если множество пустое, то возникнет проблема. Будет выбрашено исключение, которое сообщает что извлечь элемент из множества не удалось. Для этого у нас есть проверка предусловия, поэтому точно знаем что множество не пустое.

GroupData deletedGroup = before.iterator().next();
before.remove(deletedGroup);
 
//нужно удалять элемент по идентификатору

app.group().delete(deletedGroup);
 
Можно в качестве параметра передавать не идентификатор, а непосредственно объект, который сожержит id и всю остальную информацию об удаляемой группе

Реализуем новый вспомогательный метод delete()

  public void delete(int index) {
    selectGroup(index); //выбор по порядковому номеру
    deleteSelectedGroups();
    returnToGroupPage();
  }

  public void delete(GroupData deletedGroup) {
    selectGroupById(deletedGroup.getId()); //выбор по идентификатору номеру
    deleteSelectedGroups();
    returnToGroupPage();
  }

Нужно сделать второй метод selectGroupById(), потому что идентификатор это тоже целое число, и нельзя использовать один и тот же метод selectGroup(), у которого тип параметра int потому по типу параметра различить не получается. 

  public void selectGroup(int index) {
    driver.findElements(By.name("selected[]")).get(index).click();
  }

  public void selectGroupById(int id) { //если передается идентификатор, то нельзя взять список элементов, и потом по индексу выбрать нужный
    driver.findElement(By.cssSelector("input[value='" + id + "']")).click();//вместо этого нужно сразу построить локатор элементов, в котором id участвует 
  }

//локатор: тег input атрибут value="75" (склеивание строки)
// findElements замена на findElement потому что сразу найдется нужный элемент

Теперь элемент из списка выбирается случайным образом

Перейдем к тесту для модификации групп

	//теперь мы работаем с несортированными наборами элементов
	
  public void testGroupModification() {
    Set<GroupData> before = app.group().all(); //set , all
    GroupData modifiedGroup = before.iterator().next(); // select random object
    GroupData group = new GroupData().withId(modifiedGroup.getId()).withName("new1").withHeader("new2").withFooter("new3");
    app.group().modify(group);  
    Set<GroupData> after = app.group().all();
    Assert.assertEquals(after.size(), before.size());

    before.remove(modifiedGroup);
    before.add(group);
    Assert.assertEquals(before, after);
  }


}
Урок 53. Hamcrest - улучшение внешнего вида проверок {

Библиотека Hamcrest предоставляет флуент интерфейс. 
Вместо класса Assert используется класс MatcherAssert


MatcherAssert.assertThat(after, CoreMatchers.equalTo(before));
	
//ctrl + space чтобы подтянулись названия методов, а не только классов

//CoreMatchers проверялка	
	
	
Указывать префекс необязательно, вместо этого можно выполнить статический импорт //Это можно делать только для статических (глобальных) функций

Alt + enter > add static import //Добавляется импорт не класса, а конкретного метода

  @Test
  public void testGroupCreation() {
    app.goTo().groupPage();
    Set<GroupData> before = app.group().all();
    GroupData group = new GroupData().withName("test2");
    app.group().create(group);
    Set<GroupData> after = app.group().all();
    assertThat(after.size(),equalTo(before.size() + 1));

    group.withId(after.stream().mapToInt((g) -> g.getId()).max().getAsInt());
    before.add(group);
    assertThat(after, equalTo(before));
  }

Сделаем следующий шаг, прикрутим флуент интерфейс к спискам

assertThat(after, equalTo(before.withAdded(group)); 


Но добавить метод withAdded(), в уже существующий интерфейс Set<GroupData> before = app.group().all() нельзя, и даже в существующий класс нельзя.
Поэтому нам придется сделать свой собственный класс. Который с одной стороны, ведет себя как обычный традиционный Set (множество), с другой в него можно добавить свои собственные методы. Метод, который добавляет элемент в множество; метод - удаляет элемент из множества. 

Реализуем такой класс при помощи библиотеки Гуава
В ней есть специальный набор вспомогательных классов, которые предназначены для построения коллекций с расширенным набором методов ForwardingSet и ForwardingList 	
	
/*
Шаблон проектирования или паттерн (англ. design pattern) — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях. 
Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.

*/

	
В пакет modul добавим класс Groups, который расширяет ForwardingSet 


public class Groups extends ForwardingSet<GroupData> {  //делаем расширенную версию множества типа GroupData
}
 	
Alt+enter > Implement methods 	//нужно реализовать обязательный метод delegate() 

Библиотека Гуава реализует шаблон проектирования Декоратор
http://github.com/google/guava/wiki/collectionhelpersexplained
	
Суть заключается в том, что все вызовы методов делегируются к какому то объекту (реальному списку / множеству), который вложен во внутрь обертки.
Кроме того, в этой обертке мы может реализовать свои дополнительные методы, которые тоже будут взаимодействовать с объектом, которому все это делегируется.  Также, при помощи этого механизма, можно предопределить поведение уже существующих методов.

Мы хотим, чтобы стандартные методы просто делегировались вложенному списку / множеству - эту задачу на себя берет класс ForwardingSet(). А мы добавим свои собственные методы. 


public class Groups extends ForwardingSet<GroupData> {  

  private Set<GroupData> delegate; //объект - множество, которому все будет делегироваться (атрибут объекта) 

  @Override
  protected Set<GroupData> delegate() { //метод, который будет возвращать этот объект
    return delegate;
  }
  
  public Groups withAdded(GroupData group) { //добавили свой метод
	  
  }
  
}

Чтобы можно было вытягивать методы в цепочки и строить из них каскады, необходимо чтобы возвращался объект типа Groups.   
 
1 способ 
Поэтому нужно в уже существующее множество private Set<GroupData> delegate добавить тот объект, который передан в качестве параметра withAdded(GroupData group) и вернуть this. То есть тот объект, в котором вызывается метод withAdded().

2 способ
Сделать копию, так чтобы старый объект остается неизменным. А метод withAdded() возврал новый объект c добавленной новой группой.
Копировани объектов дает возможность работать со старым множеством без добавленной группы и с новым множеством с добавленной группой. 

public class Groups extends ForwardingSet<GroupData> {

  private Set<GroupData> delegate;

  //конструктор, будет строить копию существующего объекта
  
  public Groups(Groups groups) { 
    this.delegate = new HashSet<>(groups.delegate); //берем множество из существующего объекта, который передан в качестве параментра groups. = Строим новое множество, которое содержит теже самые элементы, и присваиваем this. новое множество в качестве атрибута в новый создаваемый этим конструктором объект delegate  
  
  /*  
	(Groups groups) // конструктор в качестве параметра получил объект типа "множество" 
	groups.delegate //взяли множество из существующего объекта  
	= new HashSet<>() //строим новое пустое множество 
	= new HashSet<>(groups.delegate) - строим новое множество, в которое добавляем все элементы существующего множества
	this.delegate //указываем на атрибут объекта типа "множество"
	this.delegate = new HashSet<>(groups.delegate) - присваиваем новое множество (копию) в качестве атрибута в новый создаваемый этим конструктором объект   
  */
  
  }

  @Override
  protected Set<GroupData> delegate() {
    return delegate;
  }

  public Groups withAdded(GroupData group) { //добавили свой метод
    Groups groups = new Groups(this); //создали копию
    groups.add(group); //в копию добавлили объект, который передан в качестве параментра
    return groups; //вернули построенную копию с добавленной группой
  }
  
//аналогично сделаем копию, из которой удалена какая то группа 

  public Groups without(GroupData group) {
    Groups groups = new Groups(this);
    groups.remove(group);
    return groups;

  }	
}

Возвращаемся обратно в тест

Меняем тип Set<GroupData> на Groups

Изменим метод all(), чтобы он возвращал объект типа Groups 


  public Groups all() {
    Groups groups = new Groups(); //не хватает конструктора без параметров**
	
	//дальше копии строится не будут, заполнится только тот объект который мы создали
	//Никакой необходимости в клонировании нет, потому что нет старого списка, который мы хотели бы сохранить
	
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value"));
      groups.add(new GroupData().withId(id).withName(name));
    }
    return groups; //и в конце он вернется
  }
  
//**создадим конструктор без параметров	
  public Groups() {
    this.delegate = new HashSet<>();
  }	

А в тестах очень плезно делать копии. Потому что старый список, может еще пригодится для каких то других проверок. 

В итоге получим,

public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.goTo().groupPage();
    Groups before = app.group().all();
    GroupData group = new GroupData().withName("test2");
    app.group().create(group);
    Groups after = app.group().all();
    assertThat(after.size(),equalTo(before.size() + 1)); 
    assertThat(after, equalTo(before.withAdded(group.withId(after.stream().mapToInt((g) -> g.getId()).max().getAsInt()))));

  }
}


GroupData group = new GroupData().getName("test2"); 
GroupData group  //создали переменную и указали ее тип //переменная указывает на объект GroupData
GroupData group = new GroupData()// оператор new вызывает конструктор для объекта group (Конструктор предоставляется автоматически, используется по умолчанию и инициализирует все переменные экземпляра их значениями по умолчанию) // создается копия объекта с пустыми полями
getName("test2")// сеттер, присваивает значение полю name тому объекту, для которого он был вызван
GroupData().withName("test2") //вызываем метод сеттер у пустого объекта и передаем ЕМУ в качестве аргумента строку, и эта строка присваивается в поле name нашего объекта




Проверку assertThat(after.size(),equalTo(before.size() + 1)) можно поставить как перед, так и после; потому что объект before() остается неизменным, в сравнении участвует его копия. А before сохраняет старый размер. Удобно когда можно не заботится о порядке проверок.  




Переходим к тесту удаления

public class GroupDeletionTests extends TestBase {

  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) {
      app.group().create(new GroupData().withName("test1"));
    }
  }

  @Test
  public void testGroupDeletion(){
    Groups before = app.group().all();
    GroupData deletedGroup = before.iterator().next();
    app.group().delete(deletedGroup);
    Groups after = app.group().all();
    assertEquals(after.size(),before.size() -1);
    assertThat(after, equalTo(before.without(deletedGroup)));
  }

}


К тесту мофидификации


public class GroupModificationTests extends TestBase {

  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) {
      app.group().create(new GroupData().withName("test1"));
    }
  }

  @Test
  public void testGroupModification() {
    Groups before = app.group().all();
    GroupData modifiedGroup = before.iterator().next();
    GroupData group = new GroupData()
            .withId(modifiedGroup.getId()).withName("new1").withHeader("new2").withFooter("new3");
    app.group().modify(group);
    Groups after = app.group().all();
    assertEquals(after.size(), before.size());
    assertThat(after, equalTo(before.without(modifiedGroup).withAdded(group)));
  }

}



	
}
Урок 54. Кеширование результатов длительных операций {
	
public class GroupDeletionTests extends TestBase {
  @BeforeMethod
  public void ensurePreconditions() {
    app.goTo().groupPage();
    if (app.group().all().size() == 0) { //загружаем группы 1 раз
      app.group().create(new GroupData().withName("test1"));
    }
  }

  @Test
  public void testGroupDeletion(){
    Groups before = app.group().all();//загружаем группы 2 раз
    GroupData deletedGroup = before.iterator().next();
    app.group().delete(deletedGroup);
    Groups after = app.group().all(); //загружаем группы 3 раз
    assertEquals(after.size(),before.size() -1);
    assertThat(after, equalTo(before.without(deletedGroup)));
  }
}

Ускорим работу теста со списком, состоящим из сотни групп 

Ускорить чтение списка не можем. Но может сократить количество раз, которые мы делаем эту сложную операцию. 

Реализовать кеширование означает запомнить результат выполнения какой то операции. И потом вместо после повторного выполнения этой операции использовать ранее запомненный ранее результат. 

Реализуем кеш в GroupHelder

public Groups groupCache = null; //создадим пустое поле

public Groups all() {
	if (groupCache != null) { //добавим проверку, если кеш не пустой 
	  return new Groups(groupCache); //возвращаем копию кеша. Именно копию, чтобы кеш никто не испортил
	}
	//иначе если кеш не заполнен, придется прочитать список со страницы веб приложения 

    groupCache = new Groups(); //инициализируем кеш
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value"));
      groupCache.add(new GroupData().withId(id).withName(name));
    }
    return new Groups(groupCache); //в конце возвращаем копию кеша
  } 


Но в какие то моменты кеш надо сбрасывать. Например, когда точно знаем список групп поменялся. 

app.group().delete(deletedGroup);
groupCache = null;


submitGroupModification();
groupCache = null;

submitGroupCreation();
groupCache = null;

После всех этих действий кеш будет очищен, и при следующем обращении к методу all() будет создан заново. 

Таким образом, эта тяжеловесная операция будет выполняться минимальное количество раз, именно тогда,когда чтото поменялось.

	
}
Урок 55. Хеширование и предварительные проверки {
	
Создадим неготивный тест, который проверяет что нельзя создать группу с именем содержащей символ ' 
//приложение запрещает

При этом размер списка не должен поменяться. 
И старый список должен быть равен новому списку.

  @Test
  public void testBadGroupCreation() {
    app.goTo().groupPage();
    Groups before = app.group().all();
    GroupData group = new GroupData().withName("test2'"); //вводится запрещенный символ
    app.group().create(group);
    Groups after = app.group().all();
    assertThat(after.size(),equalTo(before.size())); //размер старого и нового списка одинаковый 
    assertThat(after, equalTo(before)); //новый список равен старому
  }
 

А что если группа не должна создаваться, а она создается?
Тогда тест падает, потому что не сойдется размер списков



Groups after = app.group().all(); // загружается список
assertThat(after.size(),equalTo(before.size())); // падает здесь

Зачем загружать весь список если нужно проверить только количество элементов?
Можно переставить вышеуказанные строки местами 
Но просто так это сделать нельзя, потому что нужен альтернативный список узнать количество групп //ошибка в after.size()

  public int Count() { 
    return driver.findElements(By.name("selected[]")).size(); //происходит одно единственное обращение к браузеру
  }

Вместо загрузки информации о сотни групп, и делать примерно 200 обращений к браузеру, количество можно узнать за одну единственную операцию. 	

  @Test
  public void testBadGroupCreation() {
    app.goTo().groupPage();
    Groups before = app.group().all();
    GroupData group = new GroupData().withName("test2'");
    app.group().create(group);
    assertThat(app.group().сount(), equalTo(before.size())); //простая проверка будет выполнятся до того, как перейти к сложной проверки
    Groups after = app.group().all();
    assertThat(after, equalTo(before));
  }
	
С точки зрения производительности, проверки	размеров списка надо ставить как можно раньше. И для получения количества групп использовать более быструю операцию. 

Это называется хеширование - предварительная проверка при помощи более быстрой операции. 

Прежде чем загружать список групп надо проверить сходится ли количество.

 //пример хеширования, которое генерируется одновременно с методом equal()
  @Override
  public int hashCode() { //генерируются парой с equals() и согласованы друг с другом
    int result = id;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    return result;
  }	
	
Прежде чем сравнивать объекты при помощи метода equals(), можно попытаться выполнить более быструю проверку и сравнить хешкоды объектов. 
У равных объектов должны быть равные хешкоды. У разных объектов хешкоды могут случайно совпасть. 
Но если хешкоды не совпали, то проверка с помощью метода equals() уже не нужна.	
Хеш код это способ ускорения проверки, операция которая выоплняется быстрее чем equals() и позволяет выполнить предварительную проверку.
	
	
	

}	
Урок 56. Способы построения сложных локаторов {
	
Поговорим о регулярных выражениях, которые используют разделители для разрезания строк

Создадим тест, который проверяет корректность представления телефонов на главной страницы приложения

	
	
public class ContactPhoneTests extends TestBase {



  @BeforeMethod //добавим предусловие	
  public void ensurePreconditions() {
    app.goTo().HomePage();
    if (app.contact().all().size() == 0) {
      app.contact().create(new ContactData().withFirstname("Alex").
              withLastname("Jackson").withAddress("My street").
              withMobileNum("111").withHomeNum("222").withWorkNum("333").withGroup("test1"), true);
    }
  }

  @Test
  public void testContactPhones(){
    app.goTo().HomePage();
    //загружаем множество контактов, выбираем случайным образом какой то контакт
    ContactData contact = app.contact().all().iterator().next();
    //далее будем сравнивать информацию на главной странице с данными в форме редактирования контакта
	//для отладки оставим в таблице один контакт 
    //сделаем вспомогательный метод
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact);	
	
	}
}
	
	
	
//вспомогательный метод который загружает информацию из формы редактирования
  public ContactData infoFromEditForm(ContactData contact) {
    initContactModificationById(contact.getId()); //выбор контакта по идентификатору
    String firstname = driver.findElement(By.name("firstname")).getAttribute("value");
    String lastname = driver.findElement(By.name("lastname")).getAttribute("value");
    String home = driver.findElement(By.name("home")).getAttribute("value");
    String work = driver.findElement(By.name("work")).getAttribute("value");
    String mobile = driver.findElement(By.name("mobile")).getAttribute("value");
    return new ContactData().withId(contact.getId()).withFirstname(firstname).
            withLastname(lastname).withHome(home).withWork(work).withMobile(mobile);
  }
	
	
//вспомогательный метод, который выбирает контакт по идентификатору	
  private void initContactModificationById(int id) {
    driver.findElement(By.xpath(String.format("a[href='edit.php?id=%s']", id))).click(); //способ 1, с помощью ChroPath
  }	
 
  
	
//способ 2 последовательный приближений
  private void initContactModificationById2(int id) {
	  
	//находим чек-бокс
	//ищем элемент, который имеет тег input и атрибут value равное заданному значению  
    WebElement checkbox = driver.findElement(By.cssSelector(String.format("input[value='%s']",id)));
	
	//ищем строку
	//выполняем поиск относительно элемента checkbox 
	//нам нужно от этого чек бокса перейти к ячейке, а от ячейке к строчке
	WebElement row = checkbox.findElement(By.xpath("./../../")); 
	//xpath позволяет перейти к родительскому элементу, то есть к тому в котором находятся данные 
	// By.xpath("./ точка означает поиск с текущего элемента
	// .. переход вверх
	
	//надо попасть в ту ячейку, в которой находится кнопка Edit
	//берем полный список ячеек
	//ищем внутри строки все элементы которые имеют имя td
	List<WebElement> cells = row.findElements(By.tagName("td"));
	
	//среди этих ячеек берем по номеру нужную, внутри ячейки находим ссылку по имени тега а
	cells.get(7).findElement(By.tagName("a")).click();	
	


//способ 3 (в языке запросов xpath нумерация начинается с 1)
driver.findElement(By.xpath(String.format("input[]value=%s/../../..td[8]/a", id))).click(); 


//способ 4 xpath с подразпросами
driver.findElement(By.xpath(String.format("//tr[.//input[@value='%s']]/td[8]/a", id))).click();
//хочу найти строку внутри которой есть чек-бокс с заданным идентификатором
//tr - поиск строки //tr[ограничения (c подзапросом]
//.//input[@value='%s'] подзапрос (означает, что внутри этой строки находится input с заданным атрибутом value)
//когда найдется такая строка, относительно этой строки ищем восьмую ячейку и в ней ссылку   

//способ 5 "хитрый" ссылка тоже содержит идентификатор <a href="edit.php?id=38"></a>
//можно сразу поискать по этому признаку 

driver.findElement(By.cssSelector(String.format("a[href='edit.php?id=%s']", id))).clicl(); //строим css селектор, в котором ищется элемент а, имеющий атрибут href такого вида. 



}	
}
Урок 57. Режем строки (и немного про регулярные выражения) {
	
Загрузим с главной страницы приложения информацию о телефонах и реализуем проверки того, что эта информация действительно представлена корректно. 
	
Как получить телефоны с формы редактирования мы разобрались в прошлом уроке.
Теперь разберемся с главной страницей, то есть обратимся к методу all()	

//было
  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td")); //<tr class name="entry"></tr>
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText(); //это текст второй ячейки
      String firstname = cells.get(2).getText(); //это текст третьей ячейки
      //дальше можем получит строчку, которая содержит все телефоны одновременно
	  String allPhones = cells.get(5).getText();
	  //для того, чтобы заполнить атрибуты объекта типа ContactData нужно три отдельных телефона, поэтому строчку нужно разрезать на части
	  allPhones.split("\n"); //в качестве параметра в этот метод передается регилярное выражение - то есть шаблон поиска (перевод строки) 
	  // "\n" - перевод на следующую строку
	  //результатом будет массив String[], который состоит из трех элементов. Его нужно поместить в переменную Alt+Enter > Introduce local var
      contacts.add(new ContactData().withId(id).withFirstname(firstname)).withLastname(lastname);

    }
    return contacts;
  }
	
//стало 
    	
  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td"));
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText();
      String firstname = cells.get(2).getText();
      String[] phones = cells.get(5).getText().split("\n");
      contacts.add(new ContactData().withId(id).withFirstname(firstname).withLastname(lastname));//* сюда добавим атрибуты с номера телефонов
    }
    return contacts;
  }
	
Теперь полученные данные используем для того, чтобы заполнить атрибуты нашего модельного объекта	

public ContactData infoFromEditForm(ContactData contact)
    contacts.add(new ContactData().withId(id).withFirstname(firstname).withLastname(lastname).withHome(phones[0]).withMobile(phones[1]).withWork(phones[2])); //передали элемент массива в качестве параметра 	
	
Возвращаемся к методу testContactPhones() и добавляем проверки 

  @Test
  public void testContactPhones(){
    app.goTo().HomePage();
    ContactData contact = app.contact().all2().iterator().next();
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact);
    assertThat(contact.getHome(), equalTo(contactInfoFromEditForm.getHome()));
    assertThat(contact.getMobile(), equalTo(contactInfoFromEditForm.getMobile()));
    assertThat(contact.getWork(), equalTo(contactInfoFromEditForm.getWork()));
  }

Но если изменить текст в ячейке с номерами телефонов на 
Home + 7 (111)
Mobile 22-22	
Work 33 33 33
	
То на главной отобразится
+7111
2222
333333	
	
Тест упадет, потому что номера телефонов выглядят по разному 
Expected :+ 7 (111)
Actual   :+7111

Сначала сравниваемые объекты приводятся к общему каноническому виду, оба упрощаются а затем сравниваются. 
 
В классе ContactPhoneTests напишем вспомогательную функцию, которая будет приводить телефон к правильному очищенному виду.	
	
//метод, который удаляет лишнии символы
public String cleaned(String phone) {
  return phone.replaceAll("\\s",""); //заменить все вхождения чего-то на что-то
}
	
Первый параметр - регулярное выражение. 
Внутри строки ищем фрагмент, который подходит под некоторый шаблон и заменяем его на то значение, которое передано в качестве второго параметра (в нашем случае это будет пустая строка)  	
	
Регулярные выражения - мощный язык


Плагин IDEA для тестировани регулярных выражений
https://plugins.jetbrains.com/plugin/2917-regexptester


Онлайн-редактор регулярных выражений 
(можно также в гугле поискать по запросу regex tester java)
http://myregexp.com


\\s означает любой пробельный символ (пробел, табуляция, перевод строки)


public String cleaned(String phone) {
  return phone.replaceAll("\\s","").replaceAll("[-()]",""); //добавим еще один сеанс
}

Остается применить функцию к тем данным, которые получены с формы редактирования. Чтобы привести их к тому виду, который представлен на главной странице. Обратное преобразование невозможно. Потому что неизвестно какие символы надо добавить, легче удалить лишнии символы. 



}
Урок 58. Клеим строки - метод обратных проверок {
Испортим свойства того контакта, телефоны которого проверяются в тесте. 
В форме редактирования очистим поле Mobile.

Теперь на главной странице представлены 2 телефона, но не понятно какие именно телефоны. //в коде приложения тоже не указано

Тест падает, потому что третьего телефона нет.  

Воспользуемся методом обратных проверок
Если нельзя разрезать что то на кусочки и потом эти кусочки сравнить с чем то, значит нужно пойти с противоположного конца. Из известных кусочков склеить большую строку и сравнивать ее целиком.    

Мы не знаем как разрезать телефоны на главной странице, зато мы можем взять атрибуты того объекта, который загружен на главной странице с формы редактирования склеить из них строчку, которая должна выглядеть точно также как на главной странице. И сравнивать ее целиком.



было
  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td"));
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText();
      String firstname = cells.get(2).getText();
      String[] phones = cells.get(5).getText().split("\n"); //исправим то место которое падает
      contacts.add(new ContactData().withId(id).withFirstname(firstname).
              withLastname(lastname).withHome(phones[0]).withMobile(phones[1]).withWork(phones[2]));
    }
    return contacts;
  }

стало

  public Set<ContactData> all2() {
    Set<ContactData> contacts = new HashSet<>();
    List<WebElement> rows = driver.findElements(By.name("entry"));
    for (WebElement row : rows) {
      List<WebElement> cells = row.findElements(By.tagName("td"));
      int id = Integer.parseInt(cells.get(0).findElement(By.tagName("input")).getAttribute("value"));
      String lastname = cells.get(1).getText();
      String firstname = cells.get(2).getText();
      String allPhones = cells.get(5).getText(); //один большой кусок текста
      contacts.add(new ContactData().withId(id).withFirstname(firstname).
              withAllPhones(allPhones)); //ввели специальный служебный атрибут 
    }
    return contacts;
  }

В GroupData 

добавили атрибут 

private String allPhones;

добавили Getter и Setter


  public String getAllPhones() {
    return allPhones;
  }

  public ContactData withAllPhones(String allPhones) {
    this.allPhones = allPhones;
    return this; //для вытягивания в цепочку
  }

Теперь ContactHelper не будет падать. Он вместо заполнения трех отдельных атрибутов, будет заполнять четвертый атрибут, который содержит эти телефоны вместе.   

Возвращаемся в тест 

  @Test
  public void testContactPhones() {
    app.goTo().HomePage();
    ContactData contact = app.contact().all2().iterator().next(); //контакт, который загружен с главной страницы содержит только правильное значение атрибута allPhones, а отдельные телефоны у него не заполнены
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact); //контакт который загружен с формы редактирования, содержат отдельные атрибуты для телефонов, но пустой allPhones
	
	//поэтому сравнивать нужно будет allPhones того контакта, который загружен с главной страницы и строчку которую будем клеить  
    assertThat(contact.getHome(), equalTo(mergePhones); //делаем вспомогательный метод 
   
  }
  
  //метод, который удаляет лишнии символы
  public String cleaned(String phone) {
    return phone.replaceAll("\\s","").replaceAll("[-()]",""); //заменить все вхождения чего-то на что-то
  }
  
  private String mergePhones(ContactData contact) {
    return null;
  }

Старый способ до появления элементов функционального программирования в java 8 

  private String mergePhones(ContactData contact) {
	String result = ""; //делаем пустую строчку
	if (contact.getHomePhone() != null) {//добавляем в нее что-нибудь
		result = result + contact.getHomePhone(); //и так далее для всех 3 телефонов 
		} //кроме того между ними нужно в качестве разделителя вставить перевод строки 
    return result; 
  }


Как склеить номера телефонов при помощи элементов функционального программирования 
 	
Функциональное программирование используется для того, чтобы последовательно обрабатывать элементы коллекции. 
Поэтому с начала из наших телефонов нужно сформировать коллекцию, которую потом будем склеивать. 

private String mergePhones(ContactData contact) {
 Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork()); //получили список, который состоит из трех элементов
//из этого списка нужно отсеить те элементы, которые равны 0 а остальные будем склеивать
//для этого сначала превращаем список в поток stream()
//фильтруем поток 

Выбрасываем из него те элементы, которые равны пустой строке, иначе они будут мешать при склеивании 
Для этого используется функция filter(), в качестве параметра нужно передать аннонимную функцию
Которая на вход принимает строку, поскольку это поток, построенный из списка строк. И возвращать эта функция должна true или false (оставить элемент или выбросить его).
Оставит нам надо те элементы, которые не равны пустой строке. 


  private String mergePhones(ContactData contact) {
     Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork()).
            stream().filter((s) -> ! s.equals("")); 
			//теперь получаем новый поток, в котором выбрашены пусты строчки
			//остались только непустые строчки, которые нужно склеить вместе. 
			
			
    return null;
  }

Для склеивания используется функция collect() //собрать, в качестве параметра нужно передать Collector 
В стандартной библиотеки java уже есть набор коллекторов классе Collectors, например Collectors.joinings()
Коллектро, который склеивает все элементы потока в одну большую строку, в качеств е параметра передается разделитель "\n"
Эта та строчка, которая будет вставлятся между склеиваемыми фрагментами.  
Результатом метода collect() является строка. 


  private String mergePhones(ContactData contact) {
    return Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork())
            .stream().filter((s) -> ! s.equals("")) //нужно ко всем элементам потока применить функцию очистки 
			.map(ContactPhoneTest::cleaned) //для очистки используем map - ее назначение "применить ко всем элементам потока какую то функцию и вернуть поток, состоящий из результатов жтой функции
			//в java 8 в качестве параметра можно передать не только аннонимную, но и уже существующую глобальную функцию (static)
            .collect(Collectors.joining("\n"));
  } 


В итоге получаем, 


  @Test
  public void testContactPhones() {
    app.goTo().HomePage();
    ContactData contact = app.contact().all2().iterator().next();
    ContactData contactInfoFromEditForm = app.contact().infoFromEditForm(contact);
    assertThat(contact.getAllPhones(), equalTo(mergePhones(contactInfoFromEditForm)));
  }

  private String mergePhones(ContactData contact) {
    return Arrays.asList(contact.getHome(), contact.getMobile(), contact.getWork())
            .stream().filter((s) -> ! s.equals(""))
            .map(ContactPhoneTests::cleaned)
            .collect(Collectors.joining("\n"));
  }

  //метод, который удаляет лишнии символы
  public static String cleaned(String phone) {
    return phone.replaceAll("\\s","").replaceAll("[-()]",""); //заменить все вхождения чего-то на что-то
  }



  
}
}


Занятие 6. Работы с файлами
Урок 59. Пути к файлам и директориям {
	
Научимся работать с объектами, которые хранят описание файлов, хранящихся на диске. 	
Научимся определять	путь к файлу, установим различия между относительными и абсолютными путями.
    
Например, если при создании контакта хотим прикрепить фото, нужно в поле ввести полный абсолютный путь к файлу, содержащий рисунок.    	
	
Для хранения ссылки на файл с рисунком добавим атрибут типа File в класс GroupData.  	//File находится в пакете java.io (input / output)
	
Делаем для него геттер и сеттер	
	
Сеттер меняем на другой, который позволяет вытягивать методы в цепочку, делать каскад и использовать флуент интерфейс. 
  
  public ContactData withPhoto(File photo) {
    this.photo = photo;
    return this;
  }	

Теперь при создании объекта можно вызвать метод withPhoto(), и передать в него в качестве параметра локальную переменную. 
  @Test
  public void testContactCreation() {
    app.goTo().HomePage();
    Contacts before = app.contact().all();
    File photo = new File().; //инициализируем переменную типа File, после точки нужно указать путь к этому файлу
    ContactData contact = new ContactData().withFirstname("Alex").withLastname("Jackson")
            .withAddress("My street").withMobile("111").withHome("222").withWork("333").withPhoto(photo); //добавили метод с параметром
  
  } 

У каждого файла есть абсолютный путь, относительно корня диска. 
Например, c:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests\src\test\resources\  

Но на другом пк путь к файлу будет уже другим. Поэтому удобнее указать относительный путь, относительно рабочей директории. 
У каждой программы есть рабочая директория. У теста тоже она есть. 

Создадим вспомогательный тест, в котором будет определять какая	директория является текущей во время выполнения тестов. 

  @Test
  public void testCurrentDir() {
    File currentDir = new File("."); //точка означает текущую директорию
  }

Чтобы посмотреть как будет выглядеть объект, какой путь внутри него будет указан, ставим точку останова и запускаем тест. 	
	
В объекте так и написано "." //то есть нет информаци где эта директория расположена 
По косвенным признакам можно догадаться что это не корневая директория проекта, а корневая директория модуля. 

Опредленим абсолютный путь к этой директории. 

  @Test
  public void testCurrentDir() {
    File currentDir = new File(".");
    System.out.println(currentDir.getAbsolutePath());
  }	 
	
	C:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests\. //это корневая директория модуля
	
Если мы хотим указать относительный путь к какому-то файлу, надо указывать путь относительно этой директории, то есть 
	
File photo = new File("src/test/resources/stru.png");
    ContactData contact = new ContactData().withFirstname("Alex").withLastname("Jackson")
            .withAddress("My street").withMobile("111").withHome("222").withWork("333").withPhoto(photo);
	
Перед тем как создавать контакт с рисунком, нужно убедится, что рисунок действительно существует. 
	
  @Test
  public void testCurrentDir() {
    File currentDir = new File(".");
    System.out.println(currentDir.getAbsolutePath());
    File photo = new File("src/test/resources/stru.png"); //созданим объект типа файл, который соответствует уже существующему файлу, находящимуся на диске 
    System.out.println(photo.getAbsolutePath()); //выведем на консоль полный путь к этому файлу
    System.out.println(photo.exists()); //проверим, что файл существует 
  }

В результате получим:
C:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests\src\test\resources\stru.png
true

Доработаем метод fillContactForm()


  public void fillContactForm(ContactData contactData, boolean creation) {
 ...
    type(By.name("photo"), contactData.getPhoto().getAbsolutePath());
    //нужно передать в качестве параметра не просто результат выполнения метода getPhoto()
    // а нужно преобразовать его в строку, которая содержит абсолютный путь к файлу
    //ведь у браузера, который рапускается как отдельный самостоятельный процесс, другая рабочая директория
	//и поэтому он не сможет преобразовать путь относительно проекта в полный путь 
	//поэтому надо сделать это явно	
}
Во время выполнения теста создания группы в приложении видно, что файл прикрепился, но вместе с ним открылось диалоговое окно для выбора файла. Оказывается, что файловые поля ввода действительно заполняется при помщи метода sentKeys. Но кликать по ним не надо. //chrome сам закрывает окно и идет продолжает работу 

protected void type(By locator, String text) {
click(locator);
    if (text != null) {
      String existingText = driver.findElement(locator).getAttribute("value");
      if (! text.equals(existingText)) { 
        driver.findElement(locator).clear();
        driver.findElement(locator).sendKeys(text);}
}
}

Поэтому для ввода файлов, нужно сделать отдельный метод sendKeys без клика. 

Копируем метод type()

было 
  protected void attach(By locator, String text) {
    click(locator);
    if (text != null) {
      //оптимизация, которая проверяет совпадение уже существующее значения, с тем которое мы пытаемся ввести //убираем
      String existingText = driver.findElement(locator).getAttribute("value");
      if (! text.equals(existingText)) {
        driver.findElement(locator).clear(); 
		//убираем очистку поля ввода, потому что в отличии от текстового поля ввода, где новое значение просто допишется в конец для файлового поля ввода, очистка выполняется автоматически
        driver.findElement(locator).sendKeys(text);}
      }
    }

стало
  protected void attach(By locator, File file) { //так как метод предназначен для заполнения файлового поля ввода, передаем в качестве параметра объект типа файл
    if (file != null) {
        driver.findElement(locator).sendKeys(file.getAbsolutePath()); //здесь можно определять абсолютный пусть к файлу, который должен в качестве значения передаваться в метод sendKeys()
    }
  }

Возвращаемся в fillContactForm() и дописываем
attach(By.name("photo"), contactData.getPhoto());

Запускаем тест. Тест зеленый. Диалоговое окно не открывается.



}
Урок 60. Генератор тестовых данных, запись данных в файл {
	
Постепенно движемся в сторону создания тестов, которые будут загружать тестовые данные из внешнего файла 
 	
package ru.testjava.addressbook.generators;

//метод генерирует инфо о группах
public class GroupDataGenerator { 


  public static void main(String[] args){ //запускаемый файл
    //при запуске программы передадим параметры через массив строк Edit Configuration > Configuration > Program arguments 
    int count = Integer.parseInt(args[0]); //количество групп
    File file = new File(args[1]);//путь к файлу

	//1 часть генерация данных
    List<GroupData> groups = generatorGroups(count);
	//2 часть сохраненние данных в файл
    save(groups, file);

  }

  private static List<GroupData> generatorGroups(int count) {
    List<GroupData> groups = new ArrayList<GroupData>();
    for (int i = 0; i < count; i++) {
      groups.add(new GroupData().withName(String.format("test %s", i))
              .withHeader(String.format("header %s", i))
              .withFooter(String.format("footer %s", i)));
    }
    return groups;
    }

  private static void save(List<GroupData> groups, File file) { //выбирем формат coma Separeted Values
    //открываем файл на запись
	//создаем объект типа Writer, через него будет выполняться запись 
    Writer writer = new FileWriter(file); //IDE предупреждает об ошибке Unhandled exception
  }


}	
	
Причины исключения могут быть разными: 
- файл уже существует и у нас нет прав на запись, 
- файла нет и нет директории в которой он должен быть создан (java автоматически создавать директории не будет), 
- указано недопустимое имя файла, ОС не может создать и открыть файл


Есть два пути : //Alt+Enter
- перехват исключения и принять какие то меры, например вывести сообщение об ошибке
- дать возможность исключению пролететь дальше


В декларацию этого метода добавляется информация о том, что во время работы этого метода может возникнуть исключение типа IOException.
И тогда save() перекладывает эту проблему на main(), который тоже может декларировать, что он выбрасывает исключение типа IOException. Но конечно, перехватывать его уже некому и поэтому программа упадет. Нас такой вариант устроит.


  
  private static void save(List<GroupData> groups, File file) throws IOException { //выбирем формат comma separated values (CSV)
    //открываем файл на запись
    Writer writer = new FileWriter(file);
    for (GroupData group : groups) {
      writer.write(String.format("%s;%s;$s\n", group.getName(),group.getHeader(),group.getFooter()));
    }
    //закрываем файл
    writer.close();
  }	
	
Те данные, которые пишутся в объект типа writer не сохраняются мнгнованно на диск, они кешируются. Точно также, как мы пытались кешировать выполнение тяжеловесных операций. Запись данных на диск это медленно. 
Поэтому нужно сначала накопить большой кусок данных в памяти и потом одновременно сбросить их на диск.
Но если программа завершается в тот момент, когда данные еще не полностью сохранены на диск, а находятся в кеше, они могут быть потерены. 
Поэтому нужно явно вызвать writer.closed(). В этот момент содержимое записывается на диск, файл закрывается. Это гарантия того, что все данные благополучно сохранились. 

Запускаем тест - получаем ислючение IndexOutOfBoundsException 
Надо передавать параметры сount, file
	
Открываем настройку конфигурации запуска Run / Debug Configurations	
	
Вводим в поле Arguments	
10 src/test/resources/groups.csv	
	
	
	
В начале метода save посмотрим какая у нас текущая директория 

System.out.println(new File(".").getAbsolutePath());	

На этот раз рабочая директория проекта, а не модуля		
C:\Users\kobzev\Documents\GitHub\java_test\.
	
Когда запускаются тесты, то рабочей является директория модуля, а когда программы - директория проекта. 
	
Поменемся текущую директорию 
//рабочая директория и путь должны сойтись
//укажем что программа должна запускаться здесь 
C:\Users\kobzev\Documents\GitHub\java_test\addressbook-web-tests 	
	
	
	
}	
Урок 61. Анализ опций командой строки при запуске генератора данных {

Как правильно работать с параметрами или опциями, которые передаются при запуске программы из командной строки. 

В случае наличия ошибки при запуске программы нужно, чтобы пользователь получал подробную информацию об исключении. Что именно он сделал не правильно, и что нужно сделать чтобы программа запустилась. Какие опции она поддерживает? В каком порядке следует их указывать.  
Все это программа должна сообщать, когда пользователь пытается вызвать ее с неправильными параметрами. 	

Реализуем это при помощи библиотеки http:\\jcommander.org 
Она предназвачена для обработки опций командной строки

Подключаем библиотеку через http:\\search.maven.org

  
JC определяет список атрибутов в текущем классе, у каждого атрибута можно получить инфо о том, какие аннотации связаны с этим атрибутом, и дальше прочитать параметры аннотации.     

Ниже приведена простейша форма JC: 

Класс 
список атрибутов 
@Parameter (параметры аннотации ) //аннотация 
атрибут1; //числа, строки, списки но не файлы
@Parameter (параметры аннотации ) //аннотация 
атрибут2; 

Нам нужны опции коммандной строки count и file, которые сделаем атрибутами


@Parameter(names = "-c", description = "Group count") //дадим этим опциям имена и описание
public int coutn;

@Parameter(names = "-f", description = "Target file")
public String file; //тип String потому что библиотека jc напрямую работу с файлами не поддерживает

А теперь делаем так как написано в документации jc

Сначала создаем объект теущего класа, затем создаем объект типа 
JCommander (параметр1, параметр2)
где 
параметр1 - объект, в котором должны быть заполнены соответствующие атрибуты 
параметр2 - те опции, которые переданы коммандной строке 


Теперь запускаем generator.run()

Создадим run() и переместим туда 

  private void run() throws IOException {
	//1 часть генерация данных
    List<GroupData> groups = generatorGroups(count);
    //2 часть сохраненние данных в файл
    save(groups, new File(file)); //преобразуем

  }

А save() и generateGroups() можно убрать static, потому что все методы вызываются внутри объекта generator

Запускаем тест получаем исключение
Was passed main parameter '10' but no main parameter was defined in your arg class

Нужно добавить сообщение о том, как программу запускать правильно. 



  public static void main(String[] args) throws IOException {
    GroupDataGenerator generator = new GroupDataGenerator();
    JCommander jCommander = new JCommander(generator); //создаем объект и помещаем его в какую-то локальную переменную
    jCommander.parse(args); //помещаем в качестве параметра наши аргументы , но так как при этом может возникнуть исключение ParameterException перехватим его, завернем parse() в метод try() - catch ()
  }


  public static void main(String[] args) throws IOException { //запускаемый файл
    GroupDataGenerator generator = new GroupDataGenerator();
    JCommander jCommander = new JCommander(generator);
    try {
      jCommander.parse(args);
    } catch (ParameterException ex) {//перехватываем исключение
      jCommander.usage(); //если исключение возникло, то выводим на консоль инфо о доступных опциях при помощи метода usage()
      return; //метод генератор запускать не надо
    }
  }

Снова запускаем тест, получаем сообщение 

Usage: <main class> [options]
  Options:
    -c
      Group count
      Default: 0
    -f
      Target file

Переходим в конфигурацию теста и исправляем значение аргументов

-c 20 -f src/test/resources/groups.csv

Благодаря тому, что мы реализовали возможность указывать параметры строки с именами, значение аргументов можно указывать в другом порядке. 


	
}
Урок 62. Параметризация тестовых методов {
	
Как создать параметризованный тест в TestNG

Тестовые данные это свойство той группы,которую мы собираемся создавать (name, header, footer).

Если нужно выполнить тест многократно на разных тестовых данных, то можно сделать цикл 
	
@Test
  public void testGroupCreation() {
    String[] names = new String[]{"test1", "test2", "test3"}; //делаем массив строк, в котором перечисляем тестовые данные
    for (String name : names) { //устраиваем цикл и выполняем основное тело теста
	  GroupData group = new GroupData().withName(name); //вместо конкретного значения подставляем переменную, которая перебирает элементы массива  
	  app.goTo().groupPage();
      Groups before = app.group().all();
      app.group().create(group);
      Groups after = app.group().all();
      assertThat(after.size(), equalTo(before.size() + 1));
      assertThat(after, equalTo(before.withAdded(group.withId(after.stream().
              mapToInt((g) -> g.getId()).max().getAsInt()))));
    }
  }

1-й проблемный момент
Запустился тест, но что он делал, на каких тестовых данных выполнялся из отчета не видно. 
Хотелось бы отобразить то, что мы запускали тест 3 раза на разных тестовых данных.


2-й момент
Если хотя бы одни тестовые данные содержат не допустимый символ ('), то весь тест падает. Остальные тестовые данные вообще не использованы, несмотря на то что на них тест мог отработать корректно. В отчете не видно на каких тестовых данных, тест упал. 


Решим эти проблемы при помощи провайдера тестовых данных


Это специальный метод который помечается аннотацией @DataProvider, возвращаемое значение которого должно быть достаточно сложным  


  @DataProvider
  public Iterator<Object[]> validGroups(){//итератор массива объектов
    List<Object[]> list = new ArrayList<Object[]>(); //список массивов объектов
    list.add(new Object[] {"test1", "header 1", "footer 1"}); //заполняем список тестовыми данными 1й-набор тд
    list.add(new Object[] {"test2", "header 2", "footer 2"}); //2-й набор тд
    list.add(new Object[] {"test3", "header 3", "footer 3"});	//3-й набор тд
    return list.iterator(); //возвращается итератор этого списка
  }


А теперь этот провайдер тестовых данных нужно привязать к тесту.
Для этого нужно во первых у аннатации тест указать параметр  

@Test(dataProvider = "validGroups")

Во вторых у тестового метода нужно сделать столько параметров, сколько содержится в каждом массиве объектов. То есть у него должно быть три параметра типа String.

Теперь параметры в тестовый метод будут передаваться из вне. Поэтому цикл нужно убрать. Цикл фактически оказывается снаружи и этот цикл устраивает фрейворк TestNG.


@Test(dataProvider = "validGroups")
  public void testGroupCreation(String name, String header, String footer) { 
    GroupData group = new GroupData().withName(name).withHeader(header).withFooter(footer); //заполняем объект тестовыми данными
    app.goTo().groupPage();
    Groups before = app.group().all();
    app.group().create(group);
    Groups after = app.group().all();
    assertThat(after.size(), equalTo(before.size() + 1));
    assertThat(after, equalTo(before.withAdded(group.withId(after.stream().
            mapToInt((g) -> g.getId()).max().getAsInt()))));
  }


Запускаем тест, в отчете видим, что тест запускался три раза и указаны явно тестовые данные, которые использоватлись при каждом запуске. 


В провайдере данных 
@DataProvider
  public Iterator<Object[]> validGroups(){
    List<Object[]> list = new ArrayList<Object[]>(); //список массивов объектов
	//каждый массив содержит набор данных для одного запуска тестового метода
	//сколько будет наборов, столько раз запустится тестовый метод 
    list.add(new Object[] {"test1", "header 1", "footer 1"});  
    list.add(new Object[] {"test2", "header 2", "footer 2"}); 
    list.add(new Object[] {"test3", "header 3", "footer 3"});	
    return list.iterator(); //возвращается итератор этого списка. Тестовый фрейворк по очереди при помощи этого итератора из списка вытаскивает один набор параметров за другим и запускает тестовый метод несколько раз, помещает полученную информацию о результатах в отчет
  }

Но передавать тестовые данные в виде набора строк это не удобно. 
В самом начале от этого избавились и создали модельный класс, который внутри себя содержит эту информацию. Удобнее передавать данные как один объект типа GroupData 

public void testGroupCreation(String name, String header, String footer) 

public void testGroupCreation(GroupData group) 

В этом случае, провайдер будет передавать не массив строк а массив объектов типа GroupData. Правда этот массив будет состоять всего из одного единственного элемента, потому что у тестового метода один параметр.  

было

    list.add(new Object[]{"test1'", "header 1", "footer 1"}); //массив их 3 строк
 
стало 

    list.add(new Object[]{new GroupData().withName("test1'").withHeader("header 1").withFooter("footer 1")});//массив из одного объекта
 
Запускаем тест и видим, что теперь в отчете представлен один объект и его строковое представление формируется при помощи метода

GroudData > 
@Override
  public String toString() {
    return "GroupData{" +
            "id='" + id + '\'' +
            ", name='" + name + '\'' +
            '}';
  }


}	
Урок 63. Загрузка тестовых данных из файла {
	
Общая идея - разделение зон ответственности: тестовый сценарий отдельно от тестовых данных. 

Переделаем провайдер таким образом, чтобы он загружал тестовые данные из внешнего файла.


  @DataProvider
  public Iterator<Object[]> validGroups() throws FileNotFoundException { //добавим это исключение в декларацию метода 
  //если не найден, то пусть тесты падают  
    List<Object[]> list = new ArrayList<Object[]>();
    Reader reader = new FileReader(new File("src/test/resources.groups.csv")); //здесь может возникать исключение
	//java понимает \/ к путям к файлам
    return list.iterator();
  }


	

read() возвращается int читает из файла один символ, возвращает его код
read(char[] cbuf) int возвращает набор символов. Для этого сначала нужно создать массив символов, элементов типа char. И какая длина у  массива, столько символов будет прочитано. 
	
Нужно прочитать строчку целиком, такого метода в классе Reader нет. Но в классе BufferedReader есть readLine(), который читает и возвращает целую строчку. 
Поэтому сделаем обертку: меняем тип объекта на BufferedReader, и обычный FileReader заворачиваем в new BufferedReader.


BufferedReader reader = new BufferedReader(new FileReader(new File("src/test/resources.groups.csv")));
String line = reader.readLine(); //здесь тоже может возникнуть исключение, которое мы тоже добавляем в декларацию     
//FileNotFoundException заменяется на IOException, которое является более общим видом исключения

	//таким образом можно прочитать только первую строчку
  @DataProvider
  public Iterator<Object[]> validGroups() throws IOException {
    List<Object[]> list = new ArrayList<Object[]>();
    BufferedReader reader = new BufferedReader(new FileReader(new File("src/test/resources.groups.csv")));
    String line = reader.readLine();
    return list.iterator();
  }	
	
	
  @DataProvider
  ...
    String line = reader.readLine();
    //неизвестно сколько строк в файле, поэтому используем цикл while
    while (line != null) {
      line = reader.readLine(); //продолжаем выполнение этого цикла, на каждой следующей итерации выполняется выражение - читать следующую строчку из тогоже самого файла
    }//когда все строки кончатся, вместо очередной строки вернется значение null и выполнение цикла прекратится

	
	
В итоге получаем,	
	
  @DataProvider
  public Iterator<Object[]> validGroups() throws IOException {
    List<Object[]> list = new ArrayList<Object[]>();
    BufferedReader reader = new BufferedReader(new FileReader(new File("src/test/resources.groups.csv")));
    String line = reader.readLine();
    //неизвестно сколько строк в файле, поэтому используем цикл while
    while (line != null) {
      String[] split = line.split(";");//выполнение обработки прочитанных строк
      //строим из полученных кусочков объект, который помещаем в массив
      //массив состоит из одного этого объекта(элемента). Добавляем массив в список
      list.add(new Object[]{new GroupData().withName(split[0]).withHeader(split[1]).withFooter(split[2])});
      line = reader.readLine(); //выполнение этого цикла, на каждой следующей итерации выполняется выражение - читать следующую строчку из тогоже самого файла
    }//когда все строки кончатся, вместо очередной строки вернется значение null и выполнение цикла прекратится
    return list.iterator();
  }	
	
	
	
}	
Урок 64. Формат XML {
	
Задача: необходимо набор объектов тестовых данных сохранить в формате xml. Для этого будем использовать особую разновидность библиотек  для работы с форматом xml, которые называются сериализатор данных. 
Они предназначены, для того чтобы автоматически преобразовать какие то объекты языка программирования в формат xml и наоборот, анализировать данные в формате xml и автоматически строить объекты нужного типа.

Подключим библиотеку Xstream

https://search.maven.org/artifact/com.thoughtworks.xstream/xstream/1.4.11.1/jar
	

Недостатки формата csv:
- структура нарушается формата если поля состоят из нескольких строк
- структура формата нарушается если поле содержит ;
- большое количество полей

Переделаем гененатор

public class GroupDataGenerator { //генерирует инфо о группах


  @Parameter(names = "-c", description = "Group count")
  public int count;

  @Parameter(names = "-f", description = "Target file")
  public String file; //тип String потому что библиотека jc напрямую работу с файлами не поддерживает


  public static void main(String[] args) throws IOException { //запускаемый файл
    GroupDataGenerator generator = new GroupDataGenerator();
    JCommander jCommander = new JCommander(generator);
    try {//заворачиваем в метод try
      jCommander.parse(args);
    } catch (ParameterException ex) {//перехватываем исключение
      jCommander.usage(); //если исключение возникло, то выводим на консоль инфо о доступных опциях при помощи метода usage()
      return; //метод генератор запускать не надо
    }
    generator.run();
  }

  private void run() throws IOException {
//1 часть генерация данных
    List<GroupData> groups = generatorGroups(count);
    //2 часть сохраненние данных в файл
    save(groups, new File(file)); //преобразуем

  }


  private List<GroupData> generatorGroups(int count) {
    List<GroupData> groups = new ArrayList<GroupData>();
    for (int i = 0; i < count; i++) {
      groups.add(new GroupData().withName(String.format("test %s", i))
              .withHeader(String.format("header %s", i))
              .withFooter(String.format("footer %s", i)));
    }
    return groups;
  }

  private void save(List<GroupData> groups, File file) throws IOException {
    //открываем файл на запись
    System.out.println(new File(".").getAbsolutePath());
    Writer writer = new FileWriter(file);
    for (GroupData group : groups) {
      writer.write(String.format("%s;%s;%s\n", group.getName(), group.getHeader(), group.getFooter()));
    }
    //закрываем файл
    writer.close();
  }


}

Сделаем дополнительный параметр - опцию командной строки
  @Parameter(names = "-d", description = "Data format")
  public String format;

Теперь при запуске нужно указывать третий параметр Edit Configuration
-f src/test/resouces/groups.xml -c 3 -d xml


Нужно добавить проверку в run()


   private void run() throws IOException {
    List<GroupData> groups = generatorGroups(count);
    if (format.equals("csv")) { //свернутая конструкция if где идет серия однотипных проверок
      saveCsv(groups, new File(file));
    } else if (format.equals("xml")) {
      saveXml(groups, new File(file));
    } else { //в конце нужно сообщить пользователю если он указан нераспознаваемый формат
      System.out.println("Unrecognized" + format);
    }
  }

Создаем saveXml()

  private void saveXml(List<GroupData> groups, File file) { //(список групп, который нужно сохранить, файл, в который нужно сохранить)
  
  }

Смотрим как надо работать с библиотекой http://x-stream.github.io/tutorial.html


Создаем объект типа xstream

XStream xstream = new XStream();

Now, to convert it to XML, all you have to do is make a simple call to XStream:

String xml = xstream.toXML(groups); //в качестве параметра передаем тот объект, который нужно сериализовать 
//то есть превратить их объектного представления в строчку в формате xml

Делаем writer, который может выбрасывать исключение. Поэтому добавляем эту инфо в декларацию метода.

  private void saveXml(List<GroupData> groups, File file) throws IOException {
    XStream xstream = new XStream();
    String xml = xstream.toXML(groups);
    Writer writer = new FileWriter(file);
    writer.write(xml);
    writer.close();
  }















}	
Урок 65. Формат JSON 00:10:17
Урок 66. Автоматическое закрытие файлов после использования 00:03:13
Урок 67. Конфигурационные файлы для описания тестовых наборов 00:08:14
Урок 68. Описание конфигурации тестового стенда 00:12:56
Урок 69. Протоколирование (лог-файлы) 00:13:38


Занятие 7. Работа с базами данных

Урок 70. Драйвер базы данных. Получение данных из БД 00:13:19

Урок 71. Object Relational Mapping (ORM) 00:17:30

Урок 72. Условия отбора данных 00:09:05

Урок 73. Сравнение данных, загруженных из БД 00:13:09

Урок 74. Отключаемые проверки UI 00:08:54

Урок 75. Связи между объектами 00:16:38

Урок 76. Установка нового учебного приложения MantisBT 00:04:27

Урок 77. Подготовка проекта для тестирования MantisBT 00:09:51

Урок 78. Прямое взаимодействие с сервером по протоколу HTTP 00:16:34

Урок 79. Ленивая инициализация помощников 00:08:35

Урок 80. Передача файлов на удалённую машину по протоколу FTP 00:13:56

Урок 81. Получение почты на встроенный в тесты почтовый сервер 00:24:55

Урок 82. unnamed 82 00:16:38

Урок 83. Немного теории про Remote API 00:12:35

Урок 84. SOAP - простой пример 00:11:44

Урок 85. SOAP - взаимодействие с MantisBT 00:22:17

Урок 86. REST - взаимодействие с Bugify 00:24:43

Урок 87. RestAssured - использовать или нет 00:06:32

Урок 88. REST - взаимодействие с GitHub 00:10:26

Урок 89. Сервер непрерывной интеграции 00:23:21

Урок 90. Удалённый запуск браузера (Selenium Server) 00:15:57

Урок 91. Конфигурационное тестирование (Selenium Grid) 00:20:00

Урок 92. Генерация отчётов при помощи Allure 00:25:35

Урок 93. Keyword Driven Testing и инструмент Robot Framework 00:20:52

Урок 94. Behaviour Driven Testing и инструмент Cucumber-JVM 00:22:15	
	
	
	
	
	
	
	
	
	