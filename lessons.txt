Занятие 1.
Lesson1. Основы

Написать программу 
Загрузить в память 
Хранить пока не запустится
ЦП начинает ее исполнять
Результат

Программа - набор инструкций и данных для обработки. На выходе получаем результат.

Уровни языков 
высокий (исходный код)
низкий (машинный код) 

Трансляция - перевод языка с высого на низкий уровень
Машинный код - код, исполняемый непосредственно процессором


Языки условно разделяются на: 
Компилируемый 
Интерпритируемый 

Способ 1
Исходный код программы пишется на каком-то языке программирования, инструмент который транслирует исходный код в машинный, называется компилятор. На выход он принимает программу на высокоуровневом языке, на выходе получается файл, сожержащий исполняемый код, который может исполняться ЦП. Компилятор порождает файл, который может самостоятельно исполняться. После создания файла компилятор не нужен. Компилятор нужен только разработчику. Пользователю нужен только скомпилированный исполняемый файл. Программа распостраняется в виде исполняемого файла. 

Способ 2
Интерпретатор читает исходный код, написанный на языке высокого уровня. Интерпретатор выполняет команды этого языка. На процессоре исполняется интерпретатор, а не какая-то программа, которая им порождается. Интерпретатор ничего не порождает, он сам работает и сам во время работ интерпретирует исходный код программы. Пользователю нужно установить интерпретатор. Программа распостряняется в виде исходных кодов. 

Способ 3
Одновременное наличие компилятора и интерпретатора. 
Исходный код программы с помощью компилятора преобразуется в байт-код. Байт код - промежуточное представление. Это низкоуровневый код, но еще не машинный код. Для исполнения байт кода нужен интерпретатор, который читает программу в байт коде и исполняет ее. В отличии от классического интерпритатора, низкоуровневый байт код легче и быстрее интерпретировать. 

Преимущества способа 3   
1. Простой и быстрый интерпретатор
2. Переносимость (кроссплатформенность). Исполняемый код для разных процессоров и ОС нужен разный. Если разработчики не ходят открыть свой код, и при этом они не сделали исполняемый код для вашей платформы, то сами сделать вы не сможете. 
А байт код, в отличии от обычного машинного кода, является универсальным. Компилятор универсальный, а интерпретатор под каждую платформу отдельный. В результате, программа распостраняется в одном единственном формате, возможность запуска определяется исключительно наличием интерпретатора для этой платформы.    
	
Java распостраняется в виде двух дистрибутивов. 
Java SDK (compiler + JRE ) для разработчиков.
Java Runtime Environment (JRE) для пользователей.



---


Lesson2.  Установка Java SDK. Настройка окружения.

Путь инсталяции
C:\Program Files\Java\jdk-11.0.1\

Настройка окружение

Путь к исполняемому файл 
C:\ProgramData\Oracle\Java\javapath\

Путь к JRE 
‪C:\Program Files\Java\jre1.8.0_181\bin\java.exe

Инсталятор настраивает окружение на JRE, так как это удобно пользователям для запуска java программ. Нам нужно перенастроить окружение так, чтобы вместо этого использовались исполняемые файлы JSK.

Для этого модифицируем переменную окружения path 
Control Panel\All Control Panel Items\System > Advanced system settings > System Properties > Environment Variables > Path

c:\Program Files\Java\jdk-11.0.1\

	

Создали путь для JSK

Путь к исполняемому файлу where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe

Путь к компилятору where javac
c:\Program Files\Java\jdk-11.0.1\bin\javac.exe


Поднимаем переменную JAVA_HOME вверх, чтобы в командной строке получилось
C:\Users\kobzev\Documents\temp>where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe
C:\ProgramData\Oracle\Java\javapath\java.exe






C:\Program Files\Java\jdk-11.0.1\
---

Lesson3. 

Расширение .java указывает на то, что внутри хранится исходный код.


Пишем программу myFirstProject.java
public class myFirstProject {

	public static void main(String[] args) {
		System.out.println("Hello, world!");
	}
}


C:\Users\kobzev\Documents\temp>javac myFirstProject.java //компилируем

C:\Users\kobzev\Documents\temp>java myFirstProject //запускаем байт код
Hello, world!


---

Lesson4. Система хранение кода 

Зачем?
Резервная копия исходного кода
Ослеживание изменений (история)
Синхронизация, совместный доступ



Add .gitignore - параметр определяет чего не нужно сохранять в репозитории (файлы компиляций/отчеты о выполнении тестов)


Поэтому создаем файл .gitignore описывающий что сохранять не нужно

Выбираем Gradle / Apache License 2.0

Клонирование - программа для локальной копии

---
Lesson5. Сборщики

В больших проектах много файлов, дополнительных библиотек. При компиляции нужно указывать пути к файлам с исходным кодом, библиотекам, опции. 
Решение
Написать один конфигурационный файл, Gradle, который берет конфигурационный файл и компилирует с описанием.

Конфигурационный файл может описывать настройки запуска, тестов. 

Популярные сборщики для Java
Аpache Аnt
Apache Maven
Gradle

Подготовка проекта
sandBox

Создание конфигурационного файла sandBox.gradle

Сборщики являются универсальными инструментами, умеют работать с разными языками программирования.
Необходимо подлючить плагин 
apply plugin: 'java'
Этот плагин требует создание определенной структуры директорий. Он будет искать файлы с исходным кодом на языке java в определенном месте (будем использовать настройки по умолчанию).

Создаем структуру директорий
src > main | test

main > java //сюда кладем файлы с исходными кодами, кроме тестов
test > java //сюда кладем тесты

Перемещаем myFirstProject.java в директорию main
Переходим в корневую папку sandBox
Запускаем консоль и компилируем файл с помощью gradle
c:\Tools\gradle-4.10.3\bin\gradle build

В проекте sandBox появляется два подкаталога
первый содержит вспомогательные файлы, которые нужны gradle для работы
c:\Users\Admin\Documents\temp\sandBox\.gradle\

второй сожержит результат компиляции
c:\Users\Admin\Documents\temp\sandBox\build\classes\java\main\

Для того, чтобы запустить скомпилированный файл class используется плагин
apply plugin: 'application'

Для того, чтобы данный плагин знал, что запускать указываем настройку
mainClassMain = "myFirstProject"


c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle run
 
запускается перекомпиляция и на консоль выводится наш текст "Hello, world!"

Уложить все в репозиторий


gradle можно интегрировать в проект, так чтобы все необходимое для его запуска хранилось в самом проекте. Для создания такого запускателя, gradle все таки понадобится. После того как запускатель создан, отдельно стоящий gradle уже использоваться не будет. 

В консоли выполняем команду запускателя
c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle wrapper  

Внутри проекта sandBox появляются новые файлы, которые представляют собой запускатель.
Укладываем их в репозиторий.



c:\Users\Admin\Documents\GitHub\java_test\sandBox\gradlew build

Скачивается и устанавливается внутрь проекта отдельный сборщик gradle. В результате отдельный gradle уже не будет использоваться.

После того, как дистрибутив загружен он распаковывается внутрь проекта и используется для сборки и запуска.
c:\Users\Admin\Documents\GitHub\java_test\sandBox>gradlew run

---
Lesson6. Среда разработки

Основные
NetBeans
Eclipse
IJ


IJ позволяет оперировать двумя разными сущностями
проект - это группа модулей
модуль 

Выбираем New Project > Empty Project
Project Location: java_test //корневую директорию

Изменяем
Project Structure > SDKs + // указать где находится java
C:\Program Files\Java\jdk-11.0.1

Gradle Project 
Use auto-import enabled
Позволяет автоматически сихронизировать модуль, который мы создаем в среде разработки, с конфигурационным файлом build.gradle (когда изменения вносятся в конфигурационный файл, автоматически обновляется модуль).

Create durectories for empty content roots automatically
Используется когда есть пустой модуль с конфигурационным файлом

Create separate module содержит три типа модулей
для подкатолога src main
для подкатолога src test
общий

Открваем myFirstProject.class 
Запускаем в среде разработки IJ
Комитим в гитхаб

В GitHub видим последнии изменения, сохранять их нужно не все потому что они быстро меняются
workspace.xml // содержит информацию о том, какие файлы открыты в среде IJ
misc.xml 

помещение (push) 
получение (pull)

Скачать все ветки с origin, но не мержить их в локальный репозиторий:
fetch orgin 


---
Lesson7. Рассматриваем высокуровневую структуру

В Java есть соответствие между файлами и классами. 
Если есть файл myFirstProject.java, то он должен содержать класс с таким же именем myFirstProject без расширения (не допускается несоответствие имен)

IJ автоматически сохраняет исходный код, компилирует его, и выводит сообщение об ошибке (при наличии)


Пакеты - с физической точки зрения соответствуют наборам директорий. Предназначены для того, чтобы избегать конфликты имен файлов и разрешить создавать файлы с одинаковыми именами. Рекомендуется классы помещать в индивидуальные пакеты.

Refactor > Move > Create New Package // ru.testjava.sandBox

Помещаем в папку src main, в которой создается иерархическая структура директорий. Таким образом, исключаются все конфликты между именами файлов. 


---
Lesson8. Рассматриваем содержимое файла исходного кода

Класс - основная структурная единица кода. Любой исполняемый код должен находится внутри какого-то класса. 

public class myFirstProject {}- открывая файл исходного кода обнаруживаете декларация одноименного класса. Внутри фигурный скобок находится описание класса (ограничитель для блока кода). 

Все конструкции заканчиваются ;

Метод = функция = блок кода (параметры) {конструкции, выражения}

метод main принимает на себя массив строке


Форматирование 
Code > Reformat Code  

Правила именования
классы всегда с большой буквы
все остальное с маленькой буквы

СamelCase


---
Lesson9

В java есть определенные правила вычислений. Если в выражении есть целые числа, то результат должен является тоже целым числом.
В ПК целые и дробные числа хранятся по разному. Для хранения дробных чисел используется представление чисел с плавающей точкой (2*10^3)

System.out.println("2" + 2) > 22 //число преобразуется в строку, и две строки склеиваются



---
Lesson10 Переменные и значения

Значения - это выражение которое нельзя упростить. 
Часть даных, которая хранится в памяти компьютера. 

System.out.println("2" + 2)

("2" + 2) - выражение, получаемое путем склеивания двух значений
Когда выражение выполняется, то результатом склейки является новое значение.

Литеральные значения - явно описанные в коде программы.
Вычисляемые значения - получаемые в результате вычисления каких-то значений.

Переменная - идентификатор / имя ссылающееся на какое-то значение.

В java все значения участвующие в вычислении должны быть известны.

---
Lesson 11. Типы переменных и значений

Java язык со строгим контролем типов / со строгой типизацией

int В = 8

int указание на тип переменной, в нее можно поместить только тип целых числел

Типы значений
целые числа 
числа с плавающей точкой
строки, заключенные в кавычки


Для них опеределены разные операции , и даже одинаковые операции выполняются по разному


Java для каждого значения значет значение, оно по разному представляется внутри компьютера.

Тип значения не совместим с типом переменной
int B = 8.0 или
int B = "Hello"


Переменная типа int может ссылаться только на значение с целым числом.


double - число двойной точности (с плавающей точкой)

Языки со строгой типизацией - это языки, которые отслеживают несоответствие типов на этапе компиляции, а не на этапе выполнения когда выражение будет реально вычисляться.

---
Lesson12. Среда разработки

Отладчик (Debug) - позволяет выполнять программу последовательно, строчку за строчкой. И во время отладки смотреть какие значения преобретают переменные. Пользуются чтобы понять что происходит во время выполнения программы.

Точка останова

Нажать Step Over чтобы выполнить одну строку. 
Выполнилась та строка, в которой определяется переменная somebody. И эта переменная теперь видна в отладчике. Мы можем посмотреть ее значение. 


---
Lesson13. Функции именованные куски кода

Создадим функцию, которая выполняет строку System.out.println("Hello, world!");  

Чтобы создать функцию, выводящую на экран приветствие по имени, нужно
Объявим переменную 
String somebody = "world";

Переменная somebody определена внутри функции, и значение ей присвается внутри функции.

public static void hello() {
		String somebody = "world";
		System.out.println("Hello, " + somebody + "!");
	}

Для того, чтобы значение можно было менять из вне, нужно ее объявить по другому:
 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world"); 					//место где функкия вызывается, передаем конкретное значение этого параметра 
	}

	public static void hello(String somebody) { //где somebody - параметр, аргумент функции
		System.out.println("Hello, " + somebody + "!");
	}

}

Теперь функция main обращается к функции hello, и передает туда строчку world. Эта строчка присвается, в качестве значения, параметру somebody. Далее это значение используется в коде функции. 

Void - нично, пустота. Функция не возвращает никакого значения. 

public static double area(double b){
		return b * b;
	}

Тип возвращаемого результата, указывается перед именем функции area.



package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world");
		hello("user");
		hello("Max");

		double l = 5; // переменная#1 - l (за пределами функ main она не существует)
		System.out.println("Площадь квадрата со стороной " + l + " = " + area(l));
	}

	public static void hello(String somebody) {
		System.out.println("Hello, " + somebody + "!");
	}

	public static double area(double l){ //переменная#2 - l (за пределами функ area она не существует) 
		return l * l; 
	}
}

Область видимости для переменной ограничевается телом функции (фигурными скобками, внутри которых она определена).
Переменная#1 и переменная#2 между собой никак не связаны.
Те переменные, которые указаны как параметры функции, тоже считаются относящиеся к ней.

Следующий шаг.

Создаем функцию, которая вычисляет площадь прямоугольника.

public static double area(double len){
		return len * len;
	}

	public static double area(double a, double b) {
		return a * b;
	}
	
Имеется две функции с одниковыми именами. Java их отличает, потому что у них разные параметры. 

Обратимся ко второй area

double a = 	b



--
Lesson14. Классы, объекты, конструкторы

Объект - сложная структура хранения информации (дата), состоит из значений - полей / атрибутов (дд / мм / гггг)

Объекты могут хранить разные типы данных, поэтому у них может быть разная структура.

Для описания структуры однотипных объектов используется конструкция - класс.

Класс - это описание структуры однотипных объектов. Объекты - экземпляры, представители класса.

Создадим классы, описывающие объекты, площадь для которых мы вычисляем.

Создадим класс типа Квадрат
package ru.testjava.sandBox;

public class Square { //класс, который описывает структуру объектов, хранящих информацию о квадратах
    public double l; //описываем атрибут, которыми обладает объект. У квадрата это длина строны.
}

Создадим класс типа Прямоугольник
package ru.testjava.sandBox;

public class Rectangle {
    public double a; //у прямоугольника это две стороны
    public double b; 
}

После описания классов, можно создавать объекты, которые являются представителями или экземплярами этих классов.

Square s = new Square(); // создаем новый объект класса
s.l = 5; // обращаемся к первой area, устанавливает значение атрибута l равное 5
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

public static double area(Square s){ //функция area принимает не сторону, а объект типа Квадрат
		return s.l * s.l; // s.l чтобы предоставить доступ к атрибуту объекта
	}

Когда идет речь об объектах сложной структуры, то передавать в качестве параметра в вызываемую функцию один объект, лучше чем 10-20 параметров, которые описывают атрибуты этого объекта.   

В дальнейщем будем работать с объектами, которые имеют много атрибутов.


Rectangle r = new Rectangle(); // создается новый объект класса
		r.a = 4; // указываем (заполняем) значения атрибутов
		r.b = 6;

Можно сделать другим способом

Внутри класса объявим псевдофункцию - конструктор. 
Конструктор предназначен для того, чтобы заполнить атрибуты нового созданного объекта, некоторыми значениями, которые передаются в качестве параметра в этот контсруктор. 

public Square(double len) {
    l = len;
}
	
Конструктор - это специальная функция, которая имеет имя класса и не имеет возвращаемого значения. Тип значения не указывается. Конструктор может принимать параметры. 
Внутри фигурных скобок необходимо написать код, который инициализирует новый объект. То есть заполняет его атрибуты какими-то значеняими.

 

В итоге, получаем
	
package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world");
		hello("user");
		hello("Max");

		Square s = new Square();
		s.l = 5; // обращаемся к первой area: устанавливаем значение атрибута равное 5
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s)); /* передаем объект, в качестве параметра функции; s.1 используем объект, у которого мы берем атрибут s.l */
		Rectangle r = new Rectangle(); // чать когда, где функция вызывается
		r.a = 4; // обращаемся ко второй area
		r.b = 6;
		System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + area(r));


	}

	public static void hello(String somebody) {
		System.out.println("Hello, " + somebody + "!");
	}

	public static double area(Square s){ // функция принимает не сторону квадрата, а объект типа Квадрат
		return s.l * s.l; // для того чтобы получить доступ к атрибуту объекта, необходимо написать (объект).(значение атрибута)
	}

	public static double area(Rectangle r) {
		return r.a * r.b;
	}
}


 public Square(double l) { //
        this.l = l; /*объект, который инициализируется в конструкторе; 
		Значение атрибута присваемого объекта, равно значению параметра переданного в конструктор. 
		В первом случае l атрибут, 
		во втором l - переменная, которая объявлена как параметр (аргумент) функции. 
		*/
    }
	
Для того, чтобы присвоить переданное значение именно в атрибут объекта, нужно сослаться на этот объект this.l 

	
---

Lesson15. Методы. Функции объектов.
 	
Функция - именнованный фрагмент кода.
Метод - это функция, связанная (ассоциированная) с каким-то объектом.

Для того, чтобы превратить обычные функции в методы необходимо
1) перенести функцию во внутрь класса, которая описывает соответствующие объекты
2) модификацировать функцию


Переносим функцию в конец класса
Переделка: убираем слово static и параметр функции, добавляем ссылку (this)


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/
 
    }
}


После переделки нужно научится использовать этот метод, вместо той функции из которой он был сделан 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		
		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); /* s.area())(параметр объекта.название метода) - место где вызывается функция (код вызова).  Обращаемся к методу , который ассоциирован с объектом.
		
		*/
		
		
	}

}

Вместо того, чтобы передавать s в качестве параметра area(s), мы его указываем перед названием s.area(). Вместо обращениния к атрибуту объекта, мы обращаемся к методу, который ассоциирован с этим объектом. 

Когда Java видит конструкцию s.area() она находит функцию area(), которая находится в классе Square, соответствущему этому объекту, и вызывает эту функцию public double area(){return this.l * this.l;}
А тот объект, в котором эта функция (метод) вызывалась, становится доступен через специальный идентификатор this.

Ключевое слово static исчезло, потому что оно используется чтобы помечать фукнции, которые не ассоциированы не с каким объектом. К которым можно обращаться напрямую.  

К методам можно обращаться только указав перед ними объект, в котором этот метод вызывается s.area(). 


package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {

		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); // обращаемся к методу, который ассоциирован с объектом

		Rectangle r = new Rectangle(4, 6); // чать когда, где функция вызывается
		System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + r.area());
	}
}


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/

    }
}


package ru.testjava.sandBox;

public class Rectangle {

    public double a;
    public double b;

    public Rectangle(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double area() {
        return this.a * this.b; //ссылка на объект доступно через ключевое слово this. ссылка на тот объект, в котором этот метод вызван
    }
}

В двух классах Square и Rectangle находятся функции с одинаковыми именами и без параметров area(). Эти функции между собой не конфликтуют, потому что они находятся в разных классах и Java легко определяет какую из этих функций следует вызывать. 

Если вызывается метод в объекте s.area(), который является экземляром класса Square, значит будет выполняться функция с именем area(), которая находится в классе Square.
Если обращаемся к методу объекта, который имеет тип (является представилем класса) Rectangle, значит будет выполняться функция находящаяся в классе Rectangle.


---

Занятие 2.

Lesson16.
Что такое автотесты?

Стек автотестирования - общий набор инструментов, которые задействованы при создании автотестов


Сервер непрерывной интеграции - для автозапуска тестов из хранилища

	Хранилище - для хранения и распостранения 
	Среда разработки - для написания, отлаживания, запуска тестов по отдельности 


Сборщик - может использоваться для компиляции и запуска тестов. Удобно когда нужно запустить все тесты сразу.

Фреймворк запуска тестов. Задача найти, запустить тесты и сгенерировать отчет. 

Тесты - написаны на языке програмирования, должны взаимодействовать с ТС. 

Драйверы тестируемой системы - инструменты, которые помогают взаимодействовать с ТС по сети или через пользовательский интерфейс (написанной на другом языке?)

Тестируемая система


Взаимодействие на прямую означает через программый интерфейс.

Программа, в рамках которой запускаются и работают тесты состоит из фреймворка, тестов, драйвера.
При выполнении тестов, основной запускаемой программой является фреймворк.

---
Lesson17. Gradle подключаем зависимости

Доработаем проект для использования автотестов функций area()
Подлючаем доп зависимость от тестового фреймворка


Готовый к употреблению, скомпилированный код для языка Java распостраняется в виде библиотек.
Физически они представляют собой архивы, в формате .jar
Технически это обычный zip архив который имеет специфическую структуру, использует расширение .jar

Сайт для поиска библиотек в репозитории сборщика
https://search.maven.org

Находим testng
Копируем текст в конфигурационный файл сборщика
Указываем зависимость в специальном блоке "декларация зависимости"


dependencies {
    implementation 'org.testng:testng:7.0.0-beta1'

}

Перед декларацией указываем какой репозиторий следует использовать
repositories {
    mavenCentral()
}

Через некоторое время библиотеки подключатся.

После установки библеотек, рекомендуется их проиндексировать
File > Settings > Build, Executiosn > Build tools > Maven > Repositories

Указывается репозитории, которые используются сборком
локальный 
удаленный

При отсутствии библиотеке в локальном репозитории, среда разработки обращается к удаленному репозиторию. Чтобы было быстрее искать, IJ загружает список всех имеющихся библиотек и индексируюет его.

Загрузка библиотек из удаленого репозитория в локальный.
Эта автоматическая сихронизация модуля в среде разработки с конфигурационным файлом build.gradle происходит благодаря тому, что во время импорта модуля была поставлена галочка Auto Import. 
Но автосинхронизация не всегда работает, список зависимостей не всегда обновляется, несмотря на внесение изменений в конфигурационный файл. 

Выполнение синхронизации в ручную 
View > Tool Windows > Gradle > Refresh  

Документация сборщика, чтобы копировать фрагменты конфигурационного файла  
https://docs.gradle.org/current/userguide/building_java_projects.html



Lesson18. Фреймворк для запуска тестов TestNG


Поместить первый тест в под директорию test > java 
Создать пакет ru.testjava.sandBox.MyFirstProject
Создаем новый класс SquareTests. В Java любой код оформляется в виде классов.

Метод main делать не нужно, потому что запускается тестовый фрейворк. Он находит все тесты, выполняет и генерирует отчет.
В тестовом классе нужно написать методы, которые буду являться тестами.
Каждый метод в отчете будет представлен как отдельный тест.

В тестовом методе нет параметров и возвращаемого результата. О результатах своей работы, он сообщает тестовому фреймворку особым образом.

Создаем новый квадрата
Square s = new Square(5);
Проверяем площадь
assert s.area() == 25; // ключевое слово - логическое выражение. Знак == для сравнения величин, = для присваивания

Нужно пометить метод, чтобы фреймворк понял что это тест
Перед методом нужно написать аннотацию  
Аннотация - это особый класс, которые используются как псевдо комментарии 
Не создаем объекты этого типа, просто указываем название этого класса перед чем нибудь  
Фреймворк по аннатациям находит нужный метод, это для него сигнал что это тест и его нужно запустить


Можно писать короткие имена классов
@Test //Enter - автопродолжение

Чтобы их импортировать, появляется конструкция 
import org.testng.annotations.Test; //полное название класса


Для отображение подробного сообщение об ошибке (expected, actual result) используется вспомогательный класс Assert

import org.testng.Assert;

Assert.assertEquals(s.area(),25.0);

сравниваем значение площади, которое вычислено и ожидаемое значение




package ru.testjava.sandBox;

import org.testng.Assert; //класс Assert 
import org.testng.annotations.Test; //класс Test

public class SquareTests { // 
 
  @Test
  public void testArea(){
    Square s = new Square(5);
    Assert.assertEquals(s.area(),25.0) ;


  }
}


К функции assertEquals() можно обращаться на прямую, так как в ее описании есть слово static
Так как функция находится в классе Assert, а не в текущем классе SquareTests, значит перед ней в качестве префикса нужно указать имя класса 
 Assert.assertEquals() 
Тестовый фремворк контролирует совпадение типов данных

---
Lesson19. Среда разработки

Показать варианты исправления ошибки
курсор на проблемное место Alt + Enter

Список продолжения
Ctrl + Space

---
Lesson20. Selenium драйвер для браузеров

Скачать пакет
https://www.apachefriends.org/ru/download_success.html

Инструкция по установки
https://selenium2.ru/articles/136-installing-xampp.html


Установка приложения addressbook на сервер XAMPP

Распаковать addressbook в папку
c:\xampp\htdocs\  

Подготовка базы данных
MySQL > Admin (http://localhost/phpmyadmin/)

Create New database > addressbook

Создать структуру базы данных (импортировать)
Import > addressbook.sql

http://localhost/addressbook/
admin / secret

Если вход выполнился успешно, значит логин / пароль прочитались из базы данных. Приложение базу данных видит.


Начнем с подготовки нового модуля
Создаем подкаталог (модуль) java_test > addressbook-web-tests
Помещаем туда самое главное -  конфигурационный файл сборщика, потом сможем импортировать его в среду разработки



Перекладываем конфиг файл
build.gradle
и запускатель 
подкаталог gradle 
и запускаемые файлы для платформ win и linux
gradlew
gradlew.bat




Удаляем 
apply plugin: 'application'
mainClassName = "ru.testjava.sandBox.MyFirstProject"
	
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.testng:testng:6.14.3'
}

Скачиваем chromedriver.exe 
https://sites.google.com/a/chromium.org/chromedriver/downloads

Сохраняем в папку
c:\Tools\chromedriver_win32\



Устанавливаем Katalon Recorder
Записываем процесс создания группы http://localhost/addressbook/group.php
Сохраняем запись в формате java-testng.class и помещаем ее в каталог с нашим тестом

Открываем сгенерированный код в среде разработки
Добавляем строку, указываем путь с ChromeDriver и 
    System.setProperty("webdriver.chrome.driver", "c:\Tools\chromedriver_win32\chromedriver.exe");
    driver = new ChromeDriver();

Добавляем в конфиг файл две зависимости
    implementation 'com.katalon:com.katalon.platform.parent:1.0.1'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'

nayti podxodyashiy instrument dlia zapisi koda (naprimer Katalon), skachat poslednie drivera Selenium i vse.

---
Lesson21. Фикстуры инициализация и зачистка

Исправим ошибку в сгенерированном коде тестового метода @Test (аннотация Тест)

имя отличное от имени класса и начало с маленькой буквы

Кроме тестового метода @Test сгенерировались два вспомогательный
BeforeClass //метод инициализации фикстура, единственное место для указания используемого браузера
AfterClass //метод завершения фикстура

Это пометки (подсказки) для тестового фрейворка

Если код дублируется, то его нужно постараться выделить в отдельную функцию. Его можно использовать повторно, обращаясь к этому методу. В случае с тестовым фрейворком, он автоматически вызывает методы BeforClass / AfterClass перед каждым запуском тестового метода.

Фикструр - тестовая ситуация , тест зажимается между двумя методами. 


Модифицируем код 
Действия для авторизации не являются частью теста создания группы, поэтому вырезаем и переносим кусок кода в метод инициализации фикстура.

---
Lesson22. Рефакторинг

Правила безопасного преобразования кода. Структура кода меняется, но функциональность остается неизменной.

С помощью механизма рефакторинга научимся выделять вспомогательные методы.

Рекодер записывает сценарий, который трудно читать
Для удобства пользования мы дадим имя фрагменту кода, сделаем именнованный фрагмент кода. Для этого нужно превратить его в функцию и в нужное время к этой функции обращаться.

Выделяем фрагмент кода для превращения в именнованную функцию
Refactor > Extract > Method 

Фрагмент кода получил собственное имя - там выволняется логин

@BeforeClass
...
login(); // вызов созданного метода (место, в котором к этому фрагменту нужно обратиться)

Почему метода, а не обычной функции?
Внутри используется переменная driver, которая является атрибутом объекта типа GroupCreationTests.  

private void login() {
    driver.findElement(By.name(user)).click();
    driver.findElement(By.name(user)).clear();
	
	...
}

Тестовый фрейворк сначала создает объект класса ?
Потом выполняет метод setUp(){инициалируется атрибут объекта driver = new ChromeDriver();}
Когда вызывается другой метод login() в том же самом объекте, он может этим атрибутом пользоваться.
Также нужно поступить с тестовым методом, выделить из него вспомогательные фукнции.

Первый механизм рефакторинга - это выделение вспомогательных методов.

Следующий шаг

Делаем метод login() параметрализованным, чтобы имя пользователя и пароль передовались внутрь метода в качестве параметров. 

Выделяем значение, которое необходимо превратить в передаваемый параметр
Refactor > Extract > Parameter 
Даем имя username
   

login("admin"); //В точке вызова передается конкретное значение, которое подставляется в эту переменную параметр и используется в методе login
private void login(String username){
	driver.findElement(By.name(user)).sendKeys(username);
}


Тестовый метод создает группу с какими-то свойствами name("group_header") name("group_footer")
Значение этих свойст явно прописаны в коде метода
private void fillGroupForm() {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys("test1");
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys("test2");
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys("test3");
}

Было бы логично передавать их в качестве параметров, чтобы функция fillGroupForm стала универсальной. Ее можно было бы использовать для создания групп с разными параметрами, то есть заполнять форму разными данными. Конкретные значения передавались бы из @Test.

private void fillGroupForm(String name, String header, String footer) {
    driver.findElement(By.name("group_name")).sendKeys(name);
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys(header);
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys(footer);
  }


Создаем новый контакт
У формы контакта много параметров
Как превратить много параметров в мало?

Вместо того, чтобы передавать много разных значений, их можно объединить в один объект, который будет иметь много атрибутов. То есть создать вспомогательный класс, который описывает объект типа Group. Объекты этого типа имеют набор атрибутов.

!В метод будет передаваться один объект
Refactor > Extract > Parameter Object 

@Test
  public void testGroupCreation()
	fillGroupForm(new GroupData("test1", "test2", "test3"));


	private void fillGroupForm(GroupData groupData) {}
	driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
    driver.findElement(By.name("group_header")).sendKeys(groupData.getHeader());
    driver.findElement(By.name("group_footer")).sendKeys(groupData.getFooter());
	
---
Lesson23. Наследование общий базовый класс

Создадим отдельные классы тестов
- создание группы
- удаление группы
Куда поместить вспомогательные функции, чтобы их можно было использовать в нескольких классах?

Начнем с создания теста для удаления групп
Запись теста преобразуем с расширением java+testng
Помещаем в пакет

Исправляем имя пакету

Когда задается объект типа GroupDeletionTests, то в этом объекте нельзя вызывать функции, находящиеся в другом классе. Они с этим объектом никак не ассоциированы. 

Наследование - механизм, позволяющий сделать общее пространство для нескольких классов.

Чтобы воспользоваться механизмом наследования, нужно создать новый класс в который будут помещены общие методы. Класс GroupCreationTests будет расширять этот новый класс. 

public class GroupDeletionTests extends TestBase {}
 
Создадим новый класс TestBase 
Поместим туда общие методы














