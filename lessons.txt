Занятие 1.
Урок 1. Основы

Написать программу 
Загрузить в память 
Хранить пока не запустится
ЦП начинает ее исполнять
Результат

Программа - набор инструкций и данных для обработки. На выходе получаем результат.

Уровни языков 
высокий (исходный код)
низкий (машинный код) 

Трансляция - перевод языка с высого на низкий уровень
Машинный код - код, исполняемый непосредственно процессором


Языки условно разделяются на: 
Компилируемый 
Интерпритируемый 

Способ 1
Исходный код программы пишется на каком-то языке программирования, инструмент который транслирует исходный код в машинный, называется компилятор. На выход он принимает программу на высокоуровневом языке, на выходе получается файл, сожержащий исполняемый код, который может исполняться ЦП. Компилятор порождает файл, который может самостоятельно исполняться. После создания файла компилятор не нужен. Компилятор нужен только разработчику. Пользователю нужен только скомпилированный исполняемый файл. Программа распостраняется в виде исполняемого файла. 

Способ 2
Интерпретатор читает исходный код, написанный на языке высокого уровня. Интерпретатор выполняет команды этого языка. На процессоре исполняется интерпретатор, а не какая-то программа, которая им порождается. Интерпретатор ничего не порождает, он сам работает и сам во время работ интерпретирует исходный код программы. Пользователю нужно установить интерпретатор. Программа распостряняется в виде исходных кодов. 

Способ 3
Одновременное наличие компилятора и интерпретатора. 
Исходный код программы с помощью компилятора преобразуется в байт-код. Байт код - промежуточное представление. Это низкоуровневый код, но еще не машинный код. Для исполнения байт кода нужен интерпретатор, который читает программу в байт коде и исполняет ее. В отличии от классического интерпритатора, низкоуровневый байт код легче и быстрее интерпретировать. 

Преимущества способа 3   
1. Простой и быстрый интерпретатор
2. Переносимость (кроссплатформенность). Исполняемый код для разных процессоров и ОС нужен разный. Если разработчики не ходят открыть свой код, и при этом они не сделали исполняемый код для вашей платформы, то сами сделать вы не сможете. 
А байт код, в отличии от обычного машинного кода, является универсальным. Компилятор универсальный, а интерпретатор под каждую платформу отдельный. В результате, программа распостраняется в одном единственном формате, возможность запуска определяется исключительно наличием интерпретатора для этой платформы.    
	
Java распостраняется в виде двух дистрибутивов. 
Java SDK (compiler + JRE ) для разработчиков.
Java Runtime Environment (JRE) для пользователей.



---


Урок 2.  Установка Java SDK. Настройка окружения.

Путь инсталяции
C:\Program Files\Java\jdk-11.0.1\

Настройка окружение

Путь к исполняемому файл 
C:\ProgramData\Oracle\Java\javapath\

Путь к JRE 
‪C:\Program Files\Java\jre1.8.0_181\bin\java.exe

Инсталятор настраивает окружение на JRE, так как это удобно пользователям для запуска java программ. Нам нужно перенастроить окружение так, чтобы вместо этого использовались исполняемые файлы JSK.

Для этого модифицируем переменную окружения path 
Control Panel\All Control Panel Items\System > Advanced system settings > System Properties > Environment Variables > Path

c:\Program Files\Java\jdk-11.0.1\

	

Создали путь для JSK

Путь к исполняемому файлу where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe

Путь к компилятору where javac
c:\Program Files\Java\jdk-11.0.1\bin\javac.exe


Поднимаем переменную JAVA_HOME вверх, чтобы в командной строке получилось
C:\Users\kobzev\Documents\temp>where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe
C:\ProgramData\Oracle\Java\javapath\java.exe






C:\Program Files\Java\jdk-11.0.1\
---

Урок 3. 

Расширение .java указывает на то, что внутри хранится исходный код.


Пишем программу myFirstProject.java
public class myFirstProject {

	public static void main(String[] args) {
		System.out.println("Hello, world!");
	}
}


C:\Users\kobzev\Documents\temp>javac myFirstProject.java //компилируем

C:\Users\kobzev\Documents\temp>java myFirstProject //запускаем байт код
Hello, world!


---

Урок 4. Система хранение кода 

Зачем?
Резервная копия исходного кода
Ослеживание изменений (история)
Синхронизация, совместный доступ



Add .gitignore - параметр определяет чего не нужно сохранять в репозитории (файлы компиляций/отчеты о выполнении тестов)


Поэтому создаем файл .gitignore описывающий что сохранять не нужно

Выбираем Gradle / Apache License 2.0

Клонирование - программа для локальной копии

---
Урок 5. Сборщики

В больших проектах много файлов, дополнительных библиотек. При компиляции нужно указывать пути к файлам с исходным кодом, библиотекам, опции. 
Решение
Написать один конфигурационный файл, Gradle, который берет конфигурационный файл и компилирует с описанием.

Конфигурационный файл может описывать настройки запуска, тестов. 

Популярные сборщики для Java
Аpache Аnt
Apache Maven
Gradle

Подготовка проекта
sandBox

Создание конфигурационного файла sandBox.gradle

Сборщики являются универсальными инструментами, умеют работать с разными языками программирования.
Необходимо подлючить плагин 
apply plugin: 'java'
Этот плагин требует создание определенной структуры директорий. Он будет искать файлы с исходным кодом на языке java в определенном месте (будем использовать настройки по умолчанию).

Создаем структуру директорий
src > main | test

main > java //сюда кладем файлы с исходными кодами, кроме тестов
test > java //сюда кладем тесты

Перемещаем myFirstProject.java в директорию main
Переходим в корневую папку sandBox
Запускаем консоль и компилируем файл с помощью gradle
c:\Tools\gradle-4.10.3\bin\gradle build

В проекте sandBox появляется два подкаталога
первый содержит вспомогательные файлы, которые нужны gradle для работы
c:\Users\Admin\Documents\temp\sandBox\.gradle\

второй сожержит результат компиляции
c:\Users\Admin\Documents\temp\sandBox\build\classes\java\main\

Для того, чтобы запустить скомпилированный файл class используется плагин
apply plugin: 'application'

Для того, чтобы данный плагин знал, что запускать указываем настройку
mainClassMain = "myFirstProject"


c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle run
 
запускается перекомпиляция и на консоль выводится наш текст "Hello, world!"

Уложить все в репозиторий


gradle можно интегрировать в проект, так чтобы все необходимое для его запуска хранилось в самом проекте. Для создания такого запускателя, gradle все таки понадобится. После того как запускатель создан, отдельно стоящий gradle уже использоваться не будет. 

В консоли выполняем команду запускателя
c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle wrapper  

Внутри проекта sandBox появляются новые файлы, которые представляют собой запускатель.
Укладываем их в репозиторий.



c:\Users\Admin\Documents\GitHub\java_test\sandBox\gradlew build

Скачивается и устанавливается внутрь проекта отдельный сборщик gradle. В результате отдельный gradle уже не будет использоваться.

После того, как дистрибутив загружен он распаковывается внутрь проекта и используется для сборки и запуска.
c:\Users\Admin\Documents\GitHub\java_test\sandBox>gradlew run

---
Урок 6. Среда разработки

Основные
NetBeans
Eclipse
IJ


IJ позволяет оперировать двумя разными сущностями
проект - это группа модулей
модуль 

Выбираем New Project > Empty Project
Project Location: java_test //корневую директорию

Изменяем
Project Structure > SDKs + // указать где находится java
C:\Program Files\Java\jdk-11.0.1

Gradle Project 
Use auto-import enabled
Позволяет автоматически сихронизировать модуль, который мы создаем в среде разработки, с конфигурационным файлом build.gradle (когда изменения вносятся в конфигурационный файл, автоматически обновляется модуль).

Create durectories for empty content roots automatically
Используется когда есть пустой модуль с конфигурационным файлом

Create separate module содержит три типа модулей
для подкатолога src main
для подкатолога src test
общий

Открваем myFirstProject.class 
Запускаем в среде разработки IJ
Комитим в гитхаб

В GitHub видим последнии изменения, сохранять их нужно не все потому что они быстро меняются
workspace.xml // содержит информацию о том, какие файлы открыты в среде IJ
misc.xml 

помещение (push) 
получение (pull)

Скачать все ветки с origin, но не мержить их в локальный репозиторий:
fetch orgin 


---
Урок 7. Рассматриваем высокуровневую структуру

В Java есть соответствие между файлами и классами. 
Если есть файл myFirstProject.java, то он должен содержать класс с таким же именем myFirstProject без расширения (не допускается несоответствие имен)

IJ автоматически сохраняет исходный код, компилирует его, и выводит сообщение об ошибке (при наличии)


Пакеты - с физической точки зрения соответствуют наборам директорий. Предназначены для того, чтобы избегать конфликты имен файлов и разрешить создавать файлы с одинаковыми именами. Рекомендуется классы помещать в индивидуальные пакеты.

Refactor > Move > Create New Package // ru.testjava.sandBox

Помещаем в папку src main, в которой создается иерархическая структура директорий. Таким образом, исключаются все конфликты между именами файлов. 


---
Урок 8. Рассматриваем содержимое файла исходного кода

Класс - основная структурная единица кода. Любой исполняемый код должен находится внутри какого-то класса. 

public class myFirstProject {}- открывая файл исходного кода обнаруживаете декларация одноименного класса. Внутри фигурный скобок находится описание класса (ограничитель для блока кода). 

Все конструкции заканчиваются ;

Метод = функция = блок кода (параметры) {конструкции, выражения}

метод main принимает на себя массив строке


Форматирование 
Code > Reformat Code  

Правила именования
классы всегда с большой буквы
все остальное с маленькой буквы

СamelCase


---
Урок 9

В java есть определенные правила вычислений. Если в выражении есть целые числа, то результат должен является тоже целым числом.
В ПК целые и дробные числа хранятся по разному. Для хранения дробных чисел используется представление чисел с плавающей точкой (2*10^3)

System.out.println("2" + 2) > 22 //число преобразуется в строку, и две строки склеиваются



---
Урок 10 Переменные и значения

Значения - это выражение которое нельзя упростить. 
Часть даных, которая хранится в памяти компьютера. 

System.out.println("2" + 2)

("2" + 2) - выражение, получаемое путем склеивания двух значений
Когда выражение выполняется, то результатом склейки является новое значение.

Литеральные значения - явно описанные в коде программы.
Вычисляемые значения - получаемые в результате вычисления каких-то значений.

Переменная - идентификатор / имя ссылающееся на какое-то значение.
Переменная - ссылка, адрес где хранится объект. 
Переменная - ссылка на объект.

В java все значения участвующие в вычислении должны быть известны.

---
Урок  11. Типы переменных и значений

Java язык со строгим контролем типов / со строгой типизацией

int В = 8

int указание на тип переменной, в нее можно поместить только тип целых числел

Типы значений
целые числа 
числа с плавающей точкой
строки, заключенные в кавычки


Для них опеределены разные операции , и даже одинаковые операции выполняются по разному


Java для каждого значения значет значение, оно по разному представляется внутри компьютера.

Тип значения не совместим с типом переменной
int B = 8.0 или
int B = "Hello"


Переменная типа int может ссылаться только на значение с целым числом.


double - число двойной точности (с плавающей точкой)

Языки со строгой типизацией - это языки, которые отслеживают несоответствие типов на этапе компиляции, а не на этапе выполнения когда выражение будет реально вычисляться.

---
Урок 12. Среда разработки

Отладчик (Debug) - позволяет выполнять программу последовательно, строчку за строчкой. И во время отладки смотреть какие значения преобретают переменные. Пользуются чтобы понять что происходит во время выполнения программы.

Точка останова

Нажать Step Over чтобы выполнить одну строку. 
Выполнилась та строка, в которой определяется переменная somebody. И эта переменная теперь видна в отладчике. Мы можем посмотреть ее значение. 


---
Урок 13. Функции именованные куски кода

Создадим функцию, которая выполняет строку System.out.println("Hello, world!");  

Чтобы создать функцию, выводящую на экран приветствие по имени, нужно
Объявим переменную 
String somebody = "world";

Переменная somebody определена внутри функции, и значение ей присвается внутри функции.

public static void hello() {
		String somebody = "world";
		System.out.println("Hello, " + somebody + "!");
	}

Для того, чтобы значение можно было менять из вне, нужно ее объявить по другому:
 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world"); 					//место где функкия вызывается, передаем конкретное значение этого параметра 
	}

	public static void hello(String somebody) { //где somebody - параметр, аргумент функции
		System.out.println("Hello, " + somebody + "!");
	}

}

Теперь функция main обращается к функции hello, и передает туда строчку world. Эта строчка присвается, в качестве значения, параметру somebody. Далее это значение используется в коде функции. 

Void - нично, пустота. Функция не возвращает никакого значения. 

public static double area(double b){
		return b * b;
	}

Тип возвращаемого результата, указывается перед именем функции area.



package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world");
		hello("user");
		hello("Max");

		double l = 5; // переменная#1 - l (за пределами функ main она не существует)
		System.out.println("Площадь квадрата со стороной " + l + " = " + area(l));
	}

	public static void hello(String somebody) {
		System.out.println("Hello, " + somebody + "!");
	}

	public static double area(double l){ //переменная#2 - l (за пределами функ area она не существует) 
		return l * l; 
	}
}

Область видимости для переменной ограничевается телом функции (фигурными скобками, внутри которых она определена).
Переменная#1 и переменная#2 между собой никак не связаны.
Те переменные, которые указаны как параметры функции, тоже считаются относящиеся к ней.

Следующий шаг.

Создаем функцию, которая вычисляет площадь прямоугольника.

public static double area(double len){
		return len * len;
	}

	public static double area(double a, double b) {
		return a * b;
	}
	
Имеется две функции с одниковыми именами. Java их отличает, потому что у них разные параметры. 

Обратимся ко второй area

double a = 	b



--
Урок 14. Классы, объекты, конструкторы

Объект - сложная структура хранения информации (дата), состоит из значений - полей / атрибутов (дд / мм / гггг). Объекты принадлежат  определенному типу.

Объекты могут хранить разные типы данных, поэтому у них может быть разная структура.

Для описания структуры однотипных объектов используется конструкция - класс.

Класс - это описание структуры однотипных объектов. Объекты - экземпляры, представители класса.

Создадим классы, описывающие объекты, площадь для которых мы вычисляем.

Создадим класс типа Квадрат

public class Square { //класс, который описывает структуру объектов, хранящих информацию о квадратах
    public double l; //внутри класса описываем атрибуты, которыми обладает объект этого типа. Квадрат описывается длиной его стороны.
}

Создадим класс типа Прямоугольник

public class Rectangle {
    public double a; //прямоугольник описывается двумя сторонами
    public double b; 
}

После описания классов, можно создавать объекты, которые являются представителями или экземплярами этих классов.

Square s = new Square(); // создаем объект типа Square
s.l = 5; // обращаемся к первой area, устанавливает значение атрибута l равное 5  
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

public static double area(Square s){ //функция area принимает не сторону, а объект типа Квадрат
		return s.l * s.l; //для того чтобы обеспечить доступ к атрибуту этого объекта указываем объект.атрибут 
}

	
	
Когда идет речь об объектах сложной структуры, то передавать в качестве параметра в вызываемую функцию один объект, лучше чем 10-20 параметров, которые описывают атрибуты этого объекта.   

В дальнейщем будем работать с объектами, которые имеют много атрибутов.


Rectangle r = new Rectangle(); // сначала создается объект класса 
	r.a = 4; // потом указываются (заполняются) значения атрибутов**
	r.b = 6;

	
Следующим шагом оптимизируем те части когда, где создаются объекты.
Square s = new Square(); 
	s.l = 5;

Rectangle r = new Rectangle();
	r.a = 4;
	r.b = 6;

	
**Можно сделать другим способом
Внутри класса объявим псевдофункцию - конструктор. 
Конструктор предназначен для того, чтобы заполнить атрибуты нового создаваемого объекта некоторыми значениями, которые передаются в качестве параметра в этот контсруктор. 

Было

public class Square(){
	public double l;
}

Стало

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


Конструктор - это специальная функция, которая имеет имя класса и не имеет возвращаемого значения. Тип возвращаемого значения не указывается. Конструктор может принимать параметры. 
Внутри фигурных скобок необходимо написать код, который инициализирует новый объект. То есть заполняет его атрибуты какими-то значеняими.

Теперь нельзя создать Square s = new Square(); потому что конструктор объектов этого типа требует, чтобы ему были переданы значения параметров.

Было
Square s = new Square(); 
	s.l = 5;
	
 
Стало
Square s = new Square(5); //атрибуты заполняются в конструкторе

 
Ключевое слово this
Это тот объект, который инициализируется в конструкторе.

было

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


стало

public class Square(){
	public double l;
	
	public Square(double len){
	this.l = len;	
	}
}
 
Когда у нас есть какая то переменная s, которая ссылается на объект, то обращаться к атрибуту мы можем через эту переменную s.l
Square s = new Square(5);
s.l

Но в конструкторе в качестве специальной переменной, которая ссылается на конструируемый объект, выступает ключевое слово this.   

было
public class Square(){
	public double l;
	
	public Square(double len){ //len параметр контсруктора
	this.l = len;	
	}
}



стало 
 public class Square(){
	public double l;
	
	public Square(double l){
	this.l = l;	//так выглядит присваемое значение в атрибут. название аргумента конструктора совпадает с названием атрибута   
	}
}

В первом случае l атрибут, во втором l - переменная, которая объявлена как аргумент функции (переменная, являющаяся аргументом функции). 
Написать l=l нельзя тогда в обоих случах будет использоваться переменная  (double l)
Для того, чтобы присвоить переданное значение именно в атрибут объекта, нужно сослаться на этот объект this.l 
Значение атрибута создаваемого объекта, равно значению параметра переданного в конструктор.


В итоге, получаем
	
package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
	Square s = new Square(5);
	System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

	Rectangle r = new Rectangle(4,6); //длины сторон прямоугольника передаются в качестве параметра в конструктор 
	System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + area(r));
	}


	public static double area(Square s){ // функция принимает не сторону квадрата, а объект типа Квадрат
	return s.l * s.l; // для того чтобы получить доступ к атрибуту объекта, необходимо написать объект.атрибут
	}

	public static double area(Rectangle r) {
	return r.a * r.b;
	}
}


public Square(double l) { 
    this.l = l;
}
	
public Rectangle(double a, double b) {
	this.a = a;
	this.b = b;
	
}
	
---

Урок 15. Методы. Функции объектов.
 	
Функция - именнованный фрагмент кода.
Метод - это функция, связанная (ассоциированная) с каким-то объектом.

Для того, чтобы превратить обычные функции в методы необходимо
1) перенести функцию во внутрь класса, которая описывает соответствующие объекты
2) модификацировать функцию


Переносим функцию в конец класса
Переделка: убираем слово static и параметр функции, добавляем ссылку (this)


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/
 
    }
}


После переделки нужно научится использовать этот метод, вместо той функции из которой он был сделан 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		
		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); /* s.area())(параметр объекта.название метода) - место где вызывается функция (код вызова).  Обращаемся к методу , который ассоциирован с объектом.
		
		*/
		
		
	}

}

Вместо того, чтобы передавать s в качестве параметра area(s), мы его указываем перед названием s.area(). Вместо обращениния к атрибуту объекта, мы обращаемся к методу, который ассоциирован с этим объектом. 

Когда Java видит конструкцию s.area() она находит функцию area(), которая находится в классе Square, соответствущему этому объекту, и вызывает эту функцию public double area(){return this.l * this.l;}
А тот объект, в котором эта функция (метод) вызывалась, становится доступен через специальный идентификатор this.

Ключевое слово static исчезло, потому что оно используется чтобы помечать фукнции, которые не ассоциированы не с каким объектом. К которым можно обращаться напрямую.  

К методам можно обращаться только указав перед ними объект, в котором этот метод вызывается s.area(). 


package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {

		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); // обращаемся к методу, который ассоциирован с объектом

		Rectangle r = new Rectangle(4, 6); // чать когда, где функция вызывается
		System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + r.area());
	}
}


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/

    }
}


package ru.testjava.sandBox;

public class Rectangle {

    public double a;
    public double b;

    public Rectangle(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double area() {
        return this.a * this.b; //ссылка на объект доступно через ключевое слово this. ссылка на тот объект, в котором этот метод вызван
    }
}

В двух классах Square и Rectangle находятся функции с одинаковыми именами и без параметров area(). Эти функции между собой не конфликтуют, потому что они находятся в разных классах и Java легко определяет какую из этих функций следует вызывать. 

Если вызывается метод в объекте s.area(), который является экземляром класса Square, значит будет выполняться функция с именем area(), которая находится в классе Square.
Если обращаемся к методу объекта, который имеет тип (является представилем класса) Rectangle, значит будет выполняться функция находящаяся в классе Rectangle.


---

Занятие 2.

Урок 16.
Что такое автотесты?

Стек автотестирования - общий набор инструментов, которые задействованы при создании автотестов.
//стек - структура данных, организаванных по принципу "последний поступил -  первым обслужен"

Стек автотестирования состоит:

6. Сервер непрерывной интеграции - для автозапуска тестов из хранилища

	6.1 Хранилище - для хранения и распостранения 
	6.2 Среда разработки - для написания, отлаживания, запуска тестов по отдельности 


5. Сборщик - может использоваться для компиляции и запуска тестов. Удобно когда нужно запустить все тесты сразу.

4. Фреймворк - для запуска тестов. Его задача найти, запустить тесты и сгенерировать отчет. 

3. Тесты - написаны на языке програмирования, должны взаимодействовать с ТС. 

2. Драйверы тестируемой системы - инструменты, которые помогают взаимодействовать с ТС по сети или через пользовательский интерфейс (написанной на другом языке?)

1. Тестируемая система (ТС)


Взаимодействие на прямую означает через программый интерфейс.

Программа, в рамках которой запускаются и работают тесты состоит из фреймворка, тестов, драйвера.
При выполнении тестов, основной запускаемой программой является фреймворк.

---
Урок 17. Gradle подключаем зависимости

Доработаем проект для использования автотестов функций area()
Подлючаем доп зависимость от тестового фреймворка TestNG


Готовый к употреблению, скомпилированный код для языка Java распостраняется в виде библиотек.
Физически они представляют собой архивы, в формате .jar
Технически это обычный zip архив который имеет специфическую структуру, использует расширение .jar

Сайт для поиска библиотек в репозитории сборщика
https://search.maven.org

Находим TestNG
Копируем текст в конфигурационный файл сборщика
Указываем зависимость в специальном блоке "декларация зависимости"


dependencies {
    implementation 'org.testng:testng:7.0.0-beta1'

}

Перед декларацией указываем какой репозиторий следует использовать
repositories {
    mavenCentral()
}

Через некоторое время библиотеки подключатся.

После установки библеотек, рекомендуется их проиндексировать
File > Settings > Build, Executiosn > Build tools > Maven > Repositories

Указывается репозитории, которые используются сборком
локальный 
удаленный

При отсутствии библиотеки в локальном репозитории, среда разработки обращается к удаленному репозиторию. Чтобы было быстрее искать, IJ загружает список всех имеющихся библиотек и индексируюет его.

Загрузка библиотек из удаленого репозитория в локальный.
Эта автоматическая сихронизация модуля в среде разработки с конфигурационным файлом build.gradle происходит благодаря тому, что во время импорта модуля была поставлена галочка Auto Import. 
Но автосинхронизация работает не всегда. Список зависимостей обновляется не всегда , несмотря на внесение изменений в конфигурационный файл. 

Выполнение синхронизации в ручную 
View > Tool Windows > Gradle > Refresh  

Документация сборщика для того, чтобы копировать фрагменты конфигурационного файла  
https://docs.gradle.org/current/userguide/building_java_projects.html

---

Урок 18. Фреймворк для запуска тестов TestNG


Поместить первый тест в поддиректорию test > java 
Создать пакет ru.testjava.sandBox
В нем создать класс SquareTests. В Java любой код оформляется в виде классов.

Метод main делать не нужно, потому что запускается тестовый фрейворк. Он находит все тесты, выполняет и генерирует отчет.
В тестовом классе нужно написать методы, которые буду являться тестами.
Каждый метод в отчете будет представлен как отдельный тест.

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class SquareTests {

  @Test
  public void testArea(){
    Square s = new Square(5);
  }
}

В тестовом методе нет параметров и возвращаемого результата. О результатах своей работы, он сообщает тестовому фреймворку особым образом.

Создаем новый квадрат
Square s = new Square(5);
Проверяем площадь
assert s.area() == 25; // ключевое слово assert - логическое выражение "утверждение". Знак == для сравнения величин, а = для присваивания

Нужно пометить метод, чтобы фреймворк понял что это тест.
Перед методом нужно написать аннотацию  
Аннотация - это особый класс, которые используются как псевдо комментарии 
Не создаем объекты этого типа, просто указываем название этого класса перед чем нибудь  
Фреймворк по аннатациям находит нужный метод, это для него сигнал что это тест и его нужно запустить


Можно писать короткие имена классов
@Test //Enter - автопродолжения

Появляется конструкция, чтобы их импортировать 
import org.testng.annotations.Test; //полное название класса

или писать название классов полностью
@org.testng.annotations.Test //тогда конструкция import не нужная

После запуска теста появляется отчет 
Default Suite
Total tests run: 1, Failures: 0, Skips: 0

Но в случае упавшего теста AssertionError, не видно результата выполнения метода area().


Для отображения подробного сообщение об ошибке (expected, actual result) используется вспомогательный класс Assert

import org.testng.Assert;

Assert.assertEquals(s.area(),25.0); //начинаем писать Asserе. и включается механизм автопродолжения + Enter

Сравниваем значение площади, которое вычислено и ожидаемое значение


К функции assertEquals() можно обращаться на прямую, так как в ее описании есть ключевое слово static (подсказка ЛКП + Ctrl)
То есть чтобы воспользоваться этой функцией, не нужно создавать какой-то объект. 

Так как функция находится в классе Assert, а не в текущем классе SquareTests, значит перед ней нужно указать в качестве префикса имя класса Assert.assertEquals() Имякласса.функция




package ru.testjava.sandBox;

import org.testng.Assert; //класс Assert импорт добавляется автоматически 
import org.testng.annotations.Test; //класс Test

public class SquareTests { 

  @Test
  public void testArea(){
    Square s = new Square(5);
    Assert.assertEquals(s.area(),25) ;


  }
}


Результат упавшего теста
java.lang.AssertionError: expected [25] but found [25.0]
Expected :25
Actual   :25.0


Тестовый фремворк контролирует совпадение типов данных
Если Expected 25, а Actual 25.0, то тест считается упавшим.

---
Урок 19. Среда разработки

Показать варианты исправления ошибки Alt + Enter

Список продолжения Ctrl + Space

---
Урок 20. Selenium драйвер для браузеров

Скачать пакет
https://www.apachefriends.org/ru/download_success.html

Инструкция по установки
https://selenium2.ru/articles/136-installing-xampp.html


Установка приложения addressbook на сервер XAMPP

Распаковать addressbook в папку
c:\xampp\htdocs\  

Подготовка базы данных
MySQL > Admin (http://localhost/phpmyadmin/)

Create New database > addressbook

Создать структуру базы данных (импортировать)
Import > addressbook.sql

http://localhost/addressbook/
admin / secret

Если вход выполнился успешно, значит логин / пароль прочитались из базы данных. Приложение базу данных видит.


Начнем с подготовки нового модуля
Создаем подкаталог (модуль) java_test > addressbook-web-tests
Помещаем туда самое главное -  конфигурационный файл сборщика, потом сможем импортировать его в среду разработки



Перекладываем конфиг файл
build.gradle
и запускатель 
подкаталог gradle 
и запускаемые файлы для платформ win и linux
gradlew
gradlew.bat


Удаляем 
apply plugin: 'application'
mainClassName = "ru.testjava.sandBox.MyFirstProject"
	
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.testng:testng:6.14.3'
}

Скачиваем chromedriver.exe 
https://sites.google.com/a/chromium.org/chromedriver/downloads

Сохраняем в папку
c:\Tools\chromedriver_win32\



Устанавливаем Katalon Recorder
Записываем процесс создания группы http://localhost/addressbook/group.php
Сохраняем запись в формате java-testng.class и помещаем ее в каталог с нашим тестом

Открываем сгенерированный код в среде разработки
Добавляем строку, указываем путь с ChromeDriver и 
    System.setProperty("webdriver.chrome.driver", "c:\Tools\chromedriver_win32\chromedriver.exe");
    driver = new ChromeDriver();

Добавляем в конфиг файл две зависимости
    implementation 'com.katalon:com.katalon.platform.parent:1.0.1'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'


---
Урок 21. Фикстуры инициализация и зачистка

Исправим ошибку в сгенерированном коде тестового метода @Test (аннотация Тест)

имя должно быть отличное от имени класса, и начинаться с маленькой буквы

Кроме тестового метода @Test сгенерировались два вспомогательных (пометки/подсказки для тестового фрейворка)
BeforeClass //метод инициализации фикстура, единственное место для указания используемого драйвера - браузера
AfterClass //метод завершения фикстура


Зачистка
Если код дублируется, то его нужно постараться выделить в отдельную функцию. Его можно использовать повторно, обращаясь к этому методу. В случае с тестовым фрейворком, он автоматически вызывает методы BeforClass / AfterClass перед каждым запуском тестового метода.

Фикструр - тестовая ситуация, тест зажимается между двумя методами Before - After. 


Модифицируем код 
Действия для авторизации не являются частью теста создания группы, поэтому вырезаем и переносим кусок кода в метод инициализации фикстура @Before.

---
Урок 22. Рефакторинг

Правила безопасного преобразования кода. Структура кода меняется, но функциональность остается неизменной.

С помощью механизма рефакторинга научимся выделять вспомогательные методы.

Рекодер записывает сценарий, который трудно читается.
Для удобства пользования мы дадим имя фрагменту кода, сделаем именнованный фрагмент кода. Для этого нужно превратить его в функцию и в нужное время к этой функции обращаться.

Выделяем фрагмент кода для превращения в именнованную функцию
Refactor > Extract > Method (Ctrl + Alt + M)

Фрагмент кода получил собственное имя - там выволняется логин

@BeforeClass
...
login(); // вызов созданного метода (место, в котором к этому фрагменту нужно обратиться)

Почему метода, а не обычной функции?
Внутри метода используется переменная driver, которая является атрибутом объекта типа GroupCreationTests.  

private void login() {
    driver.findElement(By.name(user)).click();
    driver.findElement(By.name(user)).clear();
	
	...
}

Тестовый фрейворк сначала создает объект класса 
Потом выполняет метод 
setUp(){
	инициалируется атрибут объекта driver = new ChromeDriver();
}
Когда вызывается другой метод login() в том же самом объекте, он может этим атрибутом пользоваться.
Также нужно поступить с тестовым методом, выделить из него вспомогательные фукнции.

Первый механизм рефакторинга - это выделение вспомогательных методов.

Следующий шаг

Делаем метод login() параметрализованным, чтобы имя пользователя и пароль передовались внутрь метода в качестве параметров. 

Выделяем значение, которое необходимо превратить в передаваемый параметр
Refactor > Extract > Parameter (Ctrl + Alt + P)
Даем имя username
   

login("admin"); //В точке вызова передается конкретное значение, которое подставляется в эту переменную параметр и используется в методе login
private void login(String username){
	driver.findElement(By.name(user)).sendKeys(username);
}


Тестовый метод создает группу с какими-то свойствами name, header, footer
Значение этих свойств явно прописаны в коде метода
private void fillGroupForm() {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys("test1");
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys("test2");
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys("test3");
}

Было бы более логично передавать их в качестве параметров, чтобы функция fillGroupForm стала универсальной. Ее можно было бы использовать для создания групп с разными параметрами, то есть заполнять форму разными данными. Конкретные значения передавались бы из @Test.

private void fillGroupForm(String name, String header, String footer) {
    driver.findElement(By.name("group_name")).sendKeys(name);
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys(header);
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys(footer);
  }


Создаем новый контакт
У формы контакта много параметров
Как превратить много параметров в мало?

Вместо того, чтобы передавать много отдельных значений, их можно объединить в один объект, который будет иметь много атрибутов. То есть создать вспомогательный класс, который описывает объект типа Group. Объекты этого типа имеют набор атрибутов.

!В метод будет передаваться один объект
ПКМ на fillGroupForm
Refactor > Extract > Parameter Object 

Указываем имя классу, который будет описывать совокупность значений GroupData
Отмечаем те значения, которые должны быть объеденены
Default valuse for parameter -  Leave blank
Рефакторинг закончен

Теперь метод принимает один объект типа GroupData
public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

Это объект 

public class GroupData {
  private final String name; //имеет три атрибута
  private final String header;
  private final String footer;

  //конструктор, который позволяет проинициализировать объект какими то значениями
  public GroupData(String name, String header, String footer) { 
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  //методы, которые возвращают эти атрибуты
  public String getName() {
    return name;
  }

  public String getHeader() {
    return header;
  }

  public String getFooter() {
    return footer;
  }
}  
 


А в @Test при вызове fillGroupForm создается новый объект, атрибуты которого заполняются конкретными значениями


@Test
public void testGroupCreation() throws Exception {
returnToGroupPage("groups");
initGroupCreation("new");
fillGroupForm(new GroupData("test1", "test2", "test3")); //данные для передачи во вспомогательные методы
...
}


Эти значения потом используются в методе fillGroupForm()



private void fillGroupForm(GroupData groupData) {
driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
driver.findElement(By.name("group_header")).sendKeys(groupData.getHeader());
driver.findElement(By.name("group_footer")).sendKeys(groupData.getFooter());
...	
}




	
---
Урок 23. Наследование общий базовый класс

Поместим тесты в разные классы
- создание группы
- удаление группы
Куда поместить вспомогательные функции, чтобы они были доступны в нескольких классах?

Начнем с создания теста для удаления групп. Запишем его рекодером.
Запись теста экспортируем в язык программирования java+testng
Помещаем сгенерированный код в наш пакет
Исправляем имя пакету

Когда создается объект типа GroupDeletionTests, то в этом объекте нельзя вызывать функции, находящиеся в другом классе. Они с этим объектом никак не ассоциированы. 

Наследование - механизм, позволяющий сделать общее пространство для нескольких классов. Туда можно поместить методы и атрибуты. Класс наследник - это тот класс, который расширяет базовый.

Наследование - это процесс, в ходе которого один объект преобретает свойства другого объекта. 

Чтобы воспользоваться механизмом наследования, нужно создать дополнительный класс в который будут помещены общие методы. Класс GroupCreationTests будет расширять этот новый класс. 

public class GroupDeletionTests extends TestBase {}
 
Создадим общий (базовый) класс TestBase 
Поместим туда методы, которые хотим сделать общими
GroupDeletionTests > Refactor > Pull Members Up 
Отмечаем все, кроме test

public class GroupCreationTests extends TestBase { //тестовый класс расширяет (является наследником) базовый класс TestBase 
}
С технической точки зрения это означает, что все методы, которые описаны в базовом классе, становятся членами класса наследника. 
Когда создается объект GroupCreationTests, то с ним ассоциируются все атрибуты и методы, которые находятся и в базовом классе. 

Переходим ко второму тесту GroupDeletionTests.
Для того, чтобы воспользоваться теми методами, которые помещены в класс TestBase нужно написать, что класс GroupDeletionTests расширяет базовый класс TestBase.
Удаляем лишнее, то что уже есть в базовом классе.

Чистим тестовый метод testGroupDeletion()
-удаляем строки, где выполняется вход в систему. Потому что эти действия в методе, с аннотацией @BeforeMethod
К моменту начала выполнения тестового метода все будет уже готово.
-заменяем строки на уже существующие методы
-новые методы преобразуем во вспомогательные функции Ctrl+Alt+M // покабез параметров?


Созданные вспомогательные функции можно перенести в базовый класс. Меняем модификатор прав доступа.
GroupDeletionTests > Refactor > Pull Members Up 


Модификаторы видимости 
public - класс/атрибут/метод доступны откуда угодно
private - доступно из методов, которые находятся в том же самом классе
protected - доступно из методов того же самого класса и из классов наследников

protected void deleteSelectedGroups(String delete) {}

К ним можно обращаться не только из методов, находящихся в том же самом классе, но и из тех методов, которые находятся в классе наследников. 


Code > Reformat Code 
Code > Optimize Inports


Класс наследник содержит то, что описано в нем, а также то что содержится в базовом классе.
Если создается объет, то с ним ассоциированы не только не методы/атрибуты, которые описаны в нем самом, но и те методы/атрибуты, которые описаны в базовом классе.





---
Урок 24. Делегирование вместо наследования

В разных классах могут возникать одинаковые вспомогательные фукнции. Для того, чтобы избежать дублирования кода мы используем
общий базовый класс, в который помещены вспомогательные функции. Они могут использоваться в разных тестовых классах. Но это ведет к новой проблеме. По мере того, как количество тестов увеличивается - количество вспомогательных методов тоже растет. Общий базовый класс становится слишком громоздким.       

1. Большой класс трудно читать и понимать 
2. Потенциальные конфликты при использовании вспомогательных методов несколькими пользователями

Предлагается решение, раскидать вспомогательные функции по дополнительным узкоспециализированным классам. 

1 этап
Из класса TestBase перенесем все вспомогательные фукнции в новый вспомогательный класс ApplicationManager
Вместо наследования будет работать механизм делегирования

2 этап
Новый класс ApplicationManager раздробим на более мелкие узко специализированные классы.


1 этап 
1 шаг
Временно сделаем еще один базовый класс и перенесем функции вверх. А потом передвинем сверху в бок.
После всех преобразований в классе TestBase должно остаться две функции setUp() и tearDown(). 
В этих функциях выполняется много действий, сначала надо вынести эти действия во вспомогательные фукции, которые потом вместе с остальными переедут в новый вспомогательный класс. Тем самым TestBase разгрузится практически полностью.
 

Выделяем содержимое метода setUp() {то что в скобках} Ctrl+Alt+M делаем вспомогательный метод init()
Тоже с tearDown(), новый вспомогательный метод называем stop()

Временно создаем базовый класс ApplicationManager
TestBase expects ApplicationManager

Перемещаем в новый класс все кроме setUp() и tearDown()

И применяем еще один рефактор 
Refactor > Replace Inheritance with Delegations

Заменяем наследование на делегирование. При этом будет создано новое поле (атрибут) назовем его app. Никакие галочки ставить не нужно.

Делегирование - механизм, при котором объекту вспомогательного класса делегируются определенные действия, которые он должен выполнить.


package ru.testjava.addressbook;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
public class TestBase { //исчезла ссылка на расширение класса ApplicationManager, вместо этого
  protected final ApplicationManager app = new ApplicationManager(); // создается ссылка на новый объект типа ApplicationManager
  @BeforeClass(alwaysRun = true)
  public void setUp()  {
    app.init(); /* те вызовы , которые выполнялись в текущем классе (как бы this.init())
    теперь вместо этого вызываются методы, находящиеся в объекте типа ApplicationManager */
  }
  @AfterClass(alwaysRun = true)
  public void tearDown() {
    app.stop();
  }
}

Также произошли изменения в тестах 

package ru.testjava.addressbook;
import org.testng.annotations.Test;
public class GroupCreationTests extends TestBase {
  @Test
  public void testGroupCreation() {
    app.gotoGroupPage("groups"); //просим объект типа ApplicationManager, чтобы он выполнил какое-то действие (обращаемся к нему)
    app.initGroupCreation("new");
    app.fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.submitGroupCreation("submit");
    app.returnToGroupPage("group page");
  }
}

Все вспомогательные фукнции теперь находятся в классе ApplicationManager

Фактически мы разделили код на два слоя
Первый слой - логика тестов. Включает в себя тесты (тестовые классы), которые содержат тестовые методы, сценарии короткие и понятные. Класс Test Base перед каждым тестовым методом инициализирует объект типа ApplicationManager, а после того как метод отработал останавливает его, разрушает.
Второй слой - логика (код) взаимодействия с тестируемой системой.  

Разделим свои физически, разнесем из по разным пакетам

protected - пометка, которая разрешает использовать этот метод не только в классах наслениках, но и в классах находящихся в том же самом пакете.   

Если мы собираемся перенести метод в другой пакет, нужно сделать методы public

ApplicationManager > appmanager
..Tests > tests
GroupData > model

Класс GroupData используется везде. Для того, чтобы обозначить его предназначение поместим его в model.  
Он представляет собой модель какого-то объекта предметной области. 




---

Урок 25. Расщепление и специализация

Раздробим класс ApplicationManager (АМ) на несколько более простых классов и раскидаем по ним вспомогательные функции. 

Для этого используем механизм делегирования. Класс ApplicationManager будет делегировать какие-то действия своим помощникам. 
Создавать помощников мы будем как в предыдущем уроке. Создается временный базовый класс, в который переносятся какие то методы. Потом наследование заменяется на делегирование.

Самое сложное это определить какие вспомогательные классы нам нужны, и какие методы куда переносить. 
Проще всего перенести те методы, которые используются при работе с группами initGroupCreation, initGroupForm, returnToGroupPage 

public class ApplicationManager extends GroupHelper //создаем новый базовый класс
 
Переносим в новый класс методы, связанные с группами 
Заменяем наследование делегированием 
ПКМ ApplicationManager
Refactor > Replace Inheritance With Delegations

Среда сообщает, что после этого действия в тестах возникнут проблемы. Они не смогут получить доступ к перенесенным методам. 
Нужно поставить галочку Generate getter for delegated component**

**для него генерируется вспомогательный метод, дающий доступ к этому полю

Тестовые класса изменились, например GroupCreationTests


  @Test
  public void testGroupCreation() {
	app.gotoGroupPage(); // если АМ может выполнять действие сам
    app.getGroupHelper().gotoGroupPage("groups"); /* для других действий происходит делегирование в два этапа 
	Сначала происходит обращение к АМ, чтобы он дал доступ к помошнику по работе с группами GroupHelper, и уже этому помощнику делегируется выполнение настоящего действия , где происходит взаимодействие с тестируемой системой gotoGroupPage("groups") 
	*/
	}


Есть одно нежелательное изменение в АМ

Ссылка на драйвер переехала в groupHelper 
groupHelper.driver = new WebDriver();

Это неправильно, нужно вернуть ее обратно в ApplicationManager. Потому что она должна быть общей, ей хочет пользоваться  ApplicationManager и другие помощники тоже хотят работать с этой ссылкой.
Вернуть ее обратно средствами рефакторинга не получится. Нужно перенести в ручную.

Отправляемся в GroupHelper 
Копируем от туда ссылку 
WebDriver driver;
Вставляем в АМ, в начало выражения
Метод инициализации init() будет инициализировать именно эту ссылку. Атрибут который находится в классе AM
удаляем префикс groupHelper.
Но тогда возникает вопрос. Как GroupHepler получит эту ссылку на драйвер?
Нужно ее передать в конструктор, но не в private final GroupHelper = new GroupHelper(); а после того как выполнена инициализация (после  строк с атрибутом driver.)
То естьGroupHeldep должен конструироваться внутри метода init()
Ссылка на драйвер должна передаваться в качества параметра в контструктор
groupHelper = new GroupHelper(driver);
И этот конструктор необходимо создать Alt+Enter

  public GroupHelper(WebDriver driver) { //то значение, которое передано в качестве параметра конструктора
    this.driver = driver; //необходимо присвоить в атрибут (поле) класса GroupHelper
  }
Тем самым класс GroupHelper получит доступ к драйверу, который инициализирован в AM и передан помощнику. 
  
Но остались проблемы в АМ


private final GroupHelper groupHelper = new GroupHelder(); //не нужна инициализация = new GroupHelder()
private final GroupHelper groupHelper; //его нужно только декларировать

final - пометка означает, что в это можно присвоить значение только один раз. Нас это не устраивает потому что метод init() может вызываться многократно. Убираем пометку. 

private GroupHelper groupHelper;

Остались проблемы в других вспомогательных методах. Там тоже используется ссылка, которая находится внутри groupHelper. Нужно от этого избавиться. Чтобы определить где именно есть эта нежелательная ссылка, нужно в GroupHelper объявить атрибут, в котором он хранит свою личную ссылку на драйвер, private

> GroupHelper.java

private WebDriver driver;

В АМ будут выделены те кто хочет получить доступ к атрибуту, находящимуся внутри GroupHelper. Удаляем ссылки.
Пусть они пользуются ссылкой, которая находится внтури AM.


Для закрепления проделаем тоже самое с методом gotoGroupPage

Вынесем его во вспомогательный класс - NavigationHelper

public class ApplicationManager extends NavigationHelper; // создаем базовый класс  Alt+Enter

переносим в него нужную функцию gotoGroupPage + driver

Заменяем наследование на делегирование


Обратно переносим ссылку на драйвер

чтобы NavigationHelper получил доступ к этой ссылке передаем ее в качестве параметра в конструктор

navigationHelper = new navigationHelper(driver);

просим среду разработки чтобы она создала этот конструктор 

присваемваем переданное значение 

public class NavigationHelper {
  private WebDriver driver; //для того чтобы к нему никто не мог получить доступ  

  public NavigationHelper(WebDriver driver) {
    this.driver = driver; //присваеваем переданное значение в поле 
  }

возвращаемся в сломавшийся и подкрашенный АМ

удаляем все неправильные использования драйвера

удаляем модификатор final и инициализацию = new navigationHelper(); //потому что эта инициализация выполняется в методе init() после создания драйвера 

navigationHelper = new NavigationHelper(driver); 



Переносим метод login() во вспомогательный класс другим способом, без рефакторирга


appmanager > Create New Class > SessionHelper


сделаем в АМ ссылку на SessionHelper


private sessionHelper sessionHelper;


инициализируем его в методе init()

sessionHelper = new SessionHelper(driver); //поскольку такого конструктора нет, сделаем его

public class SessionHelper {
  private WebDriver driver;

  public SessionHelper(WebDriver driver) { //driver Alt+Enter > присвоить значение параметра конструктора в какое-то поле 
    this.driver = driver; //поле создается автоматически 
  }

Вырезаем метод login() и вставляем в класс SessionHelper

Добавить все необходимые импорты, поменять методы на public 

Внутри AM обращаться к нему через помощникам

sessionHelper.login("admin", "secret") //вызывается метод в помощнике, ему делиируются какие-то действия

---
Урок 26 Наследование общий базовый класс

Для того чтобы новые тесты было проще добавлять, и без использования рекодера, нужно доработать код классов помощников

Код заполнения поля ввода 

driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());

Alt+Ctrl+M

public void fillGroupForm(GroupData groupData) {
    type(groupData); 
}
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

В результате рефакторинга параметр у этого метода получился не очень удачный. Логичнее в этот метод передавать 2 других параметра: локатор элемента, текст который нужноввести в поля ввода. 

было
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

стало
 private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }
  
  
При этом среда разработки сама догадалась, что параметр GroupData больше не используется и автоматически его удалила. Кроме того, она заметила такие места, где повторяется фрагмент кода и предложила там тоже сделать замену на вызов нового созданного метода. 



  public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

  private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }

В результате всех преобразований дублирование кода сократилось.

Тоже с методом клик

 public void submitGroupCreation() {
    driver.findElement(By.name("submit")).click();
  }
  
Выделяем кусок кода, который хотим выделить во вспомогательный метод
Alt+Ctrl+M

  public void submitGroupCreation() {
    click();
  }
  }}}

  
Делаем его параметрализованным 

public void submitGroupCreation() {
	click(By.name("submit"));
}
private void click(By locator) {
	driver.findElement(locator).click();
}

Среда замечает, что есть 5 похожим фрагментов и их тоже стоит заменить

Тоже самое нужно проделать в другом классе помощнике - SessionHelper
Но мы уже сделали подходящие методы, необходимо только предоставить возможность использовать их.

Здесь нам поможет механизм наследования, который даст возможность предоставить общее пространство обобществить какие то методы между двумя классами. Возвращаемся в GroupHelper, делаем базовый класс и помещаем в него методы click и type + ссылка на драйвер

GroupHelper extends HelperBase; //базовый класс для всех помощников 

Раньше в контсрукторе просто присваивалось значение в поле класса, а сейчас появился вызов странного метода 
  public GroupHelper(WebDriver driver) {
    super(driver); //это обращение к конструктору базового класса
  }
В базовом классе создан конструктор, который принимает параметр в качестве ссылке на драйвер
  public HelperBase(WebDriver driver) {
    this.driver = driver;
  }



public void login(String username, String password) {
    driver.findElement(By.name("user")).click();
    driver.findElement(By.name("user")).clear();
    driver.findElement(By.name("user")).sendKeys(username);
    driver.findElement(By.name("pass")).clear();
    driver.findElement(By.name("pass")).sendKeys(password);
    driver.findElement(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]")).click();
  }


  public void login(String username, String password) {
    type(By.name("user"), username);
    type(By.name("pass"), password);
    click(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]"));
  }


Метод может пользоваться теми данными, которые храняться в объекте этого класса.

---

Урок 27. Новый тест без использования рекодера

Добавим тест в котором проверяется возможность модификации какой то существующей группы


package ru.testjava.addressbook.tests;

import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupModificationTests extends TestBase{

  GroupModificationTests() {

  }

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    app.getGroupHelper().selectGroup();
    app.getGroupHelper().initGroupModification(); //новый
    app.getGroupHelper().fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.getGroupHelper().submitGroupModification();//новый
    app.getGroupHelper().returnToGroupPage();
  }
}

Новые методы создаем в классе GroupHelper

---
Занятие 3 Управление потоком выполнения кода, ветвление
Урок 28. Блок if / else
Решение квадратного уравнения
D = b^2 - 4ac

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения


double d = b*b - 4*a*c; 

Будем анализировать дескреминант, чтобы присвоить значение в атрибут n

 

if (d > 0) { //если условие в скобках справедливо, то выполняется блок в фигурных скобках
  n = 2;
} else { //если условие в скобках не справедливо
  if (d == 0) { //вложенная конструкция if
	n = 1;
  } else {
	n = 0;
  }
}


---
Урок 29. Проверки различные формы
Конструкция if, служащая для проверки условий может принимать три формы

Полная форма с блоком else
Сокращеная форма без блока else
Свернутая форма - альтернативное представление для нескольких вложенных конструкций if

Если в конструкции if внутри фигурных скобок находится одно действие, то фигурные скобки можно не ставить.

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения

Тройных развилок нет, поэтому это реализуется через вложенные конструкции 


Визульно равноправные, а не вложенные. Это свернутая форма которая по сути эквивалентна вложенной форме.
if (d > 0) { 
  n = 2;
} else if (d == 0) { 
n = 1;
} else {
n = 0;
}

Если условия взаимоисключающие, то можно записать по другому. Но тогда будут выполняться все проверки, то есть будут лишнии проверки. При наличии блока else лишних проверок нет.

if (d > 0) { 
  n = 2;
} 
  
if (d == 0) { 
n = 1;
} 

if {d < 0) {
n = 0;
}
}

Внутри блока else находится одна единственная конструкция if
else { 
  if (b == 0) {
	if (c == 0) {
	  n = -1;
	} else {
	  n = 0;
	}
  } else {
	n = 1;
  }

}

стало
 if (a != 0) { //алгоритм решения квадратного уравнения
      if (d > 0) { //используется конструкция типа свертка* 
        n = 2;
      } else if (d == 0) {
        n = 1;
      } else {
        n = 0;
      }

    } else if (b != 0) { //алгоритм решения линейного, вырожденного уравнения //используется конструкция типа свертка
      n = 1;

    } else if (c != 0) {
      n = 0;

    } else {
      n = -1;
    }

С логической точки зрения это разные свертки 
в первой конструкции равноправные, взаимоисключающие варианты развития событий D < 0 или D = 0 или D > 0. Это три разные ветки.
во второй конструкции остается каскад проверок - они по смыслу вложенные, но написаны в свернутой форме.

При написании кода пробуйте эксперементируйте, меняйте проверяемые условия, переставляйте блоки местами, стараясь добиться максимальной понятности того, что проверяется и когда что должно выполняться.



---
Урок 30. Браузер на выбор

public class ApplicationManager {
  private WebDriver driver; //тип переменной интерфейс WebDriver - это проявление механизма наследования
 
public void init() {
    System.setProperty("webdriver.chrome.driver", "c:\\Tools\\chromedriver.exe");
    driver = new ChromeDriver(); //создается экземпляр класса ChromeDriver

	}	
	
В интерфейсе методы только декларируются, объявляются имена и типы параметров возвращаемого значения. А конкретная реализация этих методов должна быть написана в классе наследнике.	
Разные классы могут реализовывать один и тот же интерфейс, но по разному 	
	
Выбор типа браузера нужно указать при инициализации в TestBase. Поэтому тип браузера нужно следать параметром.

Способ 1
Можно сделать параметром метода init()	
	
Тогда в TestBase при вызове этого метода нужно указать тип браузера
@BeforeMethod
public void setUp()
app.init(CHROME)

Способ 2
Можно сделать тип бразузера параметром конструктора AM

public class TestBase {
protected final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);
...
}

Создаем конструктор
public ApplicationManager(String browser) {

    this.browser = browser; //значение параметра сохраняем в поле
  }
	
Убираем локальную переменную String browser = BrowserType.CHROME; вместо нее будет использоваться атрибут объекта АМ, тот который был установлен при конструировании этого объекта.
public void init() {
    String browser = BrowserType.CHROME;
    if (browser == BrowserType.CHROME) {	
	}	

public void init() {
    if (browser == BrowserType.CHROME) {
      driver = new ChromeDriver(); 
    } else if (browser == BrowserType.FIREFOX) {
      driver = new FirefoxDriver();
    } else if (browser == BrowserType.IE) {
      driver = new InternetExplorerDriver();
    }
}

Драйверы помещены в папку c:\Tools\
В переменную окружения PATH добавлен путь c:\Tools\ 
	
http://software-testing.ru/forum/index.php?/topic/33657-udaetsia-podkliuchit-chromedriver-tolko-cherez-systemsetproperty/?p=154278

1) Можно положить исполняемый файл chromedriver в одну из директорий, которые упоминаются в переменной окружения PATH. Если Вы попытались это сделать, но не работает -- вероятно, неправильно настроили переменную, либо не перезапустили приложение, которое должно увидеть изменённое значение переменной. В операционной системе Windows можно просто положить исполняемый файл в c:\windows\system32, эта директория по умолчанию включена в PATH (если только вы её оттуда сами не удалили)

 

2) Можно положить исполняемый файл chromedriver в текущую директорию. То есть в ту директорию, которая будет текущей, когда вы будете запускать тесты. Скорее всего это корневая директория проекта.



---
Урок 31. Сравнение Equals	
	
Знак сравнения == нужно использовать только для чисел (двойной знак равенства)
Во всех остальных случаях, для объектов нужно использовать метод Equals	
	
Переменная - ссылка на объект
Когда вы объявляете переменную ссылочного типа, на самом деле вы создаете ссылку на объект данного типа. Рассмотрим следующий код для объявления переменной типа int:
int x;
x = 10;
В этом примере переменная x имеет тип int и Java инициализирует её как 0. Когда вы присвоите переменной значение 10 (вторая строка), это значение сохранится в ячейке памяти, на которую ссылается x.


Когда мы присваивали во вторую переменную значение, которое хранится в первой переменной, новый объект не создавался. 
Скопировалась ссылка на уже существующий объект
String s1 = "firefox";
String s2 = s1; //есть 2 переменных ссылающееся на один и тот же объект


public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = s1; 

System.out.println(s1 == s2); //true сравнение ссылок, проверяется идентичность объектов 
System.out.println(s1.equals(s2)); //true сравнение содержимого объектов
}
}
	
	
public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = new String(s1);  // в памяти возник другой объект

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}	
	
В памяти возник другой объект, который логически содержит такой же текст, но физически это другой объект. Он хранится в другом месте в памяти, имеет другой адрес.

Когда сравниваются две ссылки s1 == s2 результат отрицательный.
Метод equals() сравнивает не ссылки, а содержимое объектов. Это логические сравнение, а не физическое. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = "firefox"; // не происходит копирование ссылки. В переменную s2 присвается значение, совершенно не зависимо от того что было раньше присвоено в переменную s1  

System.out.println(s1 == s2); //true java считает что переменные ссылаются на один и тот же объект 
System.out.println(s1.equals(s2)); //true
}}

Компилятор оптимизирует код. Все переменные, которые ссылаются на одну и туже литеральную строку, будут ссылаться на один и тотже физический объект. 
String s2 = "fire"+"fox";
System.out.println(s1 == s2); //true

Компилятор догадывается, что это один и тотже объект. На этапе компиляции склеет эти части, увидит что получился тотже самый объект, который ранее использовался.

Но на этапе компиляции вычисляются не любые выражения. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox" + "2.0";
String s2 = "firefox" + Math.sqrt(4.0); //на этапе выполнения будут созданы два независимых объекта

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}


---
Урок 32. Дефолтные значения в полях

Рассмотрим пример использования конструкции if для оптимизации ввода данных в текстовые поля.

Задание
Создать группу, с именем test1, а остальные поля пусть будут заполнены значениями по умолчанию. Не указывать в тесте явно. 

Можно использовать значение null. Когда в переменную присвается значение null , это означает, что она ни на какой объект не ссылается.


protected void type(By locator, String text) {
	click(locator);
	driver.findElement(locator).clear(); 
	driver.findElement(locator).sendKeys(text); //падает, предварительно очистив поле ввода 
}

Задание 
Если в качестве текста передано значение null, то это поле ввода вообще не нужно трогать.

было  	
  protected void type(By locator, String text) {
    click(locator);
    if (text == null) { // нужно проверить храниться ли в переменной ссылка на какой то объект (физ сравнение)

    } else {
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }	
}	
	
стало
if (text != null) { 
  driver.findElement(locator).clear();
  driver.findElement(locator).sendKeys(text);
}	
}
}


---
Урок 33. Ленивое заполнение полей

Для того чтобы оставить поле неизменным, можно передать в качестве значение null. Это будет означать, что мы хотим оставить в поле то значение, которое в поле уже введено.


Если то значение, которое мы передали совпадает с тем, которое уже введено в поле ввода. Есть смысл провести проверку. 

Задание
Если в поле уже введено значение, то с этим полем делать ничего не нужно



По правилам web приложений тот текст которым видим в поле ввода, является значением атрибута value

А обычный метод getText() для полей ввода всегда возвращает пустую строчку. Метод getText() используется для всех остальных элементов, кроме полей ввода. 


protected void type(By locator, String text) {
click(locator);
if (text != null) {
  String existingText = driver.findElement(locator).getAttribute("value"); //извлекаем из поля то значение, которое храниться
  if (! text.equals(existingText)) { //если неверно что текст совпадает с уже существующим текстом
	driver.findElement(locator).clear();
	driver.findElement(locator).sendKeys(text);}
  }
} 

Если нужно чтобы тесты работали быстро, есть большие поля ввода куда вводится длинный текст, тогда сделать такую доп проверку не помешает. 
Selenium вводит текст по символьно. 

---
Урок 34. Исключения. Перехват и обработка

Исключение - это информация выводящаяся на консоль при падении программы. Информация о том, где произошел сбой, в каком файле, строчке.

Конструкция if часто используется чтобы предотвратить возникновение исключения.

В нормальном состоянии выполнение метода завершается либо от дошел до самого конца }, которая ограничивает тело метода. Либо если в коде встретилось слово return.

Стек вызовов - цепочка методов, которые вызывают друг друга

Читать удобно снизу вверх. 

main главная функция, которая запускается когда мы стартуем какую нибудб программу.
В последнем методе, который упоминается в стеке вызовов произошла ошибка. 
Причем ошибка настолько серьезная, что дальнейшая работа программы стала невозможной. 
Несмотря на то, что в последнем методе нет слово return, java должная прекратить выполнение этого метода. 
Java прекращает выполнение этого метода аварийно. То есть вышестоящий метод получает сообщение о том, что вызванный метод завершился аварийно. 
И вместе с этим сообщением получает специальный объект, который содержит информацию о возникшей проблеме. Этот объект называется исключением.
А преждевременный возврат из функции называется выбросом исключением. 

Последняя функция выбросила исключение и при этом ее работа прервалась.
Предпоследняя функция, которая обращалась к проблемной , тоже не может продолжать, поэтому она пробрасывает исключение дальше. 
В свою очередь предшествующий метод тоже аварийно прерывается, и пробрасывает ислючение еще выше 
И так ислючение постепенно летит вверх пока не долетает до места где оно будет перехвачено.

В тестовом фрейфорке есть механизм, который позволяет эту цепочку аварийных прерываний остановить, исключение перехватить, проанализировать и обработать.
Тестовый фреймворк ловит исключение, записывает в отчет, выводит на консоль, и продолжает выполнять следующие тесты. 
 
Синие функции - те что в нашем проекте	
Серые - какие то библиотеки	(selenium)

Код серых библиотек нам не доступен, мы ее исправить не можем
Поэтому если внутри этой библиотеки возникает ислючение, мы можем:
- попытаться это предотвратить, написав какие то проверки и не допустить обращение к методу sendKeys() с плохими данными;
- обратиться к фукнкции sendKeys и попытаться перехватить те исключения, которые могут быть выброшены во время ее работы (устранить последствия).

Метод isAlertPresent() позволяет проверить наличие диалогового окна, которое иногда возникает на странице web приложений.
Библиотека selenium не предлагает способа проверить наличие / отсутствие этого диалогового окна
	
	
public boolean isAlertPresent() {
  try { //пытаемся выполнить блок кода
	driver.switchTo().alert(); //если окно есть, то успешно переключимся. все Ок
	return true; //а если не получилось и возникло исключение
  } catch (NoAlertPresentException e) { // если окна нет, то возникает исключения типа NoAlertPresentException. Перехватываем его и тоже все Ок. другого типа не перехватим.
	return false; 
  }
}	

Предотвратить появление ислючения нельзя. Вынуждены устранять последствия. 	
Это аварийное прерывание не будет распостраняться дальше. 
Те функции которые обращаются к isAlertPresent(), вместо прерывания и исключения получат нормальное возвращаемое значение true / false
	
Типы исключений бывают разные:	
- при выполнении недопустимых арифметических действий, поделить на 0
- преобразование строки в число, если при этом строка не может быть преобразована в число
- использование переменной, которая не проинициализирована NullPointerException
- при поиске несуществующего элемента 




---
Урок  35. Почти одикановые формы

Имеется две почти одинаковые формы. В форме для редактирования контакта отсутствует поле выбора группы с выподающим списком.

В обоих тестах CreateContact и ContactModification используется метод fillContactForm()
Добавим в него функционал для работы с группами

Во первых нужно добавить поле String group в класс ContactData, который хранит информацию о контакте

Добавляем параметр в конструктор, сохраняем его значение в какое то поле 

Делаем для этого поля метод getter, которое позволяет получить значение поля. 


public class ContactData {
	...
    private String group;

  public ContactData(...String group) {
	...
    this.group = group;
  }

  ...
  public String getGroup() {
    return group;
  }
}

Указываем существущее значение параметра group в тестах 
На странице приложения Edit Group нет поля group, поэтому в тесте ContactModification указываем null

На этом доработка тестов завершена, теперь доработаем метод который заполняет форму.

Как выбрать элемент из выпадающего списка?

Используем вспомогательный класс 
new Select(driver.findElement(By.name("new_group"))) //в качестве параметра указан элемент, который найден на странице приложения - листбокс со списком групп

Теперь в этом объекте типа select надо вызвать один из методов
new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());

Но при попытке запустить тест ContactModification в этой строчке возникнет исключение, потому что драйвер не сможет найти элемент с таким локатором.

Для того, чтобы предотвратить это исключение, можно сделать проверку

if (isElementPresent(By.name("new_group"))) { //задаем локатор в качестве параметра
    new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup()); //выбор пункта из выпадающего списка
    } 
//в противном случае, если такого элемента нет, то делать ничего не нужно - блока else не будет

Создаем метод isElementPresent()

private boolean isElementPresent(By locator) { //параметру даем общее имя, для проверки произвольного локатора
	return  ; //тут нельзя предотвратить возникновение исключения 
}
  
Драйвер селениум не предоставляет возможности узнать заранее есть ли на странице элемент или нет.
Единственное что можно сделать это его поискать

private boolean isElementPresent(By locator) {
	driver.findElement(locator); //поиск элемента
}

Если элемент есть, то он успешно найдется. 
Если элемента нет, то будет выбрашено исключение.
Поэтому нужно обернуть попытку поиска элементра в блок try

 protected boolean isElementPresent(By locator) {
    try {
    driver.findElement(locator);
    return true;
    } catch (NoSuchElementException ex) {
    return false;
    }

 }

Рассмотрим ситуацию, когда на форме создания контакта разработчики потеряли это поле. 

if (isElementPresent(By.name("new_group"))) { //селениум должен заполнить это поле, если его нет то выпадет исключение
    new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());


Чтобы эту проблему устранить, для метода fillContactForm() сделаем доп параметр, в который будет передаваться информация о том, что мы сейчас делаем - создаем или модифицируем контакт.
Это "булевский" параметр , где true - означает форма создания, там должен быть элемент для выбора группы, false - означает что контакт модифицируется, элемента не должно быть.

public void fillContactForm(ContactData contactData, boolean creation) { 
	type(By.name("firstname"), contactData.getFirstname());
	...
	
}

Тесты тоже придется поменять 

public void testContactCreation() {
...
app.getContactHelper().fillContactForm(new ContactData(...), true);
}

public void testContactModification() {
...
app.getContactHelper().fillContactForm(new ContactData(...), false);
}

А теперь поменяем метод fillContactForm() в ContactHelper //самое важное **

Вместо того, чтобы анализировать есть элемент на странице или его нет и в зависимости от этого принимать какие то решения, используем следующую конструкцию  

if (creation) { //если это форма создания, значит элемент должен быть, поэтому нужно выбирать элемент из выпадающего списка
	new Select(driver.findElement(By.name("new_group"))).selectByVisibleText(contactData.getGroup());
} //если вдруг этого элемента нет, то тест упадет - и так должно быть
else { //а иначе , это форма модификации, в этом случае элемента быть не должно
  Assert.assertFalse(isElementPresent(By.name("new_group"))); //проверка того что элемента быть не должно 
}
} 

Если вдруг на форме модицикации контакта этот элемент появился то это баг, тест должен упасть

Запускаем оба теста
В одном случае выбирается группа из выпадающего списка
В другом - проверяется отсутствие этого выпадающего списка


В тесте модификации контакта происходит задержка
driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS); //после инициализации браузера устанавливается значение тайм аута 

Когда селениум пытается найти какой то элемент, он думает что из за медленной загрузки страницы элемент не успел появится. 
При проверки отсутствия элементов тайм аут мешает. Да, он помогает уменьшить нестабильность тестов. Драйвер автоматически ждем пока страница загрузится, элементы появятся. 
Когда нужно убедится, что опредленнные элементы отсутствуют, можно тай аут отключить =0. 

Теперь проверка отсутствия элементов выполняется мнгновенно. Если где то есть элементы, которые появятся не сразу, то могут возникнуть проблемы - нестабильность при выполнении тестов. Когда возникнут проблемы, тогда будем их решать. Перед поиском конкретного элемента можно увелить тайм аут, а после того как он найден сбросить обратно в 0.

** самое важное - мы сделали метод, который позволяет выполнять проверку наличия или отсутствия элементов. И пользуем этот методом для того чтобы заполнять форму, которая то содержит, то не содержит элемент.
При этом мы не просто ориентируемя на наличие отсутствие элемента. 
Тесты предсказывают должен быть этот элемент или нет.
При создании контакта список должен быть, поэтому мы пытаемся из него выбрать. 
А при модификации контакта такого списка не должно быть вообще, поэтому мы явно контролируем его отсутствие. А если он вдруг появится, то тесты упадут - будет обнаружен баг


---
Урок 36. Ленивые действия

Оптимизированы переходы между страницами. Полезно когда веб приложение работает медленно, если проверка занимает меньше времени чем действие.  

Перед тем как перейти на страницу или кликнуть меню, имеет смысл сделать проверку. А может быть уже находимся на нужной странице и не надо никуда переходить. 

Эта оптимизация будет реализована в классе navigationHelper

Добавим проверки перед каждым кликом / переходом . Какой критерий выбрать? 

Можно проверять наличие каких то характерных элементов. Например, использовать комбинированный критерий - наличие заголовка с текстом Groups и кнопки для создания новой группы New groups. Такой критерий будет уникальным для конкретной страницы.

Cначала проверяем наличие заголовка
После того как убедились в наличии элемента, можно проверять текст
Для написания составного условия используем логические операции && (И / двойной амперсанд) || (или)


public void gotoGroupPage() {
if (isElementPresent(By.tagName("h1"))
		&& driver.findElement(By.tagName("h1")).getText().equals("Groups")
		&& isElementPresent(By.tagName("new"))) { 
		//ничего делать не надо, мы уже находимся на нужно странице

} else {
  click(By.linkText("groups"));
}
}

Но так писать не принято, чтобы основной блок if был пустым. Можно это условие развернуть, превратить в противоположное

public void gotoGroupPage() {
if (! isElementPresent(By.tagName("h1"))
		|| ! driver.findElement(By.tagName("h1")).getText().equals("Groups")
		|| ! isElementPresent(By.tagName("new"))) { 
		click(By.linkText("groups"));

}
} 


public void gotoGroupPage() {
if (isElementPresent(By.tagName("h1"))
		&& driver.findElement(By.tagName("h1")).getText().equals("Groups")
		&& isElementPresent(By.tagName("new"))) { 
		return; //сразу же выполнить выход из этого метода, не нужно дальше двигаться

} 
  click(By.linkText("groups")); //а иначе мы проскакиваем блок if и выполняем клик 
  
}


Таким образом выполняется нужная функциональность, и требования стиля тоже соблюдены.



---
Урок 37. Предусловия. Проверка и обеспечение.

Использование контструкции if для проверки предусловий перед выполнением теста.

Вопрос функциональности: могут ли тесты вообще выполнить свою задачу?

Рассмотрим тест модификации группы. Если групп для модификации нет, то тест упадет

Чтобы исправить проблему, нужно добавить в тест проверку предусловия.
Перед модификацией группы, нужно убедится что она есть.
Кроме того, нужно отреагировать на ее отсутствие.

1 способ
Тест можно пропустить 

2 способ
Можно сделать попытку исправить ситуацию
Сначала создать группу, а потом продолжить выполнение теста, как будто она существовала с самого начала

Предусловие можно не только проверять, но и обеспечивать их выполнение.

Добавляем проверку предусловия  
@Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {     //помещаем новый метод в GroupHelper, чтобы сохранить имеющуюся архитектуру
    //копировать фрагмент кода не будем, создадим вспомогательный метод 
    }
    ...
  } 

Вставлять большой фрагмент кода из метода GroupCreationTests не будем, потому что возникает дублирование.
Как только копируем большой фрагмент кода из одного места в другое, значит должно возникнуть подозрение что то идет не так. Нужно создать вспомогательный метод, который поместим в GroupHelper

if (! app.getGroupHelper().isThereAGroup()) {     //помещаем новый метод в GroupHelper, чтобы сохранить имеющуюся архитектуру
      app.getGroupHelper().createGroup(new GroupData("test1", null, null)); //параметр - группа со всеми ее атрибутами
    }


public class GroupHelper extends HelperBase {
  public void createGroup(GroupData group) { //параметру дали любое имя, значение задается в тесте
    initGroupCreation(); //маленькие вспомогательные методы
    fillGroupForm(group);
    submitGroupCreation();
    returnToGroupPage();
  }
}

Возникает вопрос: а нужно ли оставлять маленькие вспомогательные методы?

Во первых наличие этих вспомогательных методов позволяет писать метод CreateGroup, так что он легко читается  - понятно из каких шагов состоит метод создания группы

Во вторых, может существовать такой тест, в котором этот сценарий до конца не доходит. Например, при проверки отмены создания группы. Тогда, сценарий можно легко изменить.

Реализуем метод isThereAGroup()

  public boolean isThereAGroup() { //будет проверяться наличие элемента, который пытаемся выбирать в методе SelectGroup (соответствует включенному чекбоксу)
    return isElementPresent(By.name("selected[]"));
  }


Теперь тест testGroupDeletion выполняется правильно, вне зависимости от того есть ли группа в начале выполнения теста или нет. 


---
Занятие 4. Коллекции и циклы  

Урок 38. Циклы. Многократные повторения похожих действий

Циклы - конструкции, предназначенные для повторения похожих действий
Коллекции - наборы однотипных элементов

Циклы используются, чтобы сформировать или перебрать коллекцию. То есть выполнить однинаковые действия со всеми элементами некоторого набора. 

Конструкция, позволяющая описать два типа циклов 
выполнить действие определенное количество раз
выполнять действия пока не удовлетворится какое то условие окончания

Задача об определении простоты целого числа
Простое число делится только на себя и 1 
(2, 3, 5, 7, 11, ...)
Для проверки простоты числа нужно попытаться поделить его на все числа, которые меньше него. Если среди них найдется делитель, значит число не простое. Если делетелей нет, значит простое. 

Нужно число n делить последовательно на разные числа. Выполнять это действие многократно. Сколько раз? 
В данном случае нам известно сколько чисел нужно попробовать.
Нужно проверить все числа от 2 до n-1   

Для описания таких циклов используется конструкция for ()
Цикл for () обычно использует переменную счетчик, которая описывается внутри круглых скобок. Она не только декларируется, но и описывает все что с этим счетчиком происходит.

for (инициализация; место остановки; то что происходит с переменной счетчика на кажной итерации цикла) {действия которые должны происходить на каждой итерации}

  
i = i + 1
i += 1 		сокращенная запись, увеличение переменной на заданное значение
i++ 		операция инкремент, увеличение переменной на 1 
% операция получения остатка от деления двух чисел  
int a = 33;
int b = 5;
int c = a % b;  // 3
int d = 22 % 4; // 2 (22 - 4*5 = 2)


	
public class Primes {

  public static boolean isPrime(int n) { 
    for (int i = 2; i < n ; i++) { // i = 2 потому что ищем делитель отличный от 1 и n
      if (n % i == 0) { //число делится без остатка
      return false; //не простое
      }
    }
    return true; //простое
  }
}

Напишим тест

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class PrimeTests {

  @Test
  public void testPrimes() {
    Assert.assertTrue(Primes.isPrime(Integer.MAX_VALUE)); //Integer.MAX_VALUE простое число
  }

  @Test
  public void testNonPrimes() {
    Assert.assertFalse(Primes.isPrime(Integer.MAX_VALUE-2)); //Integer.MAX_VALUE - 2 не простое число
  }
}




//цикл for может быть переписан в другой вид (эквивалентная форма)

public static boolean isPrimeWhile(int n) {
int i = 2;
while (i < n) { //while (до тех пор пока) условие окончания цикла 
  if (n % i == 0) { //можно избавится от констукции if, ту проверку которая выполняется включить в условие окончания цикла
	return false;
  }
  i++; //на каждой итерации цикла увеличиваем переменную на 1, выполнять эти действия будем пока i = n
}
return true; //если дошли до конца цикла i = n, значит делителя не найдено и возвращаем true
}

 
public static boolean isPrimeWhile(int n) {
int i = 2;
while (i < n && n % i != 0) { //тогда продолжаем искать делитель дальше
  i++; 
}
return i == n; //**

} 

**
Цикл завершится когда i = n, либо будет найдет какой то делитель. Значит после окончания цикла нужно проверить чему равно i
Если i == n, то ниодного делителя не найдено, n простое число. 
Если i != n, значит цикл закончился раньше, чем достигнуто максимальное значение и делитель найден. n не простое число. 	


Рассмотрим разные модификации фукнкции Prime()

int используется для представления 32бит чисел
long это 64бит числа

Две функции имеют одинаковые имена isPrime(), но разные типы переменных int и long. Конфликта не возникает, потому что java разбирается в типах данных.

Напишем тест 

@Test(enabled = false) //отключение теста
public void testPrimesLong() {
  long n = Integer.MAX_VALUE; //значение переменной будет преобразовано в тип long
Assert.assertTrue(Primes.isPrime(n));
}

В результате, время выполнения теста увеличилось в 3 раза

Теперь сократим количество итераций в 2 раза, время выполнения теста isPrime уменьшилось в 2 раза

public static boolean isPrimeFast(int n) {
for (int i = 2; i < n / 2; i++) { // делителя больше чем n / 2 не может быть. На что нужно умножить делитель, чтобы получилось n? Любой делитель числа меньше чем его половина (n / 2).
  if (n % i == 0) { 
	return false;
  }
}
return true;
}


@Test
public void testPrimesFast() {
Assert.assertTrue(Primes.isPrimeFast(Integer.MAX_VALUE));
}

Предположим что число n имеет делитель, это означает что у него есть второй делитель. То есть n представляется как произведение двух чисел. 
n = a * b 
(а || b) <= sqrt(n) //не могут быть оба делителя > чем корень из n, иначе их произведение > n

Поэтому проверять можно до Math.sqrt(n)   

Простой, но медленный метод проверки простоты заданного числа n известен как перебор делителей. Он состоит из проверки того, является ли n кратным целому числу от 2 до квадратного корня из n.

public static boolean isPrime2Fast(int n) {
    int m = (int) Math.sqrt(n); // значение корня явно приведем к целому числу, посколько корень может быть не целым
    for (int i = 2; i < m / 2; i++) {
      if (n % i == 0) {
        return false;
      }
    }
    return true;
  }

Когда используются циклы, нужно следить чтобы 
- количество повторений было неслишким большим 
- если итераций много, то нужно стремится выполнять действия на каждой итерации как можно быстрее


---
Урок 39. Коллекции наборы элементов

В уроке пойдет речь о коллекциях и специальных разновидностей циклов, которые предназначены для перебора всех элементов коллекций

Создадим новый класс Collections

Массив -  специальная конструкция на уровне языка, которая описывает коллекции 
Например, массивом является параметр функции main (String[] args). 
В нем передается какой то набор строк, те самые строчки которые указаны как параметры запуска в командной строке 

Сделаем массив 

public class Collections {

  public static void main(String[] args) {
    String[] langs = new String[4]; //объявлена переменная типа массив строк
  }
}

На то что переменная является массивом указывают первые [] в декларации (средство для работы с массивами)
Перед [] указывается тип элементов, которые могут хранится в этом массиве
При конструировании массива в квадратных скобках указывается его размер
new String[4] - созданный массив может хранить 4 элемента


public class Collections {

  public static void main(String[] args) {
    String[] langs = new String[4];
	//ниже происходит обращение к элементам массива в формате [порядковый_номер(индекс)]=значение 
    langs[0] = "Java"; //задегларировали и заполнили массив какими то значениями 
    langs[1] = "C#"; 
    langs[2] = "Python";
    langs[3] = "PHP";
  
  
  }
}

Эквивалетная запись элементов массива в одну строчку

public class Collections {

  public static void main(String[] args) {
    String[] langs = {"Java", "C#", "Python", "PHP"}; //Cоздается массив, который состоит из 4 элементов и заполняется какими то значениями
  
  }
} 

Устроим итерацию по элементам этого массива
 
public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 

  for (int i = 0; i <langs.length; i++){//у массива атрибут length 
	System.out.println("Я хочу выучить " + langs[i]); //выбираем из массива элемент с заданным индексом
  }
}
}

Специально для коллекций есть конструкция цикла, которая предназначена для перебора элементов коллекции 


public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 

  for (String l : langs){//теперь переменная l уже не индекс, это ссылка на элемент массива
	System.out.println("Я хочу выучить " + l); 
  }
}
}

Переменная l последовательно указывает на все элементы этой коллекции
Искусственная переменная счетчик не создается, она не нужна. Удобно иметь указатель на элемент массива.
Для каждого элемента l, входящего в коллекцию (массив) langs, выполнить какое то действие. 


Массив - это конструкция, которая поддерживается на уровне языка ([] особый синтаксис для описания массивов)
В Java есть другой способ работы с коллекциями, при помощи спец классов. Классы находятся в пакете java util	
	
https://docs.oracle.com/javase/7/docs/api/index.html?java/utl/Collections.html
	
В основании иерархии находится интерфейс Collection, который описывает произвольные коллекции.
Пример типов коллекций, которые расширяют интерфейс Collection

Интерфейс List (список)
Список предназначен для представления упорядоченных коллекций, то есть он похож на массив. 
В нем точно также как из массива можно взять элемент по индексу (порядковому номеру). В списке могут находится повторяющиеся или равные элементы. 
 
Интерфейс Set (множество)
Множество предназначено для представления неупорядоченных коллекций. У множества можно посчитать количество элементов, перебрать все элементы. Но нельзя взять элемент по индексу, потому что порядок элементов в множестве не определен. В множестве все элементы уникальны. Если попытаться добавить в множество элемент, который в нем уже содержится, то множество не изменится. 

У кажного интерфейса есть конкретные классы, которые эти интерфейсы реализуют. 

/*
Создаем переменную типа WebDriver и присваеваем в нее значение разных типов: firefoxdriver, chromedriver, iedriver
Там тоже существовали разные реализации для одного интерфейса */

Для интерфейса List существует несколько реализаций, самая популярная - класс ArrayList 
 

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 


  List<String> languages = new ArrayList<String>(); //название_интерфейса<тип_элемента>  = new имя_класса<>, который реализует этот интерфейс
  for (String l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

Теперь нужно этот список заполнить значениями 

В отличии от массива, размер которого заранее известен (он указан при инициализации и меняться не может), размер списка при создании равен 0 и его можно менять: добавлять, удалять элементы. При этом его размер будет меняться динамически. 

Итерация по элементам списка устроена также. 
Тот же цикл for у которого указывается переменная, пробегающая все значения какого то списка (коллекции) 

Вернемся к моменту инициализации массива и заполнения его значениями


Как записать элементы списка в одну строку 

Нельзя указать массив в качестве параментра конструктора
List<String> languages = new ArrayList<String>({"Java", "C#", "Python", "PHP"}); // ошибка


Как преобразовать массив в список

С помощью метода asList(), в который можно передать какое то количество строк в качестве параментра. Результатом метода будет список. Аналог инициализации массива с помощью {}. 

import java.util.Arrays;
import java.util.List;

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"};

  List<String> languages = Arrays.asList("Java", "C#", "Python", "PHP");

  for (String l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}

По элементам списка можно устраивать итерации при помощи вспомогательной переменной счетчика. 

Список - это обычный объект. Поэтому при работе с объектом всегда обращаемся к нему, вызывая какой то метод // имя_объекта.название_метода

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"};


  List<String> languages = Arrays.asList("Java", "C#", "Python", "PHP");

  for (int i = 0; i < languages.size(); i++){ //атрибут size для списка
	System.out.println("Я хочу выучить " + languages.get(i)); // + обращается к элементу с помощью метода get (индекс)
  }

}
}

Можно создать список элементов произвольного типа //но так лучше не делать 

public class Collections {

public static void main(String[] args) {
  String[] langs = {"Java", "C#", "Python", "PHP"}; 


  List languages = new ArrayList<String>();  
  for (Object l : languages){
	System.out.println("Я хочу выучить " + l);
  }
}
}


---
Урок 40. Количество элементов в коллекции 

C помощью коллекций мы научимся получать список элементов со страницы веб приложения и определять их количество.

Начнем с теста для создания групп

Создадим метод позволяющий узнать количество групп и добавим его проверку 


package ru.testjava.addressbook.tests;

import org.testng.Assert;
import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
	int before = app.getGroupHelper().getGroupCount(); //количество групп до добавления
    app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    int after = app.getGroupHelper().getGroupCount(); //количество групп после добавления
    Assert.assertEquals(after, before + 1); //проверка количества элементов 
  }
}


Для реализации новых методов getGroupCount() воспользуемся методом драйвера (с локатором в качестве параметра)

public int getGroupCount() {
    return driver.findElements(By.name("selected[]")).size(); //метод findElements возвращает список элементов т.е. объект типа лист. У этого списка нужно получить размер и затем вернуть его. Это количество и будет результатом работы метода.

  }

Если элемент не найден, то метод findElements() возвращает пустой список, в отличии от метода findElement(), который падает и выбрасывает исключение NoSuchElementException.

---
Урок 41. Выбор элемента списка по порядковому номеру 


Сейчас в тестах для удаления и модификации групп неявно предполагается, что выбирается первая группа
Эта логика спрятана внутри метода selectGroup()

Реализуем возможность передавать туда параметр - индекс или номер группы, которую нужно изменить / удалить.
0 // первый элемент 
before - 1 //последний = колличество - 1 (т.к. нумерация начинается с 0)


Теперь метод selectGroup() будет принимать в качестве параметра индекс элемента

public void selectGroup(int index) { 
    click(By.name("selected[]"));
  }
Нужно как то использовать этот индекс

1) Можно построить локатор, который сразу найдет нужный элемент. В самом локаторе использовать этот индекс.
2) Лучше работать со списком элементов


  public void selectGroup(int index) {
    driver.findElements(By.name("selected[]")).get(index).click(); //находим все элементы по локатору, затем среди этих элементов выбираем нужный по индексу, и именно по этому элементу выполняем клик
  }


---
Урок 42. Формирование коллекции 

Со страницы веб приложения получим список элементов, который содержит информацию о группах. В цикле последовательно перебирем эти элементы, извлечем из каждого элемента текст и другую информацию. 
На основании полученной информации построим собственные объекты типа GroupData (модельные объекты) и сформируем из этих объектов список.  Список будет использоваться в тестах сравнения. В этом уроке для проверки корректности изменения количества групп, в следующем - для сравнения содержимого групп.


Начнем с теста создания группы 

//Как будет выглядеть тест после того как нужный метод будет реализован?

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList(); //переменная before раньше содержала количество элементов, теперь будет содержать список элементов (объектов) типа GroupData
    app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    List<GroupData> after = app.getGroupHelper().getGroupList(); //переменная after содержит список элементов, после того как будет создана новая группа
    Assert.assertEquals(after.size(), before.size() + 1);
  }



Выполним реализацию метода getGroupList()

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();//создадим список, который будем заполнять
    return groups; //в конце метода этот список будет возвращаться
  }

ArrayList<> потому что мы должны указать конкретный класс, который реализует интерфейс List


Далее нужно заполнить список объектами. Данные для создания этих объектов будут извлекаться со страницы веб приложения.
Для этого нужно понять откуда, из какого элемента со страницы можно извлечь нужную информацию.

<span class="group">
	<input type="checkbox" name="selected[]" value="1" title="Select (test1)">
	"test1"
	<br>
</span> 

Возьмем элемент span, который имеет класс group и получим его текст. Тем самым мы сразу получаем название группы.

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group")); //найти все элементы, которые имеют тег span и класс group
    return groups;
  }

Теперь нужно по этим элементам пройти в цикле и для каждого из них выполнить какие то дейсвия

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();	//создадим список, который будем заполнять названиями групп
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group")); //ищем все элементы с тегом span и классом group и создаем новый список
    for (WebElement element: elements) {	//переменная element пробегает по списку
      String name = element.getText(); 	//из каждого элемента получаем текст, это будет имя группы. При работе с элементом всегда обращаемся к нему, вызывая какой то метод (имя_элемента.название_метода)
      GroupData group = new GroupData(name, null, null); 	//создаем объект типа GroupData, в котором header & footer нам неизвестны
      groups.add(group);	//добавляем созданный объект в список
    }
      return groups;
  }

/* Теперь сравниваем размеры списков, которые получены с помощью метода getGroupList(). Фактически проверяется тоже самое (количество групп)
Следующий шаг - сравнение списка целиком */

Перепишем тесты для удаления и модификации групп, чтобы в них использовался новый метод, возвращающий список групп.


---
Урок 43. Сравнение коллекций 

Реализуем проверку, которая контролирует что действительно удалилась нужная группа.
Для этого мы будем сравнивать списки целиком до и после удаления. 

Начнем с теста для удаления групп

Имеем два списка after и before, где размер after больше размера before на 1 элемент.

Поэтому перед тем как сравнивать сами списки, удалим лишний элемент. 

 @Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() - 1);
    app.getGroupHelper().deleteSelectedGroups();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size() - 1);

    before.remove(before.size() -1); //из списка удаляем элемент с тем же индексом, который выбирали 
  }

Теперь имеем два одинаковых списка before и after. Переменная before ссылается не на оригинальный старый список, а на старый список, в котором удален лишний элемент.
Старый список должен содержать теже элементы, что и новый.
Проверить совпадение элементов можно с помощью цикла.

for (int i = 0; i < after.size(); i++){
  Assert.assertEquals(before.get(i), after.get(i));
}

Запускаем тест, получаем сообщение об ошибке 

Expected :ru.testjava.addressbook.modul.GroupData@fd0e5b6
Actual   :ru.testjava.addressbook.modul.GroupData@4eed46ee

Из описания не понятно какие именно элементы списка сравнивались // тип@идентификатор (адрес объекта в памяти)


Чтобы увидеть текстовое представление элемента, нужно в классе GroupData сгенирировать специальный метод toString(). Он используется для преобразования в строку.

Code > Generate > toString()   

Далее нужно указать какие именно атрибуты объекта должны влючаться в строковое предствление. Указываем только name, так как header и footer неизвестны.

  @Override
  public String toString() {
    return "GroupData{" +
            "name='" + name + '\'' +
            '}';
  }

Теперь сообщение об ошибке имеет вид

Expected :GroupData{name = 'test1'}
Actual   :GroupData{name = 'test1'}

Java не знает как сравнивать объекты типа GroupData. Никаких правил для сравнения этого типа данных нет.
Нужно определить собственные правила сравнения, с помощью метода Equals. Он будет сравнивать атрибуты объекта по смыслу. 

Code > Generate > equals() and hashCode()

Указываем какие атрибуты будут участвовать в сравнении (указываем только name) 
Оставляем пустыми Select all-null fields  // указать какие поля не могут принимать значения null 

Тест успешно завершился. Теперь списки логически равные, потому что они состоят из равных объектов по смыслу. 
Списки построены отдельно, независимо друг от друга. Объекты физически разные, они хранятся в памяти в разных местах.  

Тестовый фрейворк умеет сам сравнивать списки без указания цикла.
Можно вызвать метод Assert.assertequals(befor, after) и передать туда два списка. 

  @Test
  public void testGroupDeletion(){
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().deleteSelectedGroups();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size() -1);

    before.remove(before.size() -1); 
    Assert.assertEquals(before, after);

  } 


---
Урок 44. Множества. Неупорядоченные коллекции


Реализуем аналогичную проверку для теста модификации групп. Необходимо учесть, что при модификации группы меняется ее имя. Группа может перепрыгнуть на другое место в списке, потому что в тестируемом приложении группы сортируются по именам. Поэтому нужно сравнивать без учета порядка.  

Нужно преобразовать эти списки в множества и сравнить их.


public class GroupModificationTests extends TestBase{

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData("test1", "test2", "test3"); //4- добавили локальную переменную
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    //3 - ниже модифицируем старый спискок, чтобы предсказать ожидаемый результат

    before.remove(before.size() -1); //удаляли последний элемент
    before.add(group); //вместо него добавим тот, который должен появится после модификации


    //1 - добавим сравнение множеств

    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); // 2 - преобразуем списки в множества
  }
} 


Можно было модифицировать объект, который находится в этом списке, не удаляя его от туда и не добавляя вместо него другой. Но с логической точки зрения никакой разницы нет. Проще удалить не нужный и вместо него добавить тот, который нам требуется. А уже после того как это сделано, можно преобразовать полученнные списки в множества и сравнивать их друг с другом.        

Запускаем тест, он зеленый. Но не все так хорошо на самом деле. 

Модифицируем состояние тестируемой системы, создадим список из трех групп test1, test2, test3

Что сделает тест? 
Он меняет последнюю группу test3, давая ей имя test1
Теперь у нас две группы с именем test1 и одна с test2

Поставим точку остановы в строке и выполним тест в отладчике 
Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));


У нас есть before и after, в каждом из них находится по 3 элемента.
  
Провалимся во внутрь метода assertEquals()
и поставим точку остановки внутри него 

public static void assertEquals(Set<?> actual, Set<?> expected) { //сравниваются два множества, построенных из разных списков
    assertEquals(actual, expected, null);
  }
  
Продолжаем выполнение и видим, что здесь сравниваются 2 множества, имеющих размер 2.

Куда пропал третий элемент?
Проблема в том что множества не позволяют дублирование элементов, а мы сравниваем объекты (группы) по именам. Следовательно, все группы с одинаковыми именами схлопываются.
 
Вывод: если группа test3 получила бы имя test2 вместо test1, то наш тест решил бы что множества равны. 

test1		test1
test1		test2
test2		test2

Это некорректная проверка.

Решение 
Если бы группы имели уникальные идентификаторы, тогда бы при преобразовании списка в множества схлопывания не происходило.
Нужен уникальный идентификатор для каждого объекта. 


<input type="checkbox" name="selected[]" value="1" title="Select (test1)"> //value="1" 


Извлечем эти идентификаторы и будем их использовать при сравнении объектов

1 часть
 
public class GroupData {
  private final String id; //добавим атрибут 
  private final String name;
  private final String header;
  private final String footer;

  public GroupData(String id, String name, String header, String footer) { //добавим параметр в конструктор
    this.id = id; //присваивать значение параментра в атрибут - в поле объекта
    this.name = name;
    this.header = header;
    this.footer = footer;
  }


2 часть
Делаем для этого поля метод getter, которое позволяет получить значение поля 
Code > Generate > Getter

public class GroupData {
  public String getId() {
    return id;
  }

Перегенерируем методы toString() / equals() 

Code > Generate > toString //указываем для id и name и заменяем для всех
Code > Generate > equals and hashCode //заменить существующие, default, указываем для id и name

3 часть

Модификация GroupHelder

  public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));// 3 - получили элемент, который является частью списка
    for (WebElement element: elements) {
      String name = element.getText();
	  String id = element.findElement(By.tagName("input")).getAttribute("value");  //2 - откуда взять id?  4 - Ищем внутри одного элемента другой и берем из него атрибут value
      GroupData group = new GroupData(id ,name, null,null); //1 - GroupHelper должен откуда то id извлекать, и передавать его в качестве параметра в конструктор, он используется при сравнении
      groups.add(group);
    }
      return groups;
  }

//**но это не чек-бокс - это элемент внутри которого, находится чек-бокс
<span class="group">
	<input type="checkbox" name="selected[]" value="5" title="Select (test2)">
	"test2"
	<br>
</span>


После модификации, появились ошибки компиляции
- можно их исправлять, везде передавать вкачестве идентификатора null 
- можно добавить конструктор в классе GroupDate

//группа с неизвестным идентификатором, она не прочитана из веб интерфейса, а создана искусственно 	
  public GroupData(String name, String header, String footer) { //не принимает идентификатор (String id) в качестве параметра 
    this.id = null; //если вызывается этот конструктор, то присваивается null в качестве идентификатора
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  public GroupData(String id, String name, String header, String footer) {
    this.id = id;
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

Повторяем запуск отладчика с выставленными ранее точками остановы

В методе assertEquals() видим что сравниваются два множества, которые имеют размер 3
Схлопывания нет, потому что все элементы различные. У них разные идентификаторы. Но с логической точки зрения, они должны быть равны. 

Тест падает. Проблема в том, что множества оказываются разными. Во втором множестве, есть элемент, у которого id = null. Этот тот самый, который модифицировали.  
 
Нужно ему установить правильный идентификатор. 
А откуда его узнать? Из уже существующего объекта, это будет последний элемент списка before

GroupData group = new GroupData(before.get(before.size() -1).getId(),"test1", "test2", "test3"); //используем идентификатор той группы, который был до модификации

При модификации группы мы указываем новые name, header, footer, а идентификатор остается старым.



---
Урок 45. Поиск максимального элемента в коллекции

Добавим аналогичную проверку в тест для создания групп.

Проблема: новая созданная группа добавляется не в конец, а в какое то произвольное место
Решение: сравнивать старый список с новым нужно без учета порядка

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null); //2 - выделим переменную
    app.getGroupHelper().createGroup(group); //3 - используем выделенную переменную
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    //предсказываем ожидаемый результат
    before.add(group); //1 - добавляем в список ту группу, которую создали в тестируемом приложении
	
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); //4 - преобразуем списки в множества и сравниваем их
  }

Проблема: Что насчет идентификатора новой добавленной группы? Как узнать какой идентификатор присвоен новой группе?
Решение: Мы может опираться на предположение, что в новом списке это добавленная группа имеет максимальный идентификатор. //В тестируемом приложении новому индентификатору присваивается максимальное значение для того, чтобы они были уникальными.
Среди всех элементов, которые входят в новый список after, нужно найти тот, который имеет максимальный идентификатор. Это будет предсказанным ожидаемым идентификатором новой группы. Группа с таким идентификатором должна имеить те свойства, с которыми мы пытались ее создать.


Как узнать максимальный идентификатор?

Для начала меняем ему тип String на int
private final String id; // тип Строка не подходит для сравнения 

Испортились методы, в которых этот атрибут используется. Перегенерируем equals() и hashCode().


Исправим метод getGroupList(), который этот идентификатор вычисляет. Теперь он должен быть не строкой, а числом.

Было 
public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      String id = element.findElement(By.tagName("input")).getAttribute("value");
      GroupData group = new GroupData(id, name, null,null); 
      groups.add(group);
    }
      return groups;
  }

Стало
public List<GroupData> getGroupList() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
	  int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value")); // преобразуем значение атрибута из строки в число с помощью метода Integer.parseInt()
      GroupData group = new GroupData(id, name, null,null);
      groups.add(group);
    }
      return groups;
  }

Теперь можно перейти к сравнению и определению максимального идентификатора


public class GroupCreationTests extends TestBase {

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group); 
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);


    before.add(group);
    //устраиваем цикл по всем элементам
    int max = 0;  
    for (GroupData g : after) {
      if (g.getId() > max) {
        max = g.getId();
      } 
    group.setId(max); //в конце найдется самый большой, присвоим его в качестве идентификатора новой группы; сгенерируем метод setter 
    }
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }

}


Для начала присваиваем переменной max значение 0, потом постепенно сравниваем уже найденный максимум с идентификатором каждого элемента, если идентификатор окажится больше, то значение переменной max меняем на новый найденный максимум.  


Сгенерируем метод setter

private final int id; //модификатор final означает что менять атрибут нельзя. То значение, которое присвоено в конструкторе оно и остается навсегда. 

Мы хотим менять индентификатор, final убирем
private int id;


Запускаем тест. Тест зеленый. 
  

---
Урок 46. Лямбда-выражения (анонимные функции) и элементы функционального программирования

До версии Java 8 можно было функции только вызывать, обращаться к ним по имени. 

Основаная идея функционального програмирования заключается в том, что с функцией можно работать как с объектом. Ее можно присвоить в переменную, передать в качестве параметра при вызове другой функции. То есть функция такая самостоятельная сущность.

//поиск элемента с максимальным идентификатором 
//старый способ сравнения
int max = 0;
for (GroupData g : after) {
  if (g.getId() > max) {
	max = g.getId(); 
  }
}

Как сделать функцию , которая вычисляет максимальный элемент для списка, который содержит произвольные объекты (не только числа)?
Нужно передать в такую функцию в качестве параметра описание того, как сравниваются элементы. То есть передать функцию, которая умеет сравнивать объекты. 


1 способ
Использовать встроенную возможность, которая появилась в стандратной библиотеке Java 8

Список можно превратить в поток Stream.

Превращаем список в поток, у него есть метод max(), который позволяет вычислять максимальный элемент. В метод max() передадим в качестве параметра компаратор (сравниватель).

after.stream().max(byId) //Если предположить что метод отработал, то есть нашел максимальный элемент, то мы можем при помощи метода get() этот элемент получить и взять у него идентификатор  

int max = after.stream().max(byId).get().getId(); //чтобы это заработало, реализуем сравниватель 

Alt + Enter > Create local variable //создается переменная правильного типа 


Comparator<? super GroupData> byId; //компаратор, который умеет сравнивать объекты типа GroupDate
int max = after.stream().max(byId).get().getId();


Инициализируем переменную, присвоим в нее конкретное значение //добавим = new Comparator<GroupData>()

Comparator<? super GroupData> byId = new Comparator<GroupData>() {
      @Override
      public int compare(GroupData o1, GroupData o2) {
        return 0;
      }

}

Компаратор - это интерфейс, который не имеет реализации он только декларирует, объявляет какие методы должны быть. Но реализации этих методов не содержит. 
Можно создать класс, который наследуется от / реализует этот интерфейс. Но это делать не обязательно. Когда создаются такие одноразовые объекты, можно использовать аннонимные классы для которых реализация пишется здесь и сейчас.    


//новый способ сравнения
//1 - сравниватель для двух объектов типа GroupData
Comparator<? super GroupData> byId = new Comparator<GroupData>() { //должен быть реализован один единственный метод compare(), при помощи которого должны сравниваться два объекта типа GroupData
  @Override
  public int compare(GroupData o1, GroupData o2) {
	return Integer.compare(o1.getId(),o2.getId()); //используем метод compare(), который умеет сравнивать числа
  }
};
//2 - вычисление максимального объекта 
int max1 = after.stream().max(byId).get().getId(); //max(byId) сравниваются объекты при помощи компаратора 
group.setId(max1);


Лямбда-выражения - анонимные функции 


Переделаем анонимный класс в анонимную функцию //установив режим совместимости Project Structure > Modules > Language level - 8

Comparator<? super GroupData> byId = new Comparator<GroupData>() {} //класс new Comparator<GroupData>() является функциональным интерфейсом , поэтому его можно заменить на лямбда - выражение 
@FunctionalInterface - означает что внутри него имеется одна единственная функция, которая может быть представлена как самостоятельная сущность.   

Comparator<? super GroupData> byId = (Comparator<GroupData>) (o1, o2) -> Integer.compare(o1.getId(),o2.getId());
    int max1 = after.stream().max(byId).get().getId();
    group.setId(max1);



//названия параметров (o1, o2) -> тело функции Integer.compare(o1.getId(),o2.getId());
//от локальной переменной можно избавится, аннонимную функцию лямбда выражение можно передать в качестве параментра при вызове метода max() 
	
int max1 = after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId();	
	
/*список превращаем в поток
 по этому потоку пробегает функция сравниватель и находит максимальный элемент
 при этом сравниваются объекты типа GroupData путем сравнивания их индентификаторов
 get() на выходе этой функции будет максимальный объект, то есть группа с максимальным идентификатором
 getId() остается взять этот идентификатор
*/ 
	
	
	
  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    group.setId(after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId());
    before.add(group);
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }	
	

	
---
Урок 47. Сортировка списков

В тесте для модификации групп реализуем другой способ решения проблемы сортировки.
Вместо того, чтобы игнорировать порядок, мы наведем свой собственный. Например, упорядочим группы по идентификаторам. 


  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() -1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData(before.get(before.size() -1).getId(),"test1", "test2", "test3");
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    before.remove(before.size() -1);
    before.add(group);
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after));
  }
/* 
Мы не знали в каком порядке находятся элементы. После модификации группы она могла находится в другом месте. 
Потому что сортировка в тестируемом приложении выполняется по неизвестному правилу. 
Мы решили полностью игнорировать порядок и сравнивать множества вместо списков.
*/

Как сортировать список?

// Старый способ Collections.sort()

В Java 8 у списка появился метод sort(), который в качестве параметра принимает компаратор т.е. описание правил сравнения объектов 

before.sort(byId); //сравниваем по идентификаторам

Просим среду разработки, чтобы она создала локальную переменную byId

Сразу пишем лямбда-выражение
 
Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId()); 
/*
= анонимная функция, которая на вход принимает два параметра(группа_1, группа_2) 
и выполняет сравнение идентификаторов Integer.compare(первый_идентификатор,второй_идентификатор) 
это и будет возвращаемый результат этой аннонимной функции
*/


  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    if (! app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
    List<GroupData> before = app.getGroupHelper().getGroupList();
    app.getGroupHelper().selectGroup(before.size() - 1);
    app.getGroupHelper().initGroupModification();
    GroupData group = new GroupData(before.get(before.size() - 1).getId(),"test1", "test2", "test3"); 
    app.getGroupHelper().fillGroupForm(group);
    app.getGroupHelper().submitGroupModification();
    app.getGroupHelper().returnToGroupPage();
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(),before.size());

    before.remove(before.size() - 1);
    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }

Модифицируем тест для создания группы
Упорядочим группы и сравним получившиеся списки, в которых группы находятся в одинаковом порядке. При этом даже не нужно определять идентификатор новой добавленной группы, потому что она должна оказаться в конце.

было
  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    group.setId(after.stream().max((o1, o2) -> Integer.compare(o1.getId(),o2.getId())).get().getId());
    before.add(group);
	
	 
    Assert.assertEquals(new HashSet<Object>(before), new HashSet<Object>(after)); 
  }

стало

  @Test
  public void testGroupCreation() {
    app.getNavigationHelper().gotoGroupPage();
    List<GroupData> before = app.getGroupHelper().getGroupList();
    GroupData group = new GroupData("test1", null, null);
    app.getGroupHelper().createGroup(group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size() + 1);

    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(),g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }

Как добится чтобы новая группа оказалась в самом конце?  

  public GroupData(String name, String header, String footer) {
    this.id = Integer.MAX_VALUE; //дефолтное значение для индентификатора  
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

Теперь достаточно сравнивать только name

Перегенерируем функцию equals()

Запустим тест. Тест зеленый.



---
Занятие 5. Улучшение кода тестов. Работа со строками
Урок 48. Как правильно запускать браузер 

Оптимизируем тесты 

Для каждого теста запускается отдельный экземляр браузера.
Можно попробовать сэконоить, использовать один и тот же браузер (одно и тоже окружение для выполнения нескольких тестов подряд).

//Надо стараться делать тесты независимыми, чтобы они могли для себя подготовить тестовую ситуацию. Где каждый тест проверяет предусловие и сам для себя создает все что ему необходимо.     


Ведущую роль играет класс TestBase, в котором вызывается метод init() в начале (в классе ApplicationManager, который в свою очередь запускает браузер) и метод stop() в конце. 
Это происходит перед каждым тестовым методом, потому что указана анатация @BeforeMethod  //дает указание тестовому фреймворку выполнять метод setUp() перед каждым тестовым методом  

Посмотрим какие есть варианты Ctrl+Space

@BeforeMethod //тот метод, который помечен этой анатацией, запускается перед каждым тестовым методом

@BeforeClass //запускается перед всеми тестовыми методами, которые выходят в какой-то класс 
 
@BeforeGroups //в TestNG можно указать, что тестовый метод принадлежит какой-то группе 

@BeforeSuite 

В TestNG Suite всегда один единственный, он соответствует одному запуску. Он может состоять из нескольких тестов.
Сделать Suite, который состоит из нескольких тестов, можно только с помощью специального конфигурационного файла. 
Если тесты запускаются из среды разработки (ПКМ на пакет / класс), то автоматически создается Suite, который состоит из одного единственного теста. То есть в данном случае, никакой разницы между Suite и тест нет. Она возникает, когда используется конфигурационный файл.
Suite всегда один единственный, а тестов может быть несколько. Тест это часть Suite. Тест включает в себя классы. Классы состоит из нескольких тестовых методов. Suite > Test > Class > Method


Если мы хотим запустить один единственный экземляр браузера, его нужно запустить в методе, который помечен анатацией @BeforeSuite, а останавливать @AfterSuite.

Тесты упали, потому что не получили доступ к браузеру. 

Тесты разложены по разным классам. И для того чтобы их запустить TestNG, создает экземляр тестового класса, этот тестовый класс наследуется от класса TestBase  //получает доступ к переменной app

Но когда создается другой экземляр, другого тестового класса, то это будет совсем другая переменная app. Каждая из них ассоциирована со своим объектом. Этих объектов много, по одному для каждого тестового класса. А метод @BeforeSuite выполняется один раз. 
В каком именно из этих всех многочисленных объектов он будет выполняться? Ни в каком.
 
TestNG сначала создаст экземляр класса TestBase, в котором будет ссылка на ApplicationManager и в этом объекте выполнит инициализацию, а потом создаст экземляр какого то тестового класса, в котором тоже будет ссылка на ApplicationManager. Но она не будет инициализирована.  
Единственная инициализированная, находится в том самом объекте типа TestBase, который вообще не используется для запуска тестов. Он играет чисто вспомогательную роль. 

Как эту проблему решить?
Нужно ссылку на ApplicationManager сделать общей для всех тестов. Объявим ее static

protected static final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);

Все функции находятся внутри какого-то класса. Несмотряна это, для вызова static функции не нужно создавать объект этого класса. К ней можно обращаться непосредственно / на прямую. Тоже относится к переменным. 


Если пометить переменную static, то она становится независимой. То есть не является частью какого-то объекта. Это самостоятельная глобальная переменная. К ней может получить доступ кто угодно по ее имени (TestBase.app)

**
TestNG в самом начале создает экземляр класса TestBase, в нем выполняется код инициализации app.init(), который инициализируем глобальную переменную. Далее создается экземляр класса например  GroupCreationTests, который пользуется этой переменной. Потом создается другой экземляр, другого класса, и в самом конце TestNG выполняет tearDown(), обращается к глобальной переменной app.stop().   

---
Урок 49. Улучшение кода тестов - ещё немного реструктуризации кода

Код тестовых сценариев - фасадная часть работы тестировщика автоматизатора 

В TestBase есть глобальная инициализация @BeforeSuite

Для одного теста или группы тестов может существовать локальные инициализации, которые нужны чтобы подготовить состояние именно для конкретного теста.

//данный фрагмент кода будет общий для всех тестов проверки модификации групп 
    app.getNavigationHelper().gotoGroupPage();  
    if (!app.getGroupHelper().isThereAGroup()) { //проверка предусловия
      app.getGroupHelper().createGroup(new GroupData("test1", null, null)); //если предусловие не выполняется, то подготовка состояния
    } 

Поместим его в отдельный метод с анатацией @BeforeMethod


public class GroupModificationTests extends TestBase {

  @BeforeMethod //перед каждым тестовым методом должна выполняться проверка предусловия
  public void ensurePreconditions() {
    app.getNavigationHelper().gotoGroupPage();
    if (!app.getGroupHelper().isThereAGroup()) {
      app.getGroupHelper().createGroup(new GroupData("test1", null, null));
    }
  }

  @Test
  public void testGroupModification() {
    List<GroupData> before = app.getGroupHelper().getGroupList();
    int index = before.size() - 1;
    GroupData group = new GroupData(index, "test1", "test2", "test3");
    app.getGroupHelper().modifyGroup(index, group);
    List<GroupData> after = app.getGroupHelper().getGroupList();
    Assert.assertEquals(after.size(), before.size());

    before.remove(index);
    before.add(group);
    Comparator<? super GroupData> byId = (g1, g2) -> Integer.compare(g1.getId(), g2.getId());
    before.sort(byId);
    after.sort(byId);
    Assert.assertEquals(before, after);
  }


}

Самое главное требование, которое предъявляется к тестам - это легкость их восприятия / понятность. 

А когда инициализация находится в другом классе, это негативно складывается на восприятии. 



---
Урок 50. Улучшение названий методов 

 

Некотороые методы начинаются на get /set.
Наличие такого метода обычно означает, что у объекта есть атрибут. Но прямой доступ к этому атрибуту не разрешен. И к нему можно обратиться только с помощью вспомогательного метода - название которого обычно является производным от названия атрибута. 


В AM имеется атрибут, который называется NavigationHelper. Ему соответствует парный метод getNavigationHelper(). //традиционное соглашение об именах 

Называйте методы так, чтобы их было легко читать. 


---
Урок 51. Fluent-интерфейсы

Fluent (плавный / гладкий) - интерфейсы, целью которых является увеличение понятности и легкости чтения кода.

Основной прием реализации интерфеса - вытягивание методов в цепочки / каскадный вызов методов //app.contact().create()



В классе GroupData удаляем отметку final

Генерируем Setters

Меняем завание getName на withName

добавляем возвращаемое значение

меняем тип void на GroupData


public GroupData withId(int id) {
    this.id = id;
    return this; //метод будет возвращать тот самый объект, в котором он вызван. Это позволяет строить каскады - вытягивать методы в цепочку
  }

Удаляем конструкрторы, добавив дефолтное значение атрибуту 


Фактически у нас остается один единственный конструктор, который не принимает никаких параметров. 
И при этом новый созданный объект инициализируется дефолными значениями

public class GroupData {
  private int id = Integer.MAX_VALUE; //макс значение перенесли из удаленного констуктор
  private String name; //три атрибута будут иметь значение null
  private String header;
  private String footer;   

}


Теперь сломались все места в которых сломался контсруктор. Исправляем

было
public void testGroupCreation() {
  ...  
    GroupData group = new GroupData("test2", null, null);
  ...	
	}



стало
public void testGroupCreation() {
  ...  
    GroupData group = new GroupData().withName("test2");
  ...	
	}

Теперь легко читается как обычный английский тест, в этом и состоит идея гладкости 

GroupData group = new GroupData().withId(before.get(index).getId()).withName("new1").withHeader("new2").withFooter("new3");
    

Аналогично меняем в других методах, где создается новый объект типа GroupData

public List<GroupData> list() {
    List<GroupData> groups = new ArrayList<GroupData>();
    List<WebElement> elements = driver.findElements(By.cssSelector("span.group"));
    for (WebElement element: elements) {
      String name = element.getText();
      int id = Integer.parseInt(element.findElement(By.tagName("input")).getAttribute("value")); 
      GroupData group = new GroupData().withId(id).withName(name); //со значением null не надо указывать 
      groups.add(group);
    }
}

Каждый вызываемый метод, возвращащает тот же самый объек, который мы модифицируем шаг за шагом. И в конце тоже возвращается тот же самый объект, который в конечном итоге присваивается в переменную.   	
	
	
Конструировать объекты стало приятнее, потому что мы явно указываем какой атрибут принимает какое значение.	
	
Шаблон билдер - интерфейс, который описывает способ использования плавных интерфейсов для конструирования объектов  	


	
---	

Урок 52. Повсеместное использование уникальных идентификаторов объектов 





































Урок 53. Hamcrest - улучшение внешнего вида проверок 00:14:59

Урок 54. Кеширование результатов длительных операций 00:06:21

Урок 55. Хеширование и предварительные проверки 00:07:29

Урок 56. Способы построения сложных локаторов 00:10:59

Урок 57. Режем строки (и немного про регулярные выражения) 00:10:12

Урок 58. Клеим строки - метод обратных проверок 00:11:05

Урок 59. Пути к файлам и директориям 00:13:47

Урок 60. Генератор тестовых данных, запись данных в файл 00:11:50

Урок 61. Анализ опций командой строки при запуске генератора данных 00:07:29

Урок 62. Параметризация тестовых методов 00:09:52

Урок 63. Загрузка тестовых данных из файла 00:07:52

Урок 64. Формат XML 00:14:22

Урок 65. Формат JSON 00:10:17

Урок 66. Автоматическое закрытие файлов после использования 00:03:13

Урок 67. Конфигурационные файлы для описания тестовых наборов 00:08:14

Урок 68. Описание конфигурации тестового стенда 00:12:56

Урок 69. Протоколирование (лог-файлы) 00:13:38

Урок 70. Драйвер базы данных. Получение данных из БД 00:13:19

Урок 71. Object Relational Mapping (ORM) 00:17:30

Урок 72. Условия отбора данных 00:09:05

Урок 73. Сравнение данных, загруженных из БД 00:13:09

Урок 74. Отключаемые проверки UI 00:08:54

Урок 75. Связи между объектами 00:16:38

Урок 76. Установка нового учебного приложения MantisBT 00:04:27

Урок 77. Подготовка проекта для тестирования MantisBT 00:09:51

Урок 78. Прямое взаимодействие с сервером по протоколу HTTP 00:16:34

Урок 79. Ленивая инициализация помощников 00:08:35

Урок 80. Передача файлов на удалённую машину по протоколу FTP 00:13:56

Урок 81. Получение почты на встроенный в тесты почтовый сервер 00:24:55

Урок 82. unnamed 82 00:16:38

Урок 83. Немного теории про Remote API 00:12:35

Урок 84. SOAP - простой пример 00:11:44

Урок 85. SOAP - взаимодействие с MantisBT 00:22:17

Урок 86. REST - взаимодействие с Bugify 00:24:43

Урок 87. RestAssured - использовать или нет 00:06:32

Урок 88. REST - взаимодействие с GitHub 00:10:26

Урок 89. Сервер непрерывной интеграции 00:23:21

Урок 90. Удалённый запуск браузера (Selenium Server) 00:15:57

Урок 91. Конфигурационное тестирование (Selenium Grid) 00:20:00

Урок 92. Генерация отчётов при помощи Allure 00:25:35

Урок 93. Keyword Driven Testing и инструмент Robot Framework 00:20:52

Урок 94. Behaviour Driven Testing и инструмент Cucumber-JVM 00:22:15	
	
	
	
	
	
	
	
	
	