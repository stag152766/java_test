Занятие 1.
Lesson1. Основы

Написать программу 
Загрузить в память 
Хранить пока не запустится
ЦП начинает ее исполнять
Результат

Программа - набор инструкций и данных для обработки. На выходе получаем результат.

Уровни языков 
высокий (исходный код)
низкий (машинный код) 

Трансляция - перевод языка с высого на низкий уровень
Машинный код - код, исполняемый непосредственно процессором


Языки условно разделяются на: 
Компилируемый 
Интерпритируемый 

Способ 1
Исходный код программы пишется на каком-то языке программирования, инструмент который транслирует исходный код в машинный, называется компилятор. На выход он принимает программу на высокоуровневом языке, на выходе получается файл, сожержащий исполняемый код, который может исполняться ЦП. Компилятор порождает файл, который может самостоятельно исполняться. После создания файла компилятор не нужен. Компилятор нужен только разработчику. Пользователю нужен только скомпилированный исполняемый файл. Программа распостраняется в виде исполняемого файла. 

Способ 2
Интерпретатор читает исходный код, написанный на языке высокого уровня. Интерпретатор выполняет команды этого языка. На процессоре исполняется интерпретатор, а не какая-то программа, которая им порождается. Интерпретатор ничего не порождает, он сам работает и сам во время работ интерпретирует исходный код программы. Пользователю нужно установить интерпретатор. Программа распостряняется в виде исходных кодов. 

Способ 3
Одновременное наличие компилятора и интерпретатора. 
Исходный код программы с помощью компилятора преобразуется в байт-код. Байт код - промежуточное представление. Это низкоуровневый код, но еще не машинный код. Для исполнения байт кода нужен интерпретатор, который читает программу в байт коде и исполняет ее. В отличии от классического интерпритатора, низкоуровневый байт код легче и быстрее интерпретировать. 

Преимущества способа 3   
1. Простой и быстрый интерпретатор
2. Переносимость (кроссплатформенность). Исполняемый код для разных процессоров и ОС нужен разный. Если разработчики не ходят открыть свой код, и при этом они не сделали исполняемый код для вашей платформы, то сами сделать вы не сможете. 
А байт код, в отличии от обычного машинного кода, является универсальным. Компилятор универсальный, а интерпретатор под каждую платформу отдельный. В результате, программа распостраняется в одном единственном формате, возможность запуска определяется исключительно наличием интерпретатора для этой платформы.    
	
Java распостраняется в виде двух дистрибутивов. 
Java SDK (compiler + JRE ) для разработчиков.
Java Runtime Environment (JRE) для пользователей.



---


Lesson2.  Установка Java SDK. Настройка окружения.

Путь инсталяции
C:\Program Files\Java\jdk-11.0.1\

Настройка окружение

Путь к исполняемому файл 
C:\ProgramData\Oracle\Java\javapath\

Путь к JRE 
‪C:\Program Files\Java\jre1.8.0_181\bin\java.exe

Инсталятор настраивает окружение на JRE, так как это удобно пользователям для запуска java программ. Нам нужно перенастроить окружение так, чтобы вместо этого использовались исполняемые файлы JSK.

Для этого модифицируем переменную окружения path 
Control Panel\All Control Panel Items\System > Advanced system settings > System Properties > Environment Variables > Path

c:\Program Files\Java\jdk-11.0.1\

	

Создали путь для JSK

Путь к исполняемому файлу where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe

Путь к компилятору where javac
c:\Program Files\Java\jdk-11.0.1\bin\javac.exe


Поднимаем переменную JAVA_HOME вверх, чтобы в командной строке получилось
C:\Users\kobzev\Documents\temp>where java
c:\Program Files\Java\jdk-11.0.1\bin\java.exe
C:\ProgramData\Oracle\Java\javapath\java.exe






C:\Program Files\Java\jdk-11.0.1\
---

Lesson3. 

Расширение .java указывает на то, что внутри хранится исходный код.


Пишем программу myFirstProject.java
public class myFirstProject {

	public static void main(String[] args) {
		System.out.println("Hello, world!");
	}
}


C:\Users\kobzev\Documents\temp>javac myFirstProject.java //компилируем

C:\Users\kobzev\Documents\temp>java myFirstProject //запускаем байт код
Hello, world!


---

Lesson4. Система хранение кода 

Зачем?
Резервная копия исходного кода
Ослеживание изменений (история)
Синхронизация, совместный доступ



Add .gitignore - параметр определяет чего не нужно сохранять в репозитории (файлы компиляций/отчеты о выполнении тестов)


Поэтому создаем файл .gitignore описывающий что сохранять не нужно

Выбираем Gradle / Apache License 2.0

Клонирование - программа для локальной копии

---
Lesson5. Сборщики

В больших проектах много файлов, дополнительных библиотек. При компиляции нужно указывать пути к файлам с исходным кодом, библиотекам, опции. 
Решение
Написать один конфигурационный файл, Gradle, который берет конфигурационный файл и компилирует с описанием.

Конфигурационный файл может описывать настройки запуска, тестов. 

Популярные сборщики для Java
Аpache Аnt
Apache Maven
Gradle

Подготовка проекта
sandBox

Создание конфигурационного файла sandBox.gradle

Сборщики являются универсальными инструментами, умеют работать с разными языками программирования.
Необходимо подлючить плагин 
apply plugin: 'java'
Этот плагин требует создание определенной структуры директорий. Он будет искать файлы с исходным кодом на языке java в определенном месте (будем использовать настройки по умолчанию).

Создаем структуру директорий
src > main | test

main > java //сюда кладем файлы с исходными кодами, кроме тестов
test > java //сюда кладем тесты

Перемещаем myFirstProject.java в директорию main
Переходим в корневую папку sandBox
Запускаем консоль и компилируем файл с помощью gradle
c:\Tools\gradle-4.10.3\bin\gradle build

В проекте sandBox появляется два подкаталога
первый содержит вспомогательные файлы, которые нужны gradle для работы
c:\Users\Admin\Documents\temp\sandBox\.gradle\

второй сожержит результат компиляции
c:\Users\Admin\Documents\temp\sandBox\build\classes\java\main\

Для того, чтобы запустить скомпилированный файл class используется плагин
apply plugin: 'application'

Для того, чтобы данный плагин знал, что запускать указываем настройку
mainClassMain = "myFirstProject"


c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle run
 
запускается перекомпиляция и на консоль выводится наш текст "Hello, world!"

Уложить все в репозиторий


gradle можно интегрировать в проект, так чтобы все необходимое для его запуска хранилось в самом проекте. Для создания такого запускателя, gradle все таки понадобится. После того как запускатель создан, отдельно стоящий gradle уже использоваться не будет. 

В консоли выполняем команду запускателя
c:\Users\Admin\Documents\temp\sandBox>c:\Tools\gradle-4.10.3\bin\gradle wrapper  

Внутри проекта sandBox появляются новые файлы, которые представляют собой запускатель.
Укладываем их в репозиторий.



c:\Users\Admin\Documents\GitHub\java_test\sandBox\gradlew build

Скачивается и устанавливается внутрь проекта отдельный сборщик gradle. В результате отдельный gradle уже не будет использоваться.

После того, как дистрибутив загружен он распаковывается внутрь проекта и используется для сборки и запуска.
c:\Users\Admin\Documents\GitHub\java_test\sandBox>gradlew run

---
Lesson6. Среда разработки

Основные
NetBeans
Eclipse
IJ


IJ позволяет оперировать двумя разными сущностями
проект - это группа модулей
модуль 

Выбираем New Project > Empty Project
Project Location: java_test //корневую директорию

Изменяем
Project Structure > SDKs + // указать где находится java
C:\Program Files\Java\jdk-11.0.1

Gradle Project 
Use auto-import enabled
Позволяет автоматически сихронизировать модуль, который мы создаем в среде разработки, с конфигурационным файлом build.gradle (когда изменения вносятся в конфигурационный файл, автоматически обновляется модуль).

Create durectories for empty content roots automatically
Используется когда есть пустой модуль с конфигурационным файлом

Create separate module содержит три типа модулей
для подкатолога src main
для подкатолога src test
общий

Открваем myFirstProject.class 
Запускаем в среде разработки IJ
Комитим в гитхаб

В GitHub видим последнии изменения, сохранять их нужно не все потому что они быстро меняются
workspace.xml // содержит информацию о том, какие файлы открыты в среде IJ
misc.xml 

помещение (push) 
получение (pull)

Скачать все ветки с origin, но не мержить их в локальный репозиторий:
fetch orgin 


---
Lesson7. Рассматриваем высокуровневую структуру

В Java есть соответствие между файлами и классами. 
Если есть файл myFirstProject.java, то он должен содержать класс с таким же именем myFirstProject без расширения (не допускается несоответствие имен)

IJ автоматически сохраняет исходный код, компилирует его, и выводит сообщение об ошибке (при наличии)


Пакеты - с физической точки зрения соответствуют наборам директорий. Предназначены для того, чтобы избегать конфликты имен файлов и разрешить создавать файлы с одинаковыми именами. Рекомендуется классы помещать в индивидуальные пакеты.

Refactor > Move > Create New Package // ru.testjava.sandBox

Помещаем в папку src main, в которой создается иерархическая структура директорий. Таким образом, исключаются все конфликты между именами файлов. 


---
Lesson8. Рассматриваем содержимое файла исходного кода

Класс - основная структурная единица кода. Любой исполняемый код должен находится внутри какого-то класса. 

public class myFirstProject {}- открывая файл исходного кода обнаруживаете декларация одноименного класса. Внутри фигурный скобок находится описание класса (ограничитель для блока кода). 

Все конструкции заканчиваются ;

Метод = функция = блок кода (параметры) {конструкции, выражения}

метод main принимает на себя массив строке


Форматирование 
Code > Reformat Code  

Правила именования
классы всегда с большой буквы
все остальное с маленькой буквы

СamelCase


---
Lesson9

В java есть определенные правила вычислений. Если в выражении есть целые числа, то результат должен является тоже целым числом.
В ПК целые и дробные числа хранятся по разному. Для хранения дробных чисел используется представление чисел с плавающей точкой (2*10^3)

System.out.println("2" + 2) > 22 //число преобразуется в строку, и две строки склеиваются



---
Lesson10 Переменные и значения

Значения - это выражение которое нельзя упростить. 
Часть даных, которая хранится в памяти компьютера. 

System.out.println("2" + 2)

("2" + 2) - выражение, получаемое путем склеивания двух значений
Когда выражение выполняется, то результатом склейки является новое значение.

Литеральные значения - явно описанные в коде программы.
Вычисляемые значения - получаемые в результате вычисления каких-то значений.

Переменная - идентификатор / имя ссылающееся на какое-то значение.
Переменная - ссылка, адрес где хранится объект. 
Переменная - ссылка на объект.

В java все значения участвующие в вычислении должны быть известны.

---
Lesson 11. Типы переменных и значений

Java язык со строгим контролем типов / со строгой типизацией

int В = 8

int указание на тип переменной, в нее можно поместить только тип целых числел

Типы значений
целые числа 
числа с плавающей точкой
строки, заключенные в кавычки


Для них опеределены разные операции , и даже одинаковые операции выполняются по разному


Java для каждого значения значет значение, оно по разному представляется внутри компьютера.

Тип значения не совместим с типом переменной
int B = 8.0 или
int B = "Hello"


Переменная типа int может ссылаться только на значение с целым числом.


double - число двойной точности (с плавающей точкой)

Языки со строгой типизацией - это языки, которые отслеживают несоответствие типов на этапе компиляции, а не на этапе выполнения когда выражение будет реально вычисляться.

---
Lesson12. Среда разработки

Отладчик (Debug) - позволяет выполнять программу последовательно, строчку за строчкой. И во время отладки смотреть какие значения преобретают переменные. Пользуются чтобы понять что происходит во время выполнения программы.

Точка останова

Нажать Step Over чтобы выполнить одну строку. 
Выполнилась та строка, в которой определяется переменная somebody. И эта переменная теперь видна в отладчике. Мы можем посмотреть ее значение. 


---
Lesson13. Функции именованные куски кода

Создадим функцию, которая выполняет строку System.out.println("Hello, world!");  

Чтобы создать функцию, выводящую на экран приветствие по имени, нужно
Объявим переменную 
String somebody = "world";

Переменная somebody определена внутри функции, и значение ей присвается внутри функции.

public static void hello() {
		String somebody = "world";
		System.out.println("Hello, " + somebody + "!");
	}

Для того, чтобы значение можно было менять из вне, нужно ее объявить по другому:
 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world"); 					//место где функкия вызывается, передаем конкретное значение этого параметра 
	}

	public static void hello(String somebody) { //где somebody - параметр, аргумент функции
		System.out.println("Hello, " + somebody + "!");
	}

}

Теперь функция main обращается к функции hello, и передает туда строчку world. Эта строчка присвается, в качестве значения, параметру somebody. Далее это значение используется в коде функции. 

Void - нично, пустота. Функция не возвращает никакого значения. 

public static double area(double b){
		return b * b;
	}

Тип возвращаемого результата, указывается перед именем функции area.



package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		hello("world");
		hello("user");
		hello("Max");

		double l = 5; // переменная#1 - l (за пределами функ main она не существует)
		System.out.println("Площадь квадрата со стороной " + l + " = " + area(l));
	}

	public static void hello(String somebody) {
		System.out.println("Hello, " + somebody + "!");
	}

	public static double area(double l){ //переменная#2 - l (за пределами функ area она не существует) 
		return l * l; 
	}
}

Область видимости для переменной ограничевается телом функции (фигурными скобками, внутри которых она определена).
Переменная#1 и переменная#2 между собой никак не связаны.
Те переменные, которые указаны как параметры функции, тоже считаются относящиеся к ней.

Следующий шаг.

Создаем функцию, которая вычисляет площадь прямоугольника.

public static double area(double len){
		return len * len;
	}

	public static double area(double a, double b) {
		return a * b;
	}
	
Имеется две функции с одниковыми именами. Java их отличает, потому что у них разные параметры. 

Обратимся ко второй area

double a = 	b



--
Lesson14. Классы, объекты, конструкторы

Объект - сложная структура хранения информации (дата), состоит из значений - полей / атрибутов (дд / мм / гггг). Объекты принадлежат  определенному типу.

Объекты могут хранить разные типы данных, поэтому у них может быть разная структура.

Для описания структуры однотипных объектов используется конструкция - класс.

Класс - это описание структуры однотипных объектов. Объекты - экземпляры, представители класса.

Создадим классы, описывающие объекты, площадь для которых мы вычисляем.

Создадим класс типа Квадрат

public class Square { //класс, который описывает структуру объектов, хранящих информацию о квадратах
    public double l; //внутри класса описываем атрибуты, которыми обладает объект этого типа. Квадрат описывается длиной его стороны.
}

Создадим класс типа Прямоугольник

public class Rectangle {
    public double a; //прямоугольник описывается двумя сторонами
    public double b; 
}

После описания классов, можно создавать объекты, которые являются представителями или экземплярами этих классов.

Square s = new Square(); // создаем объект типа Square
s.l = 5; // обращаемся к первой area, устанавливает значение атрибута l равное 5  
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

public static double area(Square s){ //функция area принимает не сторону, а объект типа Квадрат
		return s.l * s.l; //для того чтобы обеспечить доступ к атрибуту этого объекта указываем объект.атрибут 
}

	
	
Когда идет речь об объектах сложной структуры, то передавать в качестве параметра в вызываемую функцию один объект, лучше чем 10-20 параметров, которые описывают атрибуты этого объекта.   

В дальнейщем будем работать с объектами, которые имеют много атрибутов.


Rectangle r = new Rectangle(); // сначала создается объект класса 
	r.a = 4; // потом указываются (заполняются) значения атрибутов**
	r.b = 6;

	
Следующим шагом оптимизируем те части когда, где создаются объекты.
Square s = new Square(); 
	s.l = 5;

Rectangle r = new Rectangle();
	r.a = 4;
	r.b = 6;

	
**Можно сделать другим способом
Внутри класса объявим псевдофункцию - конструктор. 
Конструктор предназначен для того, чтобы заполнить атрибуты нового создаваемого объекта некоторыми значениями, которые передаются в качестве параметра в этот контсруктор. 

Было

public class Square(){
	public double l;
}

Стало

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


Конструктор - это специальная функция, которая имеет имя класса и не имеет возвращаемого значения. Тип возвращаемого значения не указывается. Конструктор может принимать параметры. 
Внутри фигурных скобок необходимо написать код, который инициализирует новый объект. То есть заполняет его атрибуты какими-то значеняими.

Теперь нельзя создать Square s = new Square(); потому что конструктор объектов этого типа требует, чтобы ему были переданы значения параметров.

Было
Square s = new Square(); 
	s.l = 5;
	
 
Стало
Square s = new Square(5); //атрибуты заполняются в конструкторе

 
Ключевое слово this
Это тот объект, который инициализируется в конструкторе.

было

public class Square(){
	public double l;
	
	public Square(double len){
	l = len;	
	}
}


стало

public class Square(){
	public double l;
	
	public Square(double len){
	this.l = len;	
	}
}
 
Когда у нас есть какая то переменная s, которая ссылается на объект, то обращаться к атрибуту мы можем через эту переменную s.l
Square s = new Square(5);
s.l

Но в конструкторе в качестве специальной переменной, которая ссылается на конструируемый объект, выступает ключевое слово this.   

было
public class Square(){
	public double l;
	
	public Square(double len){ //len параметр контсруктора
	this.l = len;	
	}
}



стало 
 public class Square(){
	public double l;
	
	public Square(double l){
	this.l = l;	//так выглядит присваемое значение в атрибут. название аргумента конструктора совпадает с названием атрибута   
	}
}

В первом случае l атрибут, во втором l - переменная, которая объявлена как аргумент функции (переменная, являющаяся аргументом функции). 
Написать l=l нельзя тогда в обоих случах будет использоваться переменная  (double l)
Для того, чтобы присвоить переданное значение именно в атрибут объекта, нужно сослаться на этот объект this.l 
Значение атрибута создаваемого объекта, равно значению параметра переданного в конструктор.


В итоге, получаем
	
package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
	Square s = new Square(5);
	System.out.println("Площадь квадрата со стороной " + s.l + " = " + area(s));

	Rectangle r = new Rectangle(4,6); //длины сторон прямоугольника передаются в качестве параметра в конструктор 
	System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + area(r));
	}


	public static double area(Square s){ // функция принимает не сторону квадрата, а объект типа Квадрат
	return s.l * s.l; // для того чтобы получить доступ к атрибуту объекта, необходимо написать объект.атрибут
	}

	public static double area(Rectangle r) {
	return r.a * r.b;
	}
}


public Square(double l) { 
    this.l = l;
}
	
public Rectangle(double a, double b) {
	this.a = a;
	this.b = b;
	
}
	
---

Lesson15. Методы. Функции объектов.
 	
Функция - именнованный фрагмент кода.
Метод - это функция, связанная (ассоциированная) с каким-то объектом.

Для того, чтобы превратить обычные функции в методы необходимо
1) перенести функцию во внутрь класса, которая описывает соответствующие объекты
2) модификацировать функцию


Переносим функцию в конец класса
Переделка: убираем слово static и параметр функции, добавляем ссылку (this)


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/
 
    }
}


После переделки нужно научится использовать этот метод, вместо той функции из которой он был сделан 

package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {
		
		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); /* s.area())(параметр объекта.название метода) - место где вызывается функция (код вызова).  Обращаемся к методу , который ассоциирован с объектом.
		
		*/
		
		
	}

}

Вместо того, чтобы передавать s в качестве параметра area(s), мы его указываем перед названием s.area(). Вместо обращениния к атрибуту объекта, мы обращаемся к методу, который ассоциирован с этим объектом. 

Когда Java видит конструкцию s.area() она находит функцию area(), которая находится в классе Square, соответствущему этому объекту, и вызывает эту функцию public double area(){return this.l * this.l;}
А тот объект, в котором эта функция (метод) вызывалась, становится доступен через специальный идентификатор this.

Ключевое слово static исчезло, потому что оно используется чтобы помечать фукнции, которые не ассоциированы не с каким объектом. К которым можно обращаться напрямую.  

К методам можно обращаться только указав перед ними объект, в котором этот метод вызывается s.area(). 


package ru.testjava.sandBox;

public class MyFirstProject {

	public static void main(String[] args) {

		Square s = new Square(5);
		System.out.println("Площадь квадрата со стороной " + s.l + " = " + s.area()); // обращаемся к методу, который ассоциирован с объектом

		Rectangle r = new Rectangle(4, 6); // чать когда, где функция вызывается
		System.out.println("Площадь прямоугольника со сторонами " + r.a + " и " + r.b + " = " + r.area());
	}
}


package ru.testjava.sandBox;

public class Square {
    public double l;

    public Square(double l) {
        this.l = l;
    }

    public double area(){ // метод будет ассоциирован с объектом, поэтому передавать объект в качестве параметра не нужно
        return this.l * this.l; /* обращаться к ассоциированному объету, можно через ключевое слово this -
        это ссылка на тот объект, с которым ассоциирован метод*/

    }
}


package ru.testjava.sandBox;

public class Rectangle {

    public double a;
    public double b;

    public Rectangle(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double area() {
        return this.a * this.b; //ссылка на объект доступно через ключевое слово this. ссылка на тот объект, в котором этот метод вызван
    }
}

В двух классах Square и Rectangle находятся функции с одинаковыми именами и без параметров area(). Эти функции между собой не конфликтуют, потому что они находятся в разных классах и Java легко определяет какую из этих функций следует вызывать. 

Если вызывается метод в объекте s.area(), который является экземляром класса Square, значит будет выполняться функция с именем area(), которая находится в классе Square.
Если обращаемся к методу объекта, который имеет тип (является представилем класса) Rectangle, значит будет выполняться функция находящаяся в классе Rectangle.


---

Занятие 2.

Lesson16.
Что такое автотесты?

Стек автотестирования - общий набор инструментов, которые задействованы при создании автотестов.

Стек автотестирования состоит:

6. Сервер непрерывной интеграции - для автозапуска тестов из хранилища

	6.1 Хранилище - для хранения и распостранения 
	6.2 Среда разработки - для написания, отлаживания, запуска тестов по отдельности 


5. Сборщик - может использоваться для компиляции и запуска тестов. Удобно когда нужно запустить все тесты сразу.

4. Фреймворк - для запуска тестов. Его задача найти, запустить тесты и сгенерировать отчет. 

3. Тесты - написаны на языке програмирования, должны взаимодействовать с ТС. 

2. Драйверы тестируемой системы - инструменты, которые помогают взаимодействовать с ТС по сети или через пользовательский интерфейс (написанной на другом языке?)

1. Тестируемая система (ТС)


Взаимодействие на прямую означает через программый интерфейс.

Программа, в рамках которой запускаются и работают тесты состоит из фреймворка, тестов, драйвера.
При выполнении тестов, основной запускаемой программой является фреймворк.

---
Lesson17. Gradle подключаем зависимости

Доработаем проект для использования автотестов функций area()
Подлючаем доп зависимость от тестового фреймворка TestNG


Готовый к употреблению, скомпилированный код для языка Java распостраняется в виде библиотек.
Физически они представляют собой архивы, в формате .jar
Технически это обычный zip архив который имеет специфическую структуру, использует расширение .jar

Сайт для поиска библиотек в репозитории сборщика
https://search.maven.org

Находим TestNG
Копируем текст в конфигурационный файл сборщика
Указываем зависимость в специальном блоке "декларация зависимости"


dependencies {
    implementation 'org.testng:testng:7.0.0-beta1'

}

Перед декларацией указываем какой репозиторий следует использовать
repositories {
    mavenCentral()
}

Через некоторое время библиотеки подключатся.

После установки библеотек, рекомендуется их проиндексировать
File > Settings > Build, Executiosn > Build tools > Maven > Repositories

Указывается репозитории, которые используются сборком
локальный 
удаленный

При отсутствии библиотеки в локальном репозитории, среда разработки обращается к удаленному репозиторию. Чтобы было быстрее искать, IJ загружает список всех имеющихся библиотек и индексируюет его.

Загрузка библиотек из удаленого репозитория в локальный.
Эта автоматическая сихронизация модуля в среде разработки с конфигурационным файлом build.gradle происходит благодаря тому, что во время импорта модуля была поставлена галочка Auto Import. 
Но автосинхронизация работает не всегда. Список зависимостей обновляется не всегда , несмотря на внесение изменений в конфигурационный файл. 

Выполнение синхронизации в ручную 
View > Tool Windows > Gradle > Refresh  

Документация сборщика для того, чтобы копировать фрагменты конфигурационного файла  
https://docs.gradle.org/current/userguide/building_java_projects.html

---

Lesson18. Фреймворк для запуска тестов TestNG


Поместить первый тест в поддиректорию test > java 
Создать пакет ru.testjava.sandBox
В нем создать класс SquareTests. В Java любой код оформляется в виде классов.

Метод main делать не нужно, потому что запускается тестовый фрейворк. Он находит все тесты, выполняет и генерирует отчет.
В тестовом классе нужно написать методы, которые буду являться тестами.
Каждый метод в отчете будет представлен как отдельный тест.

package ru.testjava.sandBox;

import org.testng.Assert;
import org.testng.annotations.Test;

public class SquareTests {

  @Test
  public void testArea(){
    Square s = new Square(5);
  }
}

В тестовом методе нет параметров и возвращаемого результата. О результатах своей работы, он сообщает тестовому фреймворку особым образом.

Создаем новый квадрат
Square s = new Square(5);
Проверяем площадь
assert s.area() == 25; // ключевое слово assert - логическое выражение "утверждение". Знак == для сравнения величин, а = для присваивания

Нужно пометить метод, чтобы фреймворк понял что это тест.
Перед методом нужно написать аннотацию  
Аннотация - это особый класс, которые используются как псевдо комментарии 
Не создаем объекты этого типа, просто указываем название этого класса перед чем нибудь  
Фреймворк по аннатациям находит нужный метод, это для него сигнал что это тест и его нужно запустить


Можно писать короткие имена классов
@Test //Enter - автопродолжения

Появляется конструкция, чтобы их импортировать 
import org.testng.annotations.Test; //полное название класса

или писать название классов полностью
@org.testng.annotations.Test //тогда конструкция import не нужная

После запуска теста появляется отчет 
Default Suite
Total tests run: 1, Failures: 0, Skips: 0

Но в случае упавшего теста AssertionError, не видно результата выполнения метода area().


Для отображения подробного сообщение об ошибке (expected, actual result) используется вспомогательный класс Assert

import org.testng.Assert;

Assert.assertEquals(s.area(),25.0); //начинаем писать Asserе. и включается механизм автопродолжения + Enter

Сравниваем значение площади, которое вычислено и ожидаемое значение


К функции assertEquals() можно обращаться на прямую, так как в ее описании есть ключевое слово static (подсказка ЛКП + Ctrl)
То есть чтобы воспользоваться этой функцией, не нужно создавать какой-то объект. 

Так как функция находится в классе Assert, а не в текущем классе SquareTests, значит перед ней нужно указать в качестве префикса имя класса Assert.assertEquals() Имякласса.функция




package ru.testjava.sandBox;

import org.testng.Assert; //класс Assert импорт добавляется автоматически 
import org.testng.annotations.Test; //класс Test

public class SquareTests { 

  @Test
  public void testArea(){
    Square s = new Square(5);
    Assert.assertEquals(s.area(),25) ;


  }
}


Результат упавшего теста
java.lang.AssertionError: expected [25] but found [25.0]
Expected :25
Actual   :25.0


Тестовый фремворк контролирует совпадение типов данных
Если Expected 25, а Actual 25.0, то тест считается упавшим.

---
Lesson19. Среда разработки

Показать варианты исправления ошибки Alt + Enter

Список продолжения Ctrl + Space

---
Lesson20. Selenium драйвер для браузеров

Скачать пакет
https://www.apachefriends.org/ru/download_success.html

Инструкция по установки
https://selenium2.ru/articles/136-installing-xampp.html


Установка приложения addressbook на сервер XAMPP

Распаковать addressbook в папку
c:\xampp\htdocs\  

Подготовка базы данных
MySQL > Admin (http://localhost/phpmyadmin/)

Create New database > addressbook

Создать структуру базы данных (импортировать)
Import > addressbook.sql

http://localhost/addressbook/
admin / secret

Если вход выполнился успешно, значит логин / пароль прочитались из базы данных. Приложение базу данных видит.


Начнем с подготовки нового модуля
Создаем подкаталог (модуль) java_test > addressbook-web-tests
Помещаем туда самое главное -  конфигурационный файл сборщика, потом сможем импортировать его в среду разработки



Перекладываем конфиг файл
build.gradle
и запускатель 
подкаталог gradle 
и запускаемые файлы для платформ win и linux
gradlew
gradlew.bat


Удаляем 
apply plugin: 'application'
mainClassName = "ru.testjava.sandBox.MyFirstProject"
	
apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.testng:testng:6.14.3'
}

Скачиваем chromedriver.exe 
https://sites.google.com/a/chromium.org/chromedriver/downloads

Сохраняем в папку
c:\Tools\chromedriver_win32\



Устанавливаем Katalon Recorder
Записываем процесс создания группы http://localhost/addressbook/group.php
Сохраняем запись в формате java-testng.class и помещаем ее в каталог с нашим тестом

Открываем сгенерированный код в среде разработки
Добавляем строку, указываем путь с ChromeDriver и 
    System.setProperty("webdriver.chrome.driver", "c:\Tools\chromedriver_win32\chromedriver.exe");
    driver = new ChromeDriver();

Добавляем в конфиг файл две зависимости
    implementation 'com.katalon:com.katalon.platform.parent:1.0.1'
    implementation 'org.seleniumhq.selenium:selenium-java:3.141.59'


---
Lesson21. Фикстуры инициализация и зачистка

Исправим ошибку в сгенерированном коде тестового метода @Test (аннотация Тест)

имя должно быть отличное от имени класса, и начинаться с маленькой буквы

Кроме тестового метода @Test сгенерировались два вспомогательных (пометки/подсказки для тестового фрейворка)
BeforeClass //метод инициализации фикстура, единственное место для указания используемого драйвера - браузера
AfterClass //метод завершения фикстура


Зачистка
Если код дублируется, то его нужно постараться выделить в отдельную функцию. Его можно использовать повторно, обращаясь к этому методу. В случае с тестовым фрейворком, он автоматически вызывает методы BeforClass / AfterClass перед каждым запуском тестового метода.

Фикструр - тестовая ситуация, тест зажимается между двумя методами Before - After. 


Модифицируем код 
Действия для авторизации не являются частью теста создания группы, поэтому вырезаем и переносим кусок кода в метод инициализации фикстура @Before.

---
Lesson22. Рефакторинг

Правила безопасного преобразования кода. Структура кода меняется, но функциональность остается неизменной.

С помощью механизма рефакторинга научимся выделять вспомогательные методы.

Рекодер записывает сценарий, который трудно читается.
Для удобства пользования мы дадим имя фрагменту кода, сделаем именнованный фрагмент кода. Для этого нужно превратить его в функцию и в нужное время к этой функции обращаться.

Выделяем фрагмент кода для превращения в именнованную функцию
Refactor > Extract > Method (Ctrl + Alt + M)

Фрагмент кода получил собственное имя - там выволняется логин

@BeforeClass
...
login(); // вызов созданного метода (место, в котором к этому фрагменту нужно обратиться)

Почему метода, а не обычной функции?
Внутри метода используется переменная driver, которая является атрибутом объекта типа GroupCreationTests.  

private void login() {
    driver.findElement(By.name(user)).click();
    driver.findElement(By.name(user)).clear();
	
	...
}

Тестовый фрейворк сначала создает объект класса 
Потом выполняет метод 
setUp(){
	инициалируется атрибут объекта driver = new ChromeDriver();
}
Когда вызывается другой метод login() в том же самом объекте, он может этим атрибутом пользоваться.
Также нужно поступить с тестовым методом, выделить из него вспомогательные фукнции.

Первый механизм рефакторинга - это выделение вспомогательных методов.

Следующий шаг

Делаем метод login() параметрализованным, чтобы имя пользователя и пароль передовались внутрь метода в качестве параметров. 

Выделяем значение, которое необходимо превратить в передаваемый параметр
Refactor > Extract > Parameter (Ctrl + Alt + P)
Даем имя username
   

login("admin"); //В точке вызова передается конкретное значение, которое подставляется в эту переменную параметр и используется в методе login
private void login(String username){
	driver.findElement(By.name(user)).sendKeys(username);
}


Тестовый метод создает группу с какими-то свойствами name, header, footer
Значение этих свойств явно прописаны в коде метода
private void fillGroupForm() {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys("test1");
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys("test2");
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys("test3");
}

Было бы более логично передавать их в качестве параметров, чтобы функция fillGroupForm стала универсальной. Ее можно было бы использовать для создания групп с разными параметрами, то есть заполнять форму разными данными. Конкретные значения передавались бы из @Test.

private void fillGroupForm(String name, String header, String footer) {
    driver.findElement(By.name("group_name")).sendKeys(name);
    driver.findElement(By.name("group_header")).click();
    driver.findElement(By.name("group_header")).clear();
    driver.findElement(By.name("group_header")).sendKeys(header);
    driver.findElement(By.name("group_footer")).clear();
    driver.findElement(By.name("group_footer")).sendKeys(footer);
  }


Создаем новый контакт
У формы контакта много параметров
Как превратить много параметров в мало?

Вместо того, чтобы передавать много отдельных значений, их можно объединить в один объект, который будет иметь много атрибутов. То есть создать вспомогательный класс, который описывает объект типа Group. Объекты этого типа имеют набор атрибутов.

!В метод будет передаваться один объект
ПКМ на fillGroupForm
Refactor > Extract > Parameter Object 

Указываем имя классу, который будет описывать совокупность значений GroupData
Отмечаем те значения которые должны быть объеденены
Default valuse for parameter -  Leave blank


Рефакторинг закончен

Теперь метод принимает один объект типа GroupData
public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

Это объект 

public class GroupData {
  private final String name; //три атрибута
  private final String header;
  private final String footer;

  //конструктор, который позволяет проинициализировать объект какими то значениями
  public GroupData(String name, String header, String footer) { 
    this.name = name;
    this.header = header;
    this.footer = footer;
  }

  //методы, которые возвращают эти атрибуты
  public String getName() {
    return name;
  }

  public String getHeader() {
    return header;
  }

  public String getFooter() {
    return footer;
  }
}  
 


А в @Test при вызове fillGroupForm создается новый объект, атрибуты которого заполняются конкретными значениями. 
Эти значения потом используются в методе fillGroupForm
groupData.getName()
groupData.getHeader()
groupData.getFooter()


@Test
public void testGroupCreation() throws Exception {
returnToGroupPage("groups");
initGroupCreation("new");
fillGroupForm(new GroupData("test1", "test2", "test3")); //данные для передачи во вспомогательные методы
...
}



private void fillGroupForm(GroupData groupData) {
driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
driver.findElement(By.name("group_header")).sendKeys(groupData.getHeader());
driver.findElement(By.name("group_footer")).sendKeys(groupData.getFooter());
...	
}




	
---
Lesson23. Наследование общий базовый класс

Поместим тесты в разные классы
- создание группы
- удаление группы
Куда поместить вспомогательные функции, чтобы они были доступны в нескольких классах?

Начнем с создания теста для удаления групп. Запишем его рекодером.
Запись теста экспортируем в язык программирования java+testng
Помещаем сгенерированный код в наш пакет
Исправляем имя пакету

Когда создается объект типа GroupDeletionTests, то в этом объекте нельзя вызывать функции, находящиеся в другом классе. Они с этим объектом никак не ассоциированы. 

Наследование - механизм, позволяющий сделать общее пространство для нескольких классов. Туда можно поместить методы и атрибуты. Класс наследник - это тот класс, который расширяет базовый.

Чтобы воспользоваться механизмом наследования, нужно создать дополнительный класс в который будут помещены общие методы. Класс GroupCreationTests будет расширять этот новый класс. 

public class GroupDeletionTests extends TestBase {}
 
Создадим общий (базовый) класс TestBase 
Поместим туда методы, которые хотим сделать общими
GroupDeletionTests > Refactor > Pull Members Up 
Отмечаем все, кроме test

public class GroupCreationTests extends TestBase { //тестовый класс расширяет (является наследником) базовый класс TestBase 
}
С технической точки зрения это означает, что все методы, которые описаны в базовом классе, становятся членами класса наследника. 
Когда создается объект GroupCreationTests, то с ним ассоциируются все атрибуты и методы, которые находятся и в базовом классе. 

Переходим ко второму тесту GroupDeletionTests.
Для того, чтобы воспользоваться теми методами, которые помещены в класс TestBase нужно написать, что класс GroupDeletionTests расширяет базовый класс TestBase.
Удаляем лишнее, то что уже есть в базовом классе.

Чистим тестовый метод testGroupDeletion()
-удаляем строки, где выполняется вход в систему. Потому что эти действия в методе, с аннотацией @BeforeMethod
К моменту начала выполнения тестового метода все будет уже готово.
-заменяем строки на уже существующие методы
-новые методы преобразуем во вспомогательные функции Ctrl+Alt+M // покабез параметров?


Созданные вспомогательные функции можно перенести в базовый класс. Меняем модификатор прав доступа.
GroupDeletionTests > Refactor > Pull Members Up 


Модификаторы видимости 
public - класс/атрибут/метод доступны откуда угодно
private - доступно из методов, которые находятся в том же самом классе
protected - доступно из методов того же самого класса и из классов наследников

protected void deleteSelectedGroups(String delete) {}

К ним можно обращаться не только из методов, находящихся в том же самом классе, но и из тех методов, которые находятся в классе наследников. 


Code > Reformat Code 
Code > Optimize Inports


Класс наследник содержит то, что описано в нем, а также то что содержится в базовом классе.
Если создается объет, то с ним ассоциированы не только не методы/атрибуты, которые описаны в нем самом, но и те методы/атрибуты, которые описаны в базовом классе.





---
Lesson24. Делегирование вместо наследования

В разных классах могут возникать одинаковые вспомогательные фукнции. Для того, чтобы избежать дублирования кода мы используем
общий базовый класс, в который помещены вспомогательные функции. Они могут использоваться в разных тестовых классах. Но это ведет к новой проблеме. По мере того, как количество тестов увеличивается - количество вспомогательных методов тоже растет. Общий базовый класс становится слишком громоздким.       

1. Большой класс трудно читать и понимать 
2. Потенциальные конфликты при использовании вспомогательных методов несколькими пользователями

Предлагается решение, раскидать вспомогательные функции по дополнительным узкоспециализированным классам. 

1 этап
Из класса TestBase перенесем все вспомогательные фукнции в новый вспомогательный класс ApplicationManager
Вместо наследования будет работать механизм делегирования

2 этап
Новый класс ApplicationManager раздробим на более мелкие узко специализированные классы.


1 этап 
1 шаг
Временно сделаем еще один базовый класс и перенесем функции вверх. А потом передвинем сверху в бок.
После всех преобразований в классе TestBase должно остаться две функции setUp() и tearDown(). 
В этих функциях выполняется много действий, сначала надо вынести эти действия во вспомогательные фукции, которые потом вместе с остальными переедут в новый вспомогательный класс. Тем самым TestBase разгрузится практически полностью.
 

Выделяем содержимое метода setUp() {то что в скобках} Ctrl+Alt+M делаем вспомогательный метод init()
Тоже с tearDown(), новый вспомогательный метод называем stop()

Временно создаем базовый класс ApplicationManager
TestBase expects ApplicationManager

Перемещаем в новый класс все кроме setUp() и tearDown()

И применяем еще один рефактор 
Refactor > Replace Inheritance with Delegations

Заменяем наследование на делегирование. При этом будет создано новое поле (атрибут) назовем его app. Никакие галочки ставить не нужно.

Делегирование - механизм, при котором объекту вспомогательного класса делегируются определенные действия, которые он должен выполнить.


package ru.testjava.addressbook;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
public class TestBase { //исчезла ссылка на расширение класса ApplicationManager, вместо этого
  protected final ApplicationManager app = new ApplicationManager(); // создается ссылка на новый объект типа ApplicationManager
  @BeforeClass(alwaysRun = true)
  public void setUp()  {
    app.init(); /* те вызовы , которые выполнялись в текущем классе (как бы this.init())
    теперь вместо этого вызываются методы, находящиеся в объекте типа ApplicationManager */
  }
  @AfterClass(alwaysRun = true)
  public void tearDown() {
    app.stop();
  }
}

Также произошли изменения в тестах 

package ru.testjava.addressbook;
import org.testng.annotations.Test;
public class GroupCreationTests extends TestBase {
  @Test
  public void testGroupCreation() {
    app.gotoGroupPage("groups"); //просим объект типа ApplicationManager, чтобы он выполнил какое-то действие (обращаемся к нему)
    app.initGroupCreation("new");
    app.fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.submitGroupCreation("submit");
    app.returnToGroupPage("group page");
  }
}

Все вспомогательные фукнции теперь находятся в классе ApplicationManager

Фактически мы разделили код на два слоя
Первый слой - логика тестов. Включает в себя тесты (тестовые классы), которые содержат тестовые методы, сценарии короткие и понятные. Класс Test Base перед каждым тестовым методом инициализирует объект типа ApplicationManager, а после того как метод отработал останавливает его, разрушает.
Второй слой - логика (код) взаимодействия с тестируемой системой.  

Разделим свои физически, разнесем из по разным пакетам

protected - пометка, которая разрешает использовать этот метод не только в классах наслениках, но и в классах находящихся в том же самом пакете.   

Если мы собираемся перенести метод в другой пакет, нужно сделать методы public

ApplicationManager > appmanager
..Tests > tests
GroupData > model

Класс GroupData используется везде. Для того, чтобы обозначить его предназначение поместим его в model.  
Он представляет собой модель какого-то объекта предметной области. 




---

Lesson25. Расщепление и специализация

Раздробим класс ApplicationManager (АМ) на несколько более простых классов и раскидаем по ним вспомогательные функции. 

Для этого используем механизм делегирования. Класс ApplicationManager будет делегировать какие-то действия своим помощникам. 
Создавать помощников мы будем как в предыдущем уроке. Создается временный базовый класс, в который переносятся какие то методы. Потом наследование заменяется на делегирование.

Самое сложное это определить какие вспомогательные классы нам нужны, и какие методы куда переносить. 
Проще всего перенести те методы, которые используются при работе с группами initGroupCreation, initGroupForm, returnToGroupPage 

public class ApplicationManager extends GroupHelper //создаем новый базовый класс
 
Переносим в новый класс методы, связанные с группами 
Заменяем наследование делегированием 
ПКМ ApplicationManager
Refactor > Replace Inheritance With Delegations

Среда сообщает, что после этого действия в тестах возникнут проблемы. Они не смогут получить доступ к перенесенным методам. 
Нужно поставить галочку Generate getter for delegated component**

**для него генерируется вспомогательный метод, дающий доступ к этому полю

Тестовые класса изменились, например GroupCreationTests


  @Test
  public void testGroupCreation() {
	app.gotoGroupPage(); // если АМ может выполнять действие сам
    app.getGroupHelper().gotoGroupPage("groups"); /* для других действий происходит делегирование в два этапа 
	Сначала происходит обращение к АМ, чтобы он дал доступ к помошнику по работе с группами GroupHelper, и уже этому помощнику делегируется выполнение настоящего действия , где происходит взаимодействие с тестируемой системой gotoGroupPage("groups") 
	*/
	}


Есть одно нежелательное изменение в АМ

Ссылка на драйвер переехала в groupHelper 
groupHelper.driver = new WebDriver();

Это неправильно, нужно вернуть ее обратно в ApplicationManager. Потому что она должна быть общей, ей хочет пользоваться  ApplicationManager и другие помощники тоже хотят работать с этой ссылкой.
Вернуть ее обратно средствами рефакторинга не получится. Нужно перенести в ручную.

Отправляемся в GroupHelper 
Копируем от туда ссылку 
WebDriver driver;
Вставляем в АМ, в начало выражения
Метод инициализации init() будет инициализировать именно эту ссылку. Атрибут который находится в классе AM
удаляем префикс groupHelper.
Но тогда возникает вопрос. Как GroupHepler получит эту ссылку на драйвер?
Нужно ее передать в конструктор, но не в private final GroupHelper = new GroupHelper(); а после того как выполнена инициализация (после  строк с атрибутом driver.)
То естьGroupHeldep должен конструироваться внутри метода init()
Ссылка на драйвер должна передаваться в качества параметра в контструктор
groupHelper = new GroupHelper(driver);
И этот конструктор необходимо создать Alt+Enter

  public GroupHelper(WebDriver driver) { //то значение, которое передано в качестве параметра конструктора
    this.driver = driver; //необходимо присвоить в атрибут (поле) класса GroupHelper
  }
Тем самым класс GroupHelper получит доступ к драйверу, который инициализирован в AM и передан помощнику. 
  
Но остались проблемы в АМ


private final GroupHelper groupHelper = new GroupHelder(); //не нужна инициализация = new GroupHelder()
private final GroupHelper groupHelper; //его нужно только декларировать

final - пометка означает, что в это можно присвоить значение только один раз. Нас это не устраивает потому что метод init() может вызываться многократно. Убираем пометку. 

private GroupHelper groupHelper;

Остались проблемы в других вспомогательных методах. Там тоже используется ссылка, которая находится внутри groupHelper. Нужно от этого избавиться. Чтобы определить где именно есть эта нежелательная ссылка, нужно в GroupHelper объявить атрибут, в котором он хранит свою личную ссылку на драйвер, private

> GroupHelper.java

private WebDriver driver;

В АМ будут выделены те кто хочет получить доступ к атрибуту, находящимуся внутри GroupHelper. Удаляем ссылки.
Пусть они пользуются ссылкой, которая находится внтури AM.


Для закрепления проделаем тоже самое с методом gotoGroupPage

Вынесем его во вспомогательный класс - NavigationHelper

public class ApplicationManager extends NavigationHelper; // создаем базовый класс  Alt+Enter

переносим в него нужную функцию gotoGroupPage + driver

Заменяем наследование на делегирование


Обратно переносим ссылку на драйвер

чтобы NavigationHelper получил доступ к этой ссылке передаем ее в качестве параметра в конструктор

navigationHelper = new navigationHelper(driver);

просим среду разработки чтобы она создала этот конструктор 

присваемваем переданное значение 

public class NavigationHelper {
  private WebDriver driver; //для того чтобы к нему никто не мог получить доступ  

  public NavigationHelper(WebDriver driver) {
    this.driver = driver; //присваеваем переданное значение в поле 
  }

возвращаемся в сломавшийся и подкрашенный АМ

удаляем все неправильные использования драйвера

удаляем модификатор final и инициализацию = new navigationHelper(); //потому что эта инициализация выполняется в методе init() после создания драйвера 

navigationHelper = new NavigationHelper(driver); 



Переносим метод login() во вспомогательный класс другим способом, без рефакторирга


appmanager > Create New Class > SessionHelper


сделаем в АМ ссылку на SessionHelper


private sessionHelper sessionHelper;


инициализируем его в методе init()

sessionHelper = new SessionHelper(driver); //поскольку такого конструктора нет, сделаем его

public class SessionHelper {
  private WebDriver driver;

  public SessionHelper(WebDriver driver) { //driver Alt+Enter > присвоить значение параметра конструктора в какое-то поле 
    this.driver = driver; //поле создается автоматически 
  }

Вырезаем метод login() и вставляем в класс SessionHelper

Добавить все необходимые импорты, поменять методы на public 

Внутри AM обращаться к нему через помощникам

sessionHelper.login("admin", "secret") //вызывается метод в помощнике, ему делиируются какие-то действия

---
Lesson26 Наследование общий базовый класс

Для того чтобы новые тесты было проще добавлять, и без использования рекодера, нужно доработать код классов помощников

Код заполнения поля ввода 

driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());

Alt+Ctrl+M

public void fillGroupForm(GroupData groupData) {
    type(groupData); 
}
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

В результате рефакторинга параметр у этого метода получился не очень удачный. Логичнее в этот метод передавать 2 других параметра: локатор элемента, текст который нужноввести в поля ввода. 

было
private void type(GroupData groupData) {
    driver.findElement(By.name("group_name")).click();
    driver.findElement(By.name("group_name")).clear();
    driver.findElement(By.name("group_name")).sendKeys(groupData.getName());
  }

стало
 private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }
  
  
При этом среда разработки сама догадалась, что параметр GroupData больше не используется и автоматически его удалила. Кроме того, она заметила такие места, где повторяется фрагмент кода и предложила там тоже сделать замену на вызов нового созданного метода. 



  public void fillGroupForm(GroupData groupData) {
    type(By.name("group_name"), groupData.getName());
    type(By.name("group_header"), groupData.getHeader());
    type(By.name("group_footer"),groupData.getFooter());
  }

  private void type(By locator, String text) {
    driver.findElement(locator).click();
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }

В результате всех преобразований дублирование кода сократилось.

Тоже с методом клик

 public void submitGroupCreation() {
    driver.findElement(By.name("submit")).click();
  }
  
Выделяем кусок кода, который хотим выделить во вспомогательный метод
Alt+Ctrl+M

  public void submitGroupCreation() {
    click();
  }
  }}}

  
Делаем его параметрализованным 

public void submitGroupCreation() {
	click(By.name("submit"));
}
private void click(By locator) {
	driver.findElement(locator).click();
}

Среда замечает, что есть 5 похожим фрагментов и их тоже стоит заменить

Тоже самое нужно проделать в другом классе помощнике - SessionHelper
Но мы уже сделали подходящие методы, необходимо только предоставить возможность использовать их.

Здесь нам поможет механизм наследования, который даст возможность предоставить общее пространство обобществить какие то методы между двумя классами. Возвращаемся в GroupHelper, делаем базовый класс и помещаем в него методы click и type + ссылка на драйвер

GroupHelper extends HelperBase; //базовый класс для всех помощников 

Раньше в контсрукторе просто присваивалось значение в поле класса, а сейчас появился вызов странного метода 
  public GroupHelper(WebDriver driver) {
    super(driver); //это обращение к конструктору базового класса
  }
В базовом классе создан конструктор, который принимает параметр в качестве ссылке на драйвер
  public HelperBase(WebDriver driver) {
    this.driver = driver;
  }



public void login(String username, String password) {
    driver.findElement(By.name("user")).click();
    driver.findElement(By.name("user")).clear();
    driver.findElement(By.name("user")).sendKeys(username);
    driver.findElement(By.name("pass")).clear();
    driver.findElement(By.name("pass")).sendKeys(password);
    driver.findElement(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]")).click();
  }


  public void login(String username, String password) {
    type(By.name("user"), username);
    type(By.name("pass"), password);
    click(By.xpath("(.//*[normalize-space(text()) and normalize-space(.)='Password:'])[1]/following::input[2]"));
  }


Метод может пользоваться теми данными, которые храняться в объекте этого класса.

---

Lesson27. Новый тест без использования рекодера

Добавим тест в котором проверяется возможность модификации какой то существующей группы


package ru.testjava.addressbook.tests;

import org.testng.annotations.Test;
import ru.testjava.addressbook.modul.GroupData;

public class GroupModificationTests extends TestBase{

  GroupModificationTests() {

  }

  @Test
  public void testGroupModification() {
    app.getNavigationHelper().gotoGroupPage();
    app.getGroupHelper().selectGroup();
    app.getGroupHelper().initGroupModification(); //новый
    app.getGroupHelper().fillGroupForm(new GroupData("test1", "test2", "test3"));
    app.getGroupHelper().submitGroupModification();//новый
    app.getGroupHelper().returnToGroupPage();
  }
}

Новые методы создаем в классе GroupHelper

---
Занятие 3 Управление потоком выполнения кода, ветвление
Lesson28. Блок if / else
Решение квадратного уравнения
D = b^2 - 4ac

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения


double d = b*b - 4*a*c; 

Будем анализировать дескреминант, чтобы присвоить значение в атрибут n

 

if (d > 0) { //если условие в скобках справедливо, то выполняется блок в фигурных скобках
  n = 2;
} else { //если условие в скобках не справедливо
  if (d == 0) { //вложенная конструкция if
	n = 1;
  } else {
	n = 0;
  }
}


---
Lesson29. Проверки различные формы
Конструкция if, служащая для проверки условий может принимать три формы

Полная форма с блоком else
Сокращеная форма без блока else
Свернутая форма - альтернативное представление для нескольких вложенных конструкций if

Если в конструкции if внутри фигурных скобок находится одно действие, то фигурные скобки можно не ставить.

D < 0 - нет решений
D = 0 - одно решение
D > 0 - два решения

Тройных развилок нет, поэтому это реализуется через вложенные конструкции 


Визульно равноправные, а не вложенные. Это свернутая форма которая по сути эквивалентна вложенной форме.
if (d > 0) { 
  n = 2;
} else if (d == 0) { 
n = 1;
} else {
n = 0;
}

Если условия взаимоисключающие, то можно записать по другому. Но тогда будут выполняться все проверки, то есть будут лишнии проверки. При наличии блока else лишних проверок нет.

if (d > 0) { 
  n = 2;
} 
  
if (d == 0) { 
n = 1;
} 

if {d < 0) {
n = 0;
}
}

Внутри блока else находится одна единственная конструкция if
else { 
  if (b == 0) {
	if (c == 0) {
	  n = -1;
	} else {
	  n = 0;
	}
  } else {
	n = 1;
  }

}

стало
 if (a != 0) { //алгоритм решения квадратного уравнения
      if (d > 0) { //используется конструкция типа свертка* 
        n = 2;
      } else if (d == 0) {
        n = 1;
      } else {
        n = 0;
      }

    } else if (b != 0) { //алгоритм решения линейного, вырожденного уравнения //используется конструкция типа свертка
      n = 1;

    } else if (c != 0) {
      n = 0;

    } else {
      n = -1;
    }

С логической точки зрения это разные свертки 
в первой конструкции равноправные, взаимоисключающие варианты развития событий D < 0 или D = 0 или D > 0. Это три разные ветки.
во второй конструкции остается каскад проверок - они по смыслу вложенные, но написаны в свернутой форме.

При написании кода пробуйте эксперементируйте, меняйте проверяемые условия, переставляйте блоки местами, стараясь добиться максимальной понятности того, что проверяется и когда что должно выполняться.



---
Lesson30. Браузер на выбор

public class ApplicationManager {
  private WebDriver driver; //тип переменной интерфейс WebDriver - это проявление механизма наследования
 
public void init() {
    System.setProperty("webdriver.chrome.driver", "c:\\Tools\\chromedriver.exe");
    driver = new ChromeDriver(); //создается экземпляр класса ChromeDriver

	}	
	
В интерфейсе методы только декларируются, объявляются имена и типы параметров возвращаемого значения. А конкретная реализация этих методов должна быть написана в классе наследнике.	
Разные классы могут реализовывать один и тот же интерфейс, но по разному 	
	
Выбор типа браузера нужно указать при инициализации в TestBase. Поэтому тип браузера нужно следать параметром.

Способ 1
Можно сделать параметром метода init()	
	
Тогда в TestBase при вызове этого метода нужно указать тип браузера
@BeforeMethod
public void setUp()
app.init(CHROME)

Способ 2
Можно сделать тип бразузера параметром конструктора AM

public class TestBase {
protected final ApplicationManager app = new ApplicationManager(BrowserType.CHROME);
...
}

Создаем конструктор
public ApplicationManager(String browser) {

    this.browser = browser; //значение параметра сохраняем в поле
  }
	
Убираем локальную переменную String browser = BrowserType.CHROME; вместо нее будет использоваться атрибут объекта АМ, тот который был установлен при конструировании этого объекта.
public void init() {
    String browser = BrowserType.CHROME;
    if (browser == BrowserType.CHROME) {	
	}	

public void init() {
    if (browser == BrowserType.CHROME) {
      driver = new ChromeDriver(); 
    } else if (browser == BrowserType.FIREFOX) {
      driver = new FirefoxDriver();
    } else if (browser == BrowserType.IE) {
      driver = new InternetExplorerDriver();
    }
}

Драйверы помещены в папку c:\Tools\
В переменную окружения PATH добавлен путь c:\Tools\ 
	
http://software-testing.ru/forum/index.php?/topic/33657-udaetsia-podkliuchit-chromedriver-tolko-cherez-systemsetproperty/?p=154278

1) Можно положить исполняемый файл chromedriver в одну из директорий, которые упоминаются в переменной окружения PATH. Если Вы попытались это сделать, но не работает -- вероятно, неправильно настроили переменную, либо не перезапустили приложение, которое должно увидеть изменённое значение переменной. В операционной системе Windows можно просто положить исполняемый файл в c:\windows\system32, эта директория по умолчанию включена в PATH (если только вы её оттуда сами не удалили)

 

2) Можно положить исполняемый файл chromedriver в текущую директорию. То есть в ту директорию, которая будет текущей, когда вы будете запускать тесты. Скорее всего это корневая директория проекта.



---
Lesson31. Сравнение Equals	
	
Знак сравнения == нужно использовать только для чисел (двойной знак равенства)
Во всех остальных случаях, для объектов нужно использовать метод Equals	
	
Переменная - ссылка на объект
Когда вы объявляете переменную ссылочного типа, на самом деле вы создаете ссылку на объект данного типа. Рассмотрим следующий код для объявления переменной типа int:
int x;
x = 10;
В этом примере переменная x имеет тип int и Java инициализирует её как 0. Когда вы присвоите переменной значение 10 (вторая строка), это значение сохранится в ячейке памяти, на которую ссылается x.


Когда мы присваивали во вторую переменную значение, которое хранится в первой переменной, новый объект не создавался. 
Скопировалась ссылка на уже существующий объект
String s1 = "firefox";
String s2 = s1; //есть 2 переменных ссылающееся на один и тот же объект


public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = s1; 

System.out.println(s1 == s2); //true сравнение ссылок, проверяется идентичность объектов 
System.out.println(s1.equals(s2)); //true сравнение содержимого объектов
}
}
	
	
public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = new String(s1);  // в памяти возник другой объект

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}	
	
В памяти возник другой объект, который логически содержит такой же текст, но физически это другой объект. Он хранится в другом месте в памяти, имеет другой адрес.

Когда сравниваются две ссылки s1 == s2 результат отрицательный.
Метод equals() сравнивает не ссылки, а содержимое объектов. Это логические сравнение, а не физическое. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox";
String s2 = "firefox"; // не происходит копирование ссылки. В переменную s2 присвается значение, совершенно не зависимо от того что было раньше присвоено в переменную s1  

System.out.println(s1 == s2); //true java считает что переменные ссылаются на один и тот же объект 
System.out.println(s1.equals(s2)); //true
}}

Компилятор оптимизирует код. Все переменные, которые ссылаются на одну и туже литеральную строку, будут ссылаться на один и тотже физический объект. 
String s2 = "fire"+"fox";
System.out.println(s1 == s2); //true

Компилятор догадывается, что это один и тотже объект. На этапе компиляции склеет эти части, увидит что получился тотже самый объект, который ранее использовался.

Но на этапе компиляции вычисляются не любые выражения. 

public class Equality {

public static void main (String[] args) {
String s1 = "firefox" + "2.0";
String s2 = "firefox" + Math.sqrt(4.0); //на этапе выполнения будут созданы два независимых объекта

System.out.println(s1 == s2); //false
System.out.println(s1.equals(s2)); //true
}
}


---
Lesson32. Дефолтные значения в полях

Рассмотрим пример использования конструкции if для оптимизации ввода данных в текстовые поля.

Задание
Создать группу, с именем test1, а остальные поля пусть будут заполнены значениями по умолчанию. Не указывать в тесте явно. 

Можно использовать значение null. Когда в переменную присвается значение null , это означает, что она ни на какой объект не ссылается.


protected void type(By locator, String text) {
	click(locator);
	driver.findElement(locator).clear(); 
	driver.findElement(locator).sendKeys(text); //падает, предварительно очистив поле ввода 
}

Задание 
Если в качестве текста передано значение null, то это поле ввода вообще не нужно трогать.

было  	
  protected void type(By locator, String text) {
    click(locator);
    if (text == null) { // нужно проверить храниться ли в переменной ссылка на какой то объект (физ сравнение)

    } else {
    driver.findElement(locator).clear();
    driver.findElement(locator).sendKeys(text);
  }	
}	
	
стало
if (text != null) { 
  driver.findElement(locator).clear();
  driver.findElement(locator).sendKeys(text);
}	
}
}


---
Lesson33. Ленивое заполнение полей

Для того чтобы оставить поле неизменным, можно передать в качестве значение null. Это будет означать, что мы хотим оставить в поле то значение, которое в поле уже введено.


Если то значение, которое мы передали совпадает с тем, которое уже введено в поле ввода. Есть смысл провести проверку. 

Задание
Если в поле уже введено значение, то с этим полем делать ничего не нужно



По правилам web приложений тот текст которым видим в поле ввода, является значением атрибута value

А обычный метод getText() для полей ввода всегда возвращает пустую строчку. Метод getText() используется для всех остальных элементов, кроме полей ввода. 


protected void type(By locator, String text) {
click(locator);
if (text != null) {
  String existingText = driver.findElement(locator).getAttribute("value"); //извлекаем из поля то значение, которое храниться
  if (! text.equals(existingText)) { //если неверно что текст совпадает с уже существующим текстом
	driver.findElement(locator).clear();
	driver.findElement(locator).sendKeys(text);}
  }
} 

Если нужно чтобы тесты работали быстро, есть большие поля ввода куда вводится длинный текст, тогда сделать такую доп проверку не помешает. 
Selenium вводит текст по символьно. 

---
Lesson34. Исключения. Перехват и обработка

Исключение - это информация выводящаяся на консоль при падении программы. Информация о том, где произошел сбой, в каком файле, строчке.

Конструкция if часто используется чтобы предотвратить возникновение исключения.

В нормальном состоянии выполнение метода завершается либо от дошел до самого конца }, которая ограничивает тело метода. Либо если в коде встретилось слово return.

Стек вызовов - цепочка методов, которые вызывают друг друга

Читать удобно снизу вверх. 

main главная функция, которая запускается когда мы стартуем какую нибудб программу.
В последнем методе, который упоминается в стеке вызовов произошла ошибка. 
Причем ошибка настолько серьезная, что дальнейшая работа программы стала невозможной. 
Несмотря на то, что в последнем методе нет слово return, java должная прекратить выполнение этого метода. 
Java прекращает выполнение этого метода аварийно. То есть вышестоящий метод получает сообщение о том, что вызванный метод завершился аварийно. 
И вместе с этим сообщением получает специальный объект, который содержит информацию о возникшей проблеме. Этот объект называется исключением.
А преждевременный возврат из функции называется выбросом исключением. 

Последняя функция выбросила исключение и при этом ее работа прервалась.
Предпоследняя функция, которая обращалась к проблемной , тоже не может продолжать, поэтому она пробрасывает исключение дальше. 
В свою очередь предшествующий метод тоже аварийно прерывается, и пробрасывает ислючение еще выше 
И так ислючение постепенно летит вверх пока не долетает до места где оно будет перехвачено.

В тестовом фрейфорке есть механизм, который позволяет эту цепочку аварийных прерываний остановить, исключение перехватить, проанализировать и обработать.
Тестовый фреймворк ловит исключение, записывает в отчет, выводит на консоль, и продолжает выполнять следующие тесты. 
 
Синие функции - те что в нашем проекте	
Серые - какие то библиотеки	(selenium)

Код серых библиотек нам не доступен, мы ее исправить не можем
Поэтому если внутри этой библиотеки возникает ислючение, мы можем:
- попытаться это предотвратить, написав какие то проверки и не допустить обращение к методу sendKeys() с плохими данными;
- обратиться к фукнкции sendKeys и попытаться перехватить те исключения, которые могут быть выброшены во время ее работы (устранить последствия).

Метод isAlertPresent() позволяет проверить наличие диалогового окна, которое иногда возникает на странице web приложений.
Библиотека selenium не предлагает способа проверить наличие / отсутствие этого диалогового окна
	
	
public boolean isAlertPresent() {
  try { //пытаемся выполнить блок кода
	driver.switchTo().alert(); //если окно есть, то успешно переключимся. все Ок
	return true; //а если не получилось и возникло исключение
  } catch (NoAlertPresentException e) { // если окна нет, то возникает исключения типа NoAlertPresentException. Перехватываем его и тоже все Ок. другого типа не перехватим.
	return false; 
  }
}	

Предотвратить появление ислючения нельзя. Вынуждены устранять последствия. 	
Это аварийное прерывание не будет распостраняться дальше. 
Те функции которые обращаются к isAlertPresent(), вместо прерывания и исключения получат нормальное возвращаемое значение true / false
	
Типы исключений бывают разные:	
- при выполнении недопустимых арифметических действий, поделить на 0
- преобразование строки в число, если при этом строка не может быть преобразована в число
- использование переменной, которая не проинициализирована NullPointerException
- при поиске несуществующего элемента 

---
Lesson 35. Почти одикановые формы

Имеется две почти одинаковые формы. В форме для редактирования контакта отсутствует поле выбора группы с выподающим списком.





























	
	
	
	
	




